[
    {
      "Program_name": "task_func_01",
      "Cobol_Eval": "Write a COBOL program that processes soccer match statistics. The program should:\n\n1. Read match data from an input file named 'match_data.ps', which contains records with team name, goals scored, and penalties received. \n\n2. Update the match data by adding additional goals and penalties for each team based on data stored in the program. This additional data should be stored in two separate tables, one for goals and one for penalties.\n\n3. Write the updated records to a temporary file named 'temp.ps'. \n\n4. After processing all records from the input file, add any new teams from the additional data tables to the temporary file if they don't already exist in the input data.\n\n5. Copy the updated data from the temporary file to the output file named 'updated_match_data.ps'.\n\n6. Display the total goals and total penalties from the updated data.\n\nEnsure the generated COBOL program adheres to the following requirements:\n\n1. The program must be a valid COBOL program.\n\n2. Use the standard COBOL division structure (IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION). \n\n3. Follow COBOL Area A and Area B conventions for division headers, paragraph names, and statements.\n\n4. Apply standard COBOL indentation to improve readability, especially in the PROCEDURE DIVISION.\n\nThe input file is 'match_data.ps', and the output file should be 'updated_match_data.ps'. A temporary file 'temp.ps' should be used for intermediate processing.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SOCCER-STATS-PROCESSOR.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'match_data.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'updated_match_data.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT TEMP-FILE\n               ASSIGN TO 'temp.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n           05 IN-TEAM            PIC X(20).\n           05 IN-GOALS           PIC 9(3).\n           05 IN-PENALTIES       PIC 9(3).\n\n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD.\n           05 OUT-TEAM           PIC X(20).\n           05 OUT-GOALS          PIC 9(3).\n           05 OUT-PENALTIES      PIC 9(3).\n\n       FD TEMP-FILE.\n       01 TEMP-RECORD.\n           05 TEMP-TEAM          PIC X(20).\n           05 TEMP-GOALS         PIC 9(3).\n           05 TEMP-PENALTIES     PIC 9(3).\n\n       WORKING-STORAGE SECTION.\n       01 WS-EOF                 PIC X VALUE 'N'.\n       01 WS-FOUND              PIC X VALUE 'N'.\n       01 WS-TOTAL-GOALS        PIC 9(5) VALUE 0.\n       01 WS-TOTAL-PENALTIES    PIC 9(5) VALUE 0.\n\n       01 WS-ADDITIONAL-GOALS.\n           05 OCCURS 5 TIMES.\n               10 ADD-TEAM       PIC X(20).\n               10 ADD-GOALS      PIC 9(3).\n\n       01 WS-ADDITIONAL-PENALTIES.\n           05 OCCURS 5 TIMES.\n               10 PEN-TEAM       PIC X(20).\n               10 PEN-PENALTIES  PIC 9(3).\n       01  WS-IDX                PIC 9(2).\n\n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZE-ARRAYS\n           PERFORM PROCESS-FILES\n           PERFORM DISPLAY-TOTALS\n           STOP RUN.\n\n       INITIALIZE-ARRAYS.\n           MOVE 'Team A' TO ADD-TEAM(1)\n           MOVE 3 TO ADD-GOALS(1)\n           MOVE 'Team B' TO ADD-TEAM(2)\n           MOVE 2 TO ADD-GOALS(2)\n           MOVE 'Team C' TO ADD-TEAM(3)\n           MOVE 1 TO ADD-GOALS(3)\n           MOVE 'Team D' TO ADD-TEAM(4)\n           MOVE 0 TO ADD-GOALS(4)\n           MOVE 'Team E' TO ADD-TEAM(5)\n           MOVE 2 TO ADD-GOALS(5)\n\n           MOVE 'Team A' TO PEN-TEAM(1)\n           MOVE 1 TO PEN-PENALTIES(1)\n           MOVE 'Team B' TO PEN-TEAM(2)\n           MOVE 0 TO PEN-PENALTIES(2)\n           MOVE 'Team C' TO PEN-TEAM(3)\n           MOVE 2 TO PEN-PENALTIES(3)\n           MOVE 'Team D' TO PEN-TEAM(4)\n           MOVE 3 TO PEN-PENALTIES(4)\n           MOVE 'Team E' TO PEN-TEAM(5)\n           MOVE 1 TO PEN-PENALTIES(5).\n\n       PROCESS-FILES.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT TEMP-FILE\n           WRITE TEMP-RECORD FROM 'team,goals,penalties'\n           PERFORM UNTIL WS-EOF = 'Y'\n               READ INPUT-FILE\n                   AT END\n                       MOVE 'Y' TO WS-EOF\n                   NOT AT END\n                       PERFORM UPDATE-RECORD\n               END-READ\n           END-PERFORM\n           CLOSE INPUT-FILE\n           \n           PERFORM ADD-NEW-TEAMS\n           \n           CLOSE TEMP-FILE\n           \n           PERFORM COPY-TEMP-TO-OUTPUT\n           .\n\n       UPDATE-RECORD.\n           MOVE SPACES TO TEMP-RECORD\n           MOVE IN-TEAM TO TEMP-TEAM\n           MOVE IN-GOALS TO TEMP-GOALS\n           MOVE IN-PENALTIES TO TEMP-PENALTIES\n           \n           PERFORM VARYING WS-IDX FROM 1 BY 1 UNTIL WS-IDX > 5\n               IF IN-TEAM = ADD-TEAM(WS-IDX)\n                   ADD ADD-GOALS(WS-IDX) TO TEMP-GOALS\n                   ADD PEN-PENALTIES(WS-IDX) TO TEMP-PENALTIES\n               END-IF\n           END-PERFORM\n           \n           ADD TEMP-GOALS TO WS-TOTAL-GOALS\n           ADD TEMP-PENALTIES TO WS-TOTAL-PENALTIES\n           \n           WRITE TEMP-RECORD\n           .\n\n       ADD-NEW-TEAMS.\n           MOVE 'N' TO WS-EOF   \n           PERFORM VARYING WS-IDX FROM 1 BY 1 UNTIL WS-IDX > 5\n               MOVE SPACES TO TEMP-RECORD\n               MOVE 'N' TO WS-FOUND\n               \n               PERFORM CHECK-TEAM-EXISTS\n               IF WS-FOUND = 'N'\n                   \n                   MOVE ADD-TEAM(WS-IDX) TO TEMP-TEAM\n                   MOVE ADD-GOALS(WS-IDX) TO TEMP-GOALS\n                   \n                   MOVE PEN-PENALTIES(WS-IDX) TO TEMP-PENALTIES\n                   ADD TEMP-GOALS TO WS-TOTAL-GOALS\n                   ADD TEMP-PENALTIES TO WS-TOTAL-PENALTIES\n                   WRITE TEMP-RECORD\n               END-IF\n           END-PERFORM\n           .\n\n       CHECK-TEAM-EXISTS.\n           OPEN INPUT INPUT-FILE\n                    \n           PERFORM UNTIL WS-EOF = 'Y'  \n                \n               READ INPUT-FILE\n                   AT END\n                       MOVE 'Y' TO WS-EOF\n                   NOT AT END\n                       IF  ADD-TEAM(WS-IDX) = IN-TEAM\n                            \n\n                           MOVE 'Y' TO WS-FOUND\n                       END-IF\n               END-READ\n           END-PERFORM\n           CLOSE INPUT-FILE\n           MOVE 'N' TO WS-EOF\n           .\n\n       COPY-TEMP-TO-OUTPUT.\n           OPEN INPUT TEMP-FILE\n           OPEN OUTPUT OUTPUT-FILE\n           PERFORM UNTIL WS-EOF = 'Y'\n               READ TEMP-FILE\n                   AT END\n                       MOVE 'Y' TO WS-EOF\n                   NOT AT END\n                       WRITE OUTPUT-RECORD FROM TEMP-RECORD\n               END-READ\n           END-PERFORM\n           CLOSE TEMP-FILE\n           CLOSE OUTPUT-FILE\n           .\n\n       DISPLAY-TOTALS.\n           DISPLAY 'Counter({'\n           DISPLAY '\"goals\": ' WS-TOTAL-GOALS\n           DISPLAY '\"penalties\": ' WS-TOTAL-PENALTIES\n           DISPLAY '})'\n           .",
      "input_file_names": [
        "match_data.ps",
        "temp.ps"
      ],
      "output_file_names": "updated_match_data.ps",
      "inputs": {
        "match_data.ps": "Team A              002001\nTeam C              001000\nTeam F              001001 ",
        "temp.ps": "team,goals,penalties\nTeam A              005002\nTeam C              002002\nTeam F              001001\n\nTeam B              002000\nTeam D              000003\nTeam E              002001\n"
      },
      "outputs": {
        "updated_match_data.ps": "team,goals,penalties\nTeam A              005002\nTeam C              002002\nTeam F              001001\n\nTeam B              002000\nTeam D              000003\nTeam E              002001\n"
      }
    },
    {
      "Program_name": "task_func_02",
      "Cobol_Eval": "Write a COBOL program that reads a file named 'input.txt' containing filenames, checks if each filename has an extension of 'txt', 'doc', or 'docx', and if so, writes that filename to an output file named 'output.txt'. At the end, display the count of filenames that were moved to the output file.\n\nEnsure the COBOL program follows these requirements:\n1. It must be a valid COBOL program. \n2. Use the standard COBOL division structure:\n   IDENTIFICATION DIVISION. \n   ENVIRONMENT DIVISION.\n   DATA DIVISION.\n   PROCEDURE DIVISION.\n3. Follow COBOL coding conventions:\n   - Division headers and paragraph names in Area A (columns 8-11)  \n   - Statements in Area B (columns 12-72)\n4. Use standard COBOL indentation, especially in the PROCEDURE DIVISION, to enhance readability.\n\nThe program should open the input file, read filenames one at a time, check each filename's extension pattern, write matching filenames to the output file, keep count of the moved filenames, close both files when done, and display the final count of moved filenames.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. FILE-PATTERN-MOVE.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 FILENAME-IN    PIC X(100).\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 FILENAME-OUT   PIC X(100).\n           \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05 WS-EOF-FLAG    PIC X VALUE 'N'.\n              88 END-OF-FILE VALUE 'Y'.\n           \n       01  WS-COUNTERS.\n           05 WS-MOVED-COUNT PIC 9(5) VALUE 0.\n           \n       01  WS-FILENAME-VARS.\n           05 WS-EXTENSION   PIC X(5).\n           05 WS-DOT-POS     PIC 9(3).\n           \n       01  WS-PATTERN-MATCH  PIC X VALUE 'N'.\n          88 PATTERN-MATCHES VALUE 'Y'.\n          \n       PROCEDURE DIVISION.\n       0100-MAIN-PARA.\n           PERFORM 1000-INIT-PARA\n           PERFORM 2000-PROCESS-FILES UNTIL END-OF-FILE\n           PERFORM 3000-CLOSE-PARA\n           STOP RUN.\n           \n       1000-INIT-PARA.\n           OPEN INPUT  INPUT-FILE\n                OUTPUT OUTPUT-FILE.\n           \n       2000-PROCESS-FILES.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF-FLAG\n               NOT AT END\n                   PERFORM 2100-CHECK-PATTERN\n                   IF PATTERN-MATCHES\n                       PERFORM 2200-MOVE-FILE\n                   END-IF\n           END-READ.\n           \n       2100-CHECK-PATTERN.\n           MOVE 'N' TO WS-PATTERN-MATCH\n           \n           *> Find the position of the last dot in filename\n           PERFORM VARYING WS-DOT-POS FROM 100 BY -1\n               UNTIL WS-DOT-POS < 1 OR \n                     FILENAME-IN(WS-DOT-POS:1) = '.'\n               CONTINUE\n           END-PERFORM\n           \n           IF WS-DOT-POS > 0\n               MOVE FILENAME-IN(WS-DOT-POS + 1:) TO WS-EXTENSION\n               \n               *> Check if extension matches pattern\n               IF WS-EXTENSION = 'txt ' OR \n                  WS-EXTENSION = 'doc ' OR \n                  WS-EXTENSION = 'docx'\n                   MOVE 'Y' TO WS-PATTERN-MATCH\n               END-IF\n           END-IF.\n           \n       2200-MOVE-FILE.\n           MOVE FILENAME-IN TO FILENAME-OUT\n           WRITE OUTPUT-RECORD\n           ADD 1 TO WS-MOVED-COUNT.\n           \n       3000-CLOSE-PARA.\n           CLOSE INPUT-FILE\n                 OUTPUT-FILE\n           DISPLAY 'Number of files moved: ' WS-MOVED-COUNT.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "ABC.txt\nDetailsofprogramming.pdf\nCOBOLDocument.docx\n"
      },
      "outputs": {
        "output.txt": "ABC.txt\nCOBOLDocument.docx\n"
      }
    },
    {
      "Program_name": "task_func_03",
      "Cobol_Eval": "Write a valid COBOL program that follows the standard COBOL division structure (IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION). Adhere to COBOL formatting conventions, using Area A (columns 8-11) for division headers and paragraph names, and Area B (columns 12-72) for statements. Apply standard COBOL indentation, especially within the PROCEDURE DIVISION, to enhance readability.\n\nThe program should read a line of input from a file named \"task_func03_inp\". This input line will contain three single-digit numbers separated by commas. The program should validate that the input numbers are unique, positive, and that all three numbers are provided. If the input is invalid, display an appropriate error message.\n\nFor valid input, the program should calculate the factorial of each input number and compute the sum of these factorials. Write this factorial sum to an output file named \"task_func03_out1\".\n\nAdditionally, the program should generate all possible permutations of the three input numbers, formatting each permutation as \"(X, Y, Z)\" where X, Y, and Z represent the numbers in a specific order. Write these formatted permutations, one per line, to a second output file named \"task_func03_out2\".\n\nAfter processing the input, the program should close all files and terminate gracefully. The program's purpose is to demonstrate basic input validation, mathematical calculations (factorials), and generation of permutations in COBOL, while adhering to COBOL coding standards and best practices.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. PERMUTATION-FACTORIAL-SUM.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE ASSIGN TO \"task_func03_inp\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE-1 ASSIGN TO \"task_func03_out1\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE-2 ASSIGN TO \"task_func03_out2\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n           05 INPUT-NUMBERS PIC X(5).\n\n       FD OUTPUT-FILE-1.\n       01 OUTPUT-RECORD-1.\n           05 FACTORIAL-SUM PIC 9(10).\n\n       FD OUTPUT-FILE-2.\n       01 OUTPUT-RECORD-2.\n           05 PERMUTATION PIC X(11).\n\n       WORKING-STORAGE SECTION.\n       01 WS-NUMBERS.\n           05 WS-NUMBER   PIC 9.\n           05 WS-NUMBER-1 PIC 9.\n           05 WS-NUMBER-2 PIC 9.\n           05 WS-NUMBER-3 PIC 9.\n           05 WS-STR-CN1  PIC 9.\n           05 WS-STR-CN2  PIC 9.\n           05 WS-STR-CN3  PIC 9.\n           05 WS-CNT          PIC 9.\n           05 WS-MAX-COUNT    PIC 9 VALUE 9.\n\n       01 WS-FACTORIAL-SUM PIC 9(10).\n       01 WS-I             PIC 9(02).\n       01 WS-NUM-FACT      PIC 9(07).\n       01 WS-NUM1-FACT     PIC 9(07).\n       01 WS-NUM2-FACT     PIC 9(07).\n       01 WS-NUM3-FACT     PIC 9(07).\n       01 WS-PERMUTATION   PIC X(11).\n       01 WS-STR1-DELIM    PIC X.\n       01 WS-STR2-DELIM    PIC X.\n       01 WS-STR3-DELIM    PIC X.\n\n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           OPEN INPUT INPUT-FILE.\n           OPEN OUTPUT OUTPUT-FILE-1.\n           OPEN OUTPUT OUTPUT-FILE-2.\n\n           READ INPUT-FILE INTO INPUT-RECORD\n               AT END GO TO END-OF-FILE.\n\n           IF INPUT-NUMBERS IS EQUAL TO SPACES\n               GO TO END-OF-FILE.\n\n           UNSTRING INPUT-NUMBERS DELIMITED BY \",\"\n               INTO WS-NUMBER-1 COUNT IN WS-STR-CN1\n                    WS-NUMBER-2 COUNT IN WS-STR-CN2\n                    WS-NUMBER-3 COUNT IN WS-STR-CN3.\n         \n           IF (WS-NUMBER-1 = WS-NUMBER-2) OR \n              (WS-NUMBER-2 = WS-NUMBER-3) OR\n              (WS-NUMBER-3 = WS-NUMBER-1) \n               DISPLAY \"Error: Number has to be unique\"\n               GO TO END-OF-FILE\n           END-IF\n\n           IF WS-STR-CN1 >1  OR WS-STR-CN2 >1 OR WS-STR-CN3 > 1\n               DISPLAY \"Error: Negative numbers not allowed.\"\n               GO TO END-OF-FILE\n      \n           IF WS-STR-CN1  = 0 OR WS-STR-CN2 = 0 OR WS-STR-CN3 = 0\n              DISPLAY \"Error: Missing Input number\"\n              GO TO END-OF-FILE.\n\n           PERFORM GENERATE-PERMUTATIONS.\n\n           GO TO END-OF-FILE.\n\n       GENERATE-PERMUTATIONS.\n\n           MOVE WS-NUMBER-1 TO WS-NUMBER\n           PERFORM CALCULATE-FACTORIAL\n           MOVE WS-NUM-FACT TO WS-NUM1-FACT\n              \n           MOVE WS-NUMBER-2 TO WS-NUMBER\n           PERFORM CALCULATE-FACTORIAL\n           MOVE WS-NUM-FACT TO WS-NUM2-FACT\n\n           MOVE WS-NUMBER-3 TO WS-NUMBER\n           PERFORM CALCULATE-FACTORIAL\n           MOVE WS-NUM-FACT TO WS-NUM3-FACT\n\n           COMPUTE WS-FACTORIAL-SUM =\n                   WS-NUM1-FACT +\n                   WS-NUM2-FACT +\n                   WS-NUM3-FACT\n           MOVE WS-FACTORIAL-SUM TO FACTORIAL-SUM\n           WRITE OUTPUT-RECORD-1\n\n           PERFORM PERMUTE-NUMBERS.\n          \n        PERMUTE-NUMBERS.            \n            \n               STRING \"(\" WS-NUMBER-1 \", \" WS-NUMBER-2 \", \"\n                      WS-NUMBER-3 \")\" INTO WS-PERMUTATION\n               MOVE WS-PERMUTATION TO PERMUTATION\n               WRITE OUTPUT-RECORD-2.\n\n                STRING \"(\" WS-NUMBER-1 \", \" WS-NUMBER-3 \", \"\n                      WS-NUMBER-2 \")\" INTO WS-PERMUTATION\n               MOVE WS-PERMUTATION TO PERMUTATION\n               WRITE OUTPUT-RECORD-2.\n               \n               STRING \"(\" WS-NUMBER-2 \", \" WS-NUMBER-3 \", \"\n                      WS-NUMBER-1 \")\" INTO WS-PERMUTATION\n               MOVE WS-PERMUTATION TO PERMUTATION\n               WRITE OUTPUT-RECORD-2.\n\n               STRING \"(\" WS-NUMBER-2 \", \" WS-NUMBER-1 \", \"\n                      WS-NUMBER-3 \")\" INTO WS-PERMUTATION\n               MOVE WS-PERMUTATION TO PERMUTATION\n               WRITE OUTPUT-RECORD-2.\n\n               STRING \"(\" WS-NUMBER-3 \", \" WS-NUMBER-2 \", \"\n                      WS-NUMBER-1 \")\" INTO WS-PERMUTATION\n               MOVE WS-PERMUTATION TO PERMUTATION\n               WRITE OUTPUT-RECORD-2.\n\n                STRING \"(\" WS-NUMBER-3 \", \" WS-NUMBER-1 \", \"\n                      WS-NUMBER-2 \")\" INTO WS-PERMUTATION\n               MOVE WS-PERMUTATION TO PERMUTATION\n               WRITE OUTPUT-RECORD-2.\n\n\n       CALCULATE-FACTORIAL.\n           IF WS-NUMBER EQUAL TO 0\n               MOVE 1 TO WS-NUM-FACT\n           ELSE\n               MOVE 1 TO WS-NUM-FACT\n               PERFORM VARYING WS-I FROM 1 BY 1 UNTIL WS-I > WS-NUMBER \n                       COMPUTE WS-NUM-FACT = WS-I * WS-NUM-FACT\n               END-PERFORM\n            .      \n\n       END-OF-FILE.\n           CLOSE INPUT-FILE.\n           CLOSE OUTPUT-FILE-1.\n           CLOSE OUTPUT-FILE-2.\n           STOP RUN.\n",
      "input_file_names": "task_func03_inp",
      "output_file_names": [
        "task_func03_out1",
        "task_func03_out2"
      ],
      "inputs": {
        "task_func03_inp": "0,2,3"
      },
      "outputs": {
        "task_func03_out1": "0000000009\n",
        "task_func03_out2": "(0, 2, 3)\n(0, 3, 2)\n(2, 3, 0)\n(2, 0, 3)\n(3, 2, 0)\n(3, 0, 2)\n"
      }
    },
    {
      "Program_name": "task_func_04",
      "Cobol_Eval": "Write a COBOL program that processes a file containing filenames (input.txt), moves files with valid extensions (.txt, .csv, .xlsx) to an output file (output.txt), and records invalid filenames and their reason for rejection in an error file (error.txt). \n\nThe program should follow this structure:\n- IDENTIFICATION DIVISION with PROGRAM-ID\n- ENVIRONMENT DIVISION \n  - INPUT-OUTPUT SECTION\n    - FILE-CONTROL paragraph to ASSIGN input, output and error files\n- DATA DIVISION\n  - FILE SECTION to define record layouts of files\n  - WORKING-STORAGE SECTION for internal data items  \n- PROCEDURE DIVISION with paragraphs to:\n  - PERFORM initialization \n  - PERFORM file processing until end-of-file\n    - READ input record\n    - CHECK filename extension \n    - IF valid, WRITE record to output file\n    - ELSE WRITE error message to error file\n  - PERFORM wrap-up\n  - STOP RUN\n\nUse proper COBOL coding conventions:  \n- Area A (columns 8-11) for division headers, section names, paragraph names\n- Area B (columns 12-72) for statements\n- Consistent indentation, especially in PROCEDURE DIVISION\n\nDisplay counts of successfully moved files and rejected files at the end.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. FILE-MOVER.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT ERROR-FILE\n               ASSIGN TO 'error.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 FILENAME-IN    PIC X(100).\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 FILENAME-OUT   PIC X(100).\n           \n       FD  ERROR-FILE.\n       01  ERROR-RECORD.\n           05 ERROR-MSG      PIC X(100).\n           \n       WORKING-STORAGE SECTION.\n       01  WS-VARIABLES.\n           05 WS-EOF-FLAG    PIC X VALUE 'N'.\n              88 END-OF-FILE VALUE 'Y'.\n           05 WS-MOVED-COUNT PIC 9(5) VALUE 0.\n           05 WS-ERROR-COUNT PIC 9(5) VALUE 0.\n           \n       01  WS-FILENAME-PARTS.\n           05 WS-NAME        PIC X(95).\n           05 WS-DOT        PIC X.\n           05 WS-EXTENSION  PIC X(4).\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-FILES UNTIL END-OF-FILE\n           PERFORM WRAP-UP\n           STOP RUN.\n           \n       INITIALIZATION.\n           OPEN INPUT  INPUT-FILE\n                OUTPUT OUTPUT-FILE\n                OUTPUT ERROR-FILE.\n                \n       PROCESS-FILES.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF-FLAG\n               NOT AT END\n                   PERFORM PROCESS-SINGLE-FILE\n           END-READ.\n           \n       PROCESS-SINGLE-FILE.\n           UNSTRING FILENAME-IN DELIMITED BY '.'\n               INTO WS-NAME\n                    WS-EXTENSION\n           END-UNSTRING\n           display 'ws-extension:' ws-extension\n           IF WS-EXTENSION = 'txt' OR \n              WS-EXTENSION = 'csv' OR \n              WS-EXTENSION = 'xlsx'\n               PERFORM MOVE-VALID-FILE\n           ELSE\n               PERFORM RECORD-INVALID-FILE\n           END-IF.\n           \n       MOVE-VALID-FILE.\n           MOVE FILENAME-IN TO FILENAME-OUT\n           WRITE OUTPUT-RECORD\n           display 'output:' output-record\n           ADD 1 TO WS-MOVED-COUNT\n           .\n           \n       RECORD-INVALID-FILE.\n           initialize error-msg\n           STRING 'Invalid extension for file: ' delimited by size,\n                  FILENAME-IN delimited by spaces,\n                  '  Expected txt, csv, or xlsx'\n               INTO ERROR-MSG\n           display 'error is:' error-record\n           WRITE ERROR-RECORD\n           \n           ADD 1 TO WS-ERROR-COUNT\n           .\n           \n       WRAP-UP.\n           DISPLAY 'Processing Complete'\n           DISPLAY 'Files successfully moved: ' WS-MOVED-COUNT\n           DISPLAY 'Files rejected: ' WS-ERROR-COUNT\n           \n           CLOSE INPUT-FILE\n                 OUTPUT-FILE\n                 ERROR-FILE\n           .\n",
      "input_file_names": [
        "input.txt",
        "error.txt"
      ],
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "ABC.txt\nMyfiletest.csv\nMyfilecobol.pdf",
        "error.txt": "Invalid extension for file: Myfilecobol.pdf  Expected txt, csv, or xlsx\n"
      },
      "outputs": {
        "output.txt": "ABC.txt\nMyfiletest.csv\n"
      }
    },
    {
      "Program_name": "task_func_05",
      "Cobol_Eval": "Write a valid COBOL program that reads an input file named 'input.txt' containing records with a filename and status, and writes the filename to an output file named 'output.txt' if the status is 'processed'. The program should follow the standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE DIVISION), adhere to Area A and Area B conventions for division headers, paragraph names, and statements, and use standard COBOL indentation to improve readability. \n\nIn the IDENTIFICATION DIVISION, assign the program a name. \n\nIn the ENVIRONMENT DIVISION, define the INPUT-OUTPUT SECTION to specify the input and output files as LINE SEQUENTIAL organization and assign them to 'input.txt' and 'output.txt' respectively.\n\nIn the DATA DIVISION, define the FILE SECTION with descriptions of the input and output record structures, and the WORKING-STORAGE SECTION to define flags, counters, and work areas needed by the program.\n\nIn the PROCEDURE DIVISION, define the main process that initializes the files, reads and processes records from the input file until end-of-file, checking each record's status, writing 'processed' records to the output file, counting the records written, and closing the files after processing. Display the count of processed records.\n\nThe program should handle errors gracefully and display appropriate messages. Aim for clean, readable, maintainable code.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. FILE-ARCHIVER.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 INPUT-FILENAME      PIC X(20).\n           05 INPUT-STATUS       PIC X(20).\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD         PIC X(50).\n       \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05 WS-EOF-FLAG        PIC X VALUE 'N'.\n           05 WS-PROCESSED-FLAG  PIC X VALUE 'N'.\n           \n       01  WS-COUNTERS.\n           05 WS-MOVED-FILES     PIC 9(4) VALUE 0.\n           \n       01  WS-WORK-AREAS.\n           05 WS-FILENAME        PIC X(50).\n           05 WS-STATUS          PIC X(20).\n           \n       PROCEDURE DIVISION.\n       100-MAIN-PROCESS.\n           PERFORM 200-INIT-ROUTINE\n           PERFORM 300-PROCESS-FILES UNTIL WS-EOF-FLAG = 'Y'\n           PERFORM 400-CLOSE-ROUTINE\n           STOP RUN.\n           \n       200-INIT-ROUTINE.\n           OPEN INPUT  INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE\n           MOVE 'N' TO WS-EOF-FLAG.\n           \n       300-PROCESS-FILES.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF-FLAG\n               NOT AT END\n                   PERFORM 310-CHECK-PROCESSED\n           END-READ.\n           \n       310-CHECK-PROCESSED.\n           MOVE INPUT-FILENAME TO WS-FILENAME\n           MOVE INPUT-STATUS TO WS-STATUS\n           \n           IF WS-STATUS = 'processed'\n               PERFORM 320-WRITE-TO-OUTPUT\n           END-IF.\n           \n       320-WRITE-TO-OUTPUT.\n           MOVE WS-FILENAME TO OUTPUT-RECORD\n           WRITE OUTPUT-RECORD\n           ADD 1 TO WS-MOVED-FILES\n           DISPLAY 'Processed file: ' WS-FILENAME.\n           \n       400-CLOSE-ROUTINE.\n           DISPLAY 'Total files processed: ' WS-MOVED-FILES\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "document1.txt       processed\nreport.doc          not processed\nnotes.docx          processed\nimage.png           not processed"
      },
      "outputs": {
        "output.txt": "document1.txt\nnotes.docx\n"
      }
    },
    {
      "Program_name": "task_func_07",
      "Cobol_Eval": "Write a valid COBOL program that assigns tasks to employees and generates an output file with the task assignments. The program should:\n\n1. Follow the standard COBOL division structure with IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE divisions. \n\n2. Use proper COBOL formatting conventions, with division headers and paragraph names in Area A (columns 8-11) and statements in Area B (columns 12-72).\n\n3. Indent code appropriately, especially in the PROCEDURE DIVISION, to improve readability.\n\nThe program will:\n\n- Read a number of tasks to assign from the command line \n- Read task descriptions from an input file named 'task_func_07_inp1'\n- Read employee names from an input file named 'task_func_07_inp2' \n- If no employees are provided, use a default list of 5 employees\n- Randomly assign each task to an employee\n- Format the task description by replacing spaces with underscores\n- Get the current date and format it as YYYY-MM-DD \n- Write each task assignment to an output file named 'task_func07_out' with the formatted task name, assigned employee, and due date\n- Include error handling if the number of tasks is negative or exceeds the number of tasks in the input file\n- Close all files after processing\n\nThe output file should have a header row labeling the columns. Each detail row should have the formatted task name, employee assigned, and due date, with columns separated by two spaces.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. TASK-ASSIGNMENT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT TASK-INPUT ASSIGN TO 'task_func_07_inp1'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT EMP-INPUT ASSIGN TO 'task_func_07_inp2'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE ASSIGN TO 'task_func07_out'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  TASK-INPUT.\n       01  TASK-RECORD.\n           05 TASK-DESC    PIC X(50).\n           \n       FD  EMP-INPUT.\n       01  EMP-RECORD.\n           05 EMP-NAME     PIC X(50).\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 OUT-TASK     PIC X(50).\n           05 FILLER       PIC X(2) VALUE SPACES.\n           05 OUT-EMP      PIC X(50).\n           05 FILLER       PIC X(2) VALUE SPACES.\n           05 OUT-DATE     PIC X(10).\n           \n       WORKING-STORAGE SECTION.\n       01  WS-CURRENT-DATE.\n           05 WS-YEAR      PIC 9(4).\n           05 WS-MONTH     PIC 9(2).\n           05 WS-DAY       PIC 9(2).\n           \n       01  WS-FORMATTED-DATE PIC X(10).\n       01  WS-TSK-EOF       PIC X VALUE 'N'.\n       01  WS-EMP-EOF       PIC X VALUE 'N'.\n       01  WS-N-TASKS       PIC 9(4) VALUE 0.    \n       01  WS-TASK-COUNT    PIC 9(4) VALUE 0.\n       01  WS-EMP-COUNT     PIC 9(4) VALUE 0.      \n       01  WS-SEED          PIC 9(8).\n       01  WS-RANDOM        PIC 9(8).\n       \n       01  WS-DEFAULT-EMPS.\n           05 WS-EMP-LIST OCCURS 100 TIMES.\n               10 WS-EMP-NAME PIC X(50).\n               \n       01  WS-HEADER.\n           05 FILLER       PIC X(10) VALUE 'Task Name'.\n           05 FILLER       PIC X(12) VALUE SPACES.\n           05 FILLER       PIC X(11) VALUE 'Assigned To'.\n           05 FILLER       PIC X(11) VALUE SPACES.\n           05 FILLER       PIC X(8)  VALUE 'Due Date'.\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-EMPLOYEE\n           PERFORM PROCESS-TASKS\n           PERFORM CLEANUP\n           STOP RUN.\n           \n       INITIALIZATION.\n                     \n\t   ACCEPT WS-N-TASKS FROM COMMAND-LINE\n\n           IF WS-N-TASKS < 0\n               DISPLAY \"Error: Number of tasks cannot be negative\"\n               STOP RUN\n           END-IF\n\n           ACCEPT WS-CURRENT-DATE FROM DATE YYYYMMDD\n           STRING WS-YEAR DELIMITED BY SIZE\n                  \"-\"    DELIMITED BY SIZE\n                  WS-MONTH DELIMITED BY SIZE\n                  \"-\"    DELIMITED BY SIZE\n                  WS-DAY  DELIMITED BY SIZE\n               INTO WS-FORMATTED-DATE\n           \n           OPEN INPUT TASK-INPUT\n                      EMP-INPUT\n                OUTPUT OUTPUT-FILE\n           \n           WRITE OUTPUT-RECORD FROM WS-HEADER.\n           \n       PROCESS-EMPLOYEE.\n\n           PERFORM UNTIL WS-EMP-EOF = 'Y'               \n                   READ EMP-INPUT \n                      AT END MOVE 'Y' TO WS-EMP-EOF\n                   NOT AT END\n                      ADD 1           TO WS-EMP-COUNT\n                      MOVE EMP-NAME   TO WS-EMP-NAME(WS-EMP-COUNT)\n           END-PERFORM\n                                 \n           IF WS-EMP-COUNT = 0\n              PERFORM LOAD-DEFAULT-EMPLOYEES\n           END-IF\n           .\n\t   \n       LOAD-DEFAULT-EMPLOYEES.\n           MOVE \"John Doe\"      TO WS-EMP-NAME(1)\n           MOVE \"Jane Smith\"    TO WS-EMP-NAME(2)\n           MOVE \"James Brown\"   TO WS-EMP-NAME(3)\n           MOVE \"Mary Johnson\"  TO WS-EMP-NAME(4)\n           MOVE \"Robert Davis\"  TO WS-EMP-NAME(5).\n           \n       PROCESS-TASKS.\n           PERFORM UNTIL WS-TASK-COUNT >= WS-N-TASKS OR WS-TSK-EOF = 'Y'\n               READ TASK-INPUT\n                   AT END MOVE 'Y' TO WS-TSK-EOF\n                   NOT AT END\n                       ADD 1 TO WS-TASK-COUNT\n                       PERFORM ASSIGN-TASK\n               END-READ\n           END-PERFORM\n           \n\t   IF WS-N-TASKS > WS-TASK-COUNT\n               DISPLAY \"Error: No of tasks cannot be more than in file\"\n               STOP RUN\n           END-IF.\n\n       ASSIGN-TASK.\n           MOVE SPACES TO OUTPUT-RECORD\n           PERFORM SANITIZE-TASK-NAME\n           COMPUTE WS-RANDOM = FUNCTION RANDOM * 5 + 1\n           MOVE WS-EMP-NAME(WS-RANDOM) TO OUT-EMP\n           MOVE WS-FORMATTED-DATE      TO OUT-DATE\n           WRITE OUTPUT-RECORD.\n           \n       SANITIZE-TASK-NAME.\n           INSPECT TASK-DESC REPLACING ALL ' ' BY '_'\n           MOVE TASK-DESC TO OUT-TASK.\n           \n       CLEANUP.\n           CLOSE TASK-INPUT\n                 EMP-INPUT\n                 OUTPUT-FILE.\n",
      "input_file_names": [
        "task_func_07_inp1",
        "task_func_07_inp2"
      ],
      "output_file_names": "task_func07_out",
      "inputs": {
        "task_func_07_inp1": "Create POC for IBM WatsonX AI\ncomparison study Github copilot vs Amazon Q\nCode cobol programs for eval (1-25)\ncode cobol programs for eval (26-50)\ntechnical paper on Legacy transformation\n",
        "task_func_07_inp2": "Rama\nJohn\nSai\nAfreen\nAngela\nPavan"
      },
      "outputs": {
        "task_func07_out": "Task Name             Assigned To           Due Date\n"
      }
    },
    {
      "Program_name": "task_func_08",
      "Cobol_Eval": "Write a COBOL program that converts the file extensions of filenames listed in an input file to '.csv' and writes the converted filenames to an output file. The program should adhere to the following requirements:\n\n1. Be a valid COBOL program with proper IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, and PROCEDURE DIVISION sections.\n\n2. Follow standard COBOL formatting conventions, with division headers and paragraph names in Area A (columns 8-11) and statements in Area B (columns 12-72). \n\n3. Use appropriate indentation, especially in the PROCEDURE DIVISION, to enhance readability.\n\n4. Read filenames from an input file named 'input.txt', convert those ending in '.txt', '.docx' or '.xlsx' to '.csv', and write the converted filenames to an output file named 'output.txt'.\n\n5. Display the total count of filenames converted after processing.\n\nThe program should efficiently process the list of filenames, performing the extension conversion and writing out the updated filenames line by line. Aim to minimize complexity while ensuring the program is well-structured and follows COBOL best practices.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. FILE-CONVERTER.\n      \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n      \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 INPUT-FILENAME    PIC X(100).\n      \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 OUTPUT-FILENAME   PIC X(100).\n      \n       WORKING-STORAGE SECTION.\n       01  WS-VARIABLES.\n           05 WS-FILE-COUNT     PIC 9(4) VALUE 0.\n           05 WS-EOF-FLAG       PIC X VALUE 'N'.\n           05 WS-FILENAME-LEN   PIC 9(3).\n           05 WS-EXTENSION      PIC X(5).\n           05 WS-BASE-FILENAME  PIC X(95).\n           05 WS-NEW-FILENAME   PIC X(100).\n      \n       LINKAGE SECTION.\n      \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-FILES UNTIL WS-EOF-FLAG = 'Y'\n           PERFORM CLEANUP\n           DISPLAY \"Total files converted: \" WS-FILE-COUNT\n           STOP RUN.\n      \n       INITIALIZATION.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n      \n       PROCESS-FILES.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF-FLAG\n               NOT AT END\n                   PERFORM PROCESS-SINGLE-FILE\n           END-READ.\n      \n       PROCESS-SINGLE-FILE.\n           MOVE SPACES TO WS-EXTENSION\n           MOVE SPACES TO WS-BASE-FILENAME\n           MOVE SPACES TO WS-NEW-FILENAME\n      \n           PERFORM GET-FILENAME-PARTS\n           \n           IF WS-EXTENSION(2:4) = '.txt ' OR \n              WS-EXTENSION = '.docx' OR\n              WS-EXTENSION = '.xlsx'\n               PERFORM CREATE-CSV-FILENAME\n               PERFORM WRITE-OUTPUT-FILE\n               ADD 1 TO WS-FILE-COUNT\n           END-IF.\n      \n       GET-FILENAME-PARTS.\n           MOVE FUNCTION TRIM(INPUT-FILENAME) TO INPUT-FILENAME\n           COMPUTE WS-FILENAME-LEN = \n               FUNCTION LENGTH(FUNCTION TRIM(INPUT-FILENAME))\n           \n           IF WS-FILENAME-LEN > 4\n               MOVE INPUT-FILENAME(WS-FILENAME-LEN - 4:5) \n                   TO WS-EXTENSION\n               MOVE INPUT-FILENAME(1:WS-FILENAME-LEN - 5) \n                   TO WS-BASE-FILENAME\n           END-IF.\n           DISPLAY 'FILEEXT: ' WS-EXTENSION\n           DISPLAY 'FILENAME:' WS-BASE-FILENAME.\n      \n       CREATE-CSV-FILENAME.\n           STRING WS-BASE-FILENAME DELIMITED BY SPACE\n                  '.csv' DELIMITED BY SIZE\n                  INTO WS-NEW-FILENAME.\n      \n       WRITE-OUTPUT-FILE.\n           MOVE WS-NEW-FILENAME TO OUTPUT-FILENAME\n           WRITE OUTPUT-RECORD FROM OUTPUT-FILENAME.\n      \n       CLEANUP.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n      \n       END PROGRAM FILE-CONVERTER.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "Mytest.xlsx\nabc.docx\npicture.jpg\nmyimage.png\ntest2file.txt"
      },
      "outputs": {
        "output.txt": "Mytest.csv\nabc.csv\ntest2fil.csv\n"
      }
    },
    {
      "Program_name": "task_func_09",
      "Cobol_Eval": "Create a valid COBOL program that reads numbers from an input file named 'input.txt', calculates statistics for each line and for the overall file, and writes the results to an output file named 'output.txt'. The program should adhere to the standard COBOL division structure (IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION) and follow COBOL formatting conventions for Area A (columns 8-11) and Area B (columns 12-72). Use standard COBOL indentation to improve readability.\n\nThe program should perform the following tasks:\n\n1. Read the input file line by line until the end of the file is reached.\n2. For each non-empty line, parse the comma-separated numbers and calculate the minimum, maximum, and sum of the numbers on that line. \n3. Write the calculated statistics for each line to the output file.\n4. Keep track of the overall minimum, maximum, and sum across all lines in the file.\n5. After processing all lines, write the overall statistics to the output file.\n\nHandle any necessary error conditions, such as an empty input file. Ensure the program opens and closes the input and output files properly.\n\nThe input file will contain lines of comma-separated numbers. The output file should contain the minimum, maximum, and sum for each line, followed by the overall minimum, maximum, and sum for the entire file.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. COMPUTE-STATS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n           01 INPUT-RECORD.\n               05 INPUT-LINE PIC X(100).\n       \n       FD OUTPUT-FILE.\n           01 OUTPUT-RECORD.\n               05 MIN-VAL-OUT    PIC 9(4).99.\n               05 SPACE1         PIC X(5) VALUE SPACES.\n               05 MAX-VAL-OUT    PIC 9(4).99.\n               05 SPACE2         PIC X(5) VALUE SPACES.\n               05 SUM-VAL-OUT    PIC 9(6).99.\n       \n       WORKING-STORAGE SECTION.\n       01 WS-FLAGS.\n           05 WS-EOF-FLAG        PIC X VALUE 'N'.\n           05 WS-VALID-DATA-FLAG PIC X VALUE 'Y'.\n       \n       01 WS-COUNTERS.\n           05 WS-NUM-COUNT       PIC 9(4) VALUE 0.\n           05 WS-POS             PIC 9(4) VALUE 1.\n           05 WS-IDX             PIC 9(4) VALUE 1.\n       \n       01 WS-NUMBERS.\n           05 WS-NUM-TABLE OCCURS 50 TIMES.\n               10 WS-NUM         PIC 9(9)V99.\n       \n       01 WS-CALCULATIONS.\n           05 WS-MIN-VAL        PIC 9(4)V99.\n           05 WS-MAX-VAL        PIC 9(4)V99.\n           05 WS-TEMP-MIN        PIC 9(4)V99.\n           05 WS-TEMP-MAX        PIC 9(4)V99.\n           05 WS-SUM            PIC 9(6)V99.\n           05 WS-TEMP-SUM       PIC 9(6)V99. \n           05 WS-GLOBAL-MIN     PIC 9(4)V99 VALUE 0.\n           05 WS-GLOBAL-MAX     PIC 9(4)V99 VALUE 0.\n           05 WS-GLOBAL-SUM     PIC 9(6)V99 VALUE ZERO.\n       \n       01 WS-TEMP.\n           05 WS-NUMBER         PIC X(20).\n           05 WS-NUM-DEC        PIC 9(9)V99.\n           05 L                 PIC 9(3).\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-DATA UNTIL WS-EOF-FLAG = 'Y'\n           PERFORM WRITE-GLOBAL-STATS\n           PERFORM CLEANUP\n           STOP RUN.\n       \n       INITIALIZATION.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE\n           IF WS-EOF-FLAG = 'Y'\n               DISPLAY 'Error: Empty input file'\n               STOP RUN\n           END-IF.\n       \n       PROCESS-DATA.\n           READ INPUT-FILE\n               AT END\n                    \n                   MOVE 'Y' TO WS-EOF-FLAG\n               NOT AT END \n                   display 'input file line:' INPUT-LINE\n                   IF INPUT-LINE <>  SPACES \n                      PERFORM PROCESS-LINE\n                   END-IF\n           END-READ.\n       \n       PROCESS-LINE.\n           MOVE 0 TO WS-NUM-COUNT\n           MOVE 1 TO WS-POS\n           INITIALIZE WS-NUMBERS\n           PERFORM PARSE-NUMBERS \n           PERFORM CALCULATE-STATS\n           PERFORM WRITE-STATS\n           \n           .\n       \n       PARSE-NUMBERS.\n            \n           MOVE 'Y' TO WS-VALID-DATA-FLAG\n           INITIALIZE WS-MIN-VAL, WS-MAX-VAL , WS-SUM , L\n           INSPECT FUNCTION REVERSE (INPUT-LINE) TALLYING L FOR\n           LEADING SPACES\n           \n           COMPUTE L = (LENGTH OF INPUT-LINE - L ) + 1\n            \n           PERFORM VARYING WS-IDX FROM 1 BY 1  UNTIL WS-IDX > (L) \n              \n            IF INPUT-LINE(WS-IDX:1) <> ','\n            and INPUT-LINE(WS-IDX:1) <> SPACES\n                \n               MOVE INPUT-LINE(WS-IDX:1) TO WS-NUMBER(WS-POS:1)\n               ADD 1 TO WS-POS\n            ELSE\n             \n               MOVE WS-NUMBER(1:WS-POS) TO    WS-TEMP-MIN\n                                              WS-TEMP-MAX\n                                              WS-TEMP-SUM\n              \n               IF WS-MIN-VAL = 0\n                  MOVE WS-TEMP-MIN TO WS-MIN-VAL\n                                       \n               END-IF\n               if ws-global-min = 0\n                  move ws-temp-min to ws-global-min\n               end-if \n\n               IF WS-MAX-VAL = 0\n                  MOVE WS-TEMP-MAX TO WS-MAX-VAL\n               END-IF   \n              \n               IF WS-NUMBER(1:WS-POS) < WS-MIN-VAL\n               AND WS-NUMBER(1:WS-POS) > 0\n                   MOVE WS-NUMBER(1:WS-POS) TO WS-MIN-VAL\n               END-IF\n               \n               IF WS-MIN-VAL < WS-GLOBAL-MIN\n                  MOVE WS-MIN-VAL TO      WS-GLOBAL-MIN\n               END-IF\n               IF WS-NUMBER(1:WS-POS) > WS-MAX-VAL \n               AND WS-NUMBER(1:WS-POS) > 0\n                    MOVE WS-NUMBER(1:WS-POS) TO WS-MAX-VAL\n               END-IF\n                   \n               ADD WS-TEMP-SUM TO WS-SUM\n               initialize ws-pos, ws-number\n               MOVE 1   TO WS-POS\n            END-IF\n            \n           END-PERFORM\n        \n            .\n\n              \n       \n       CALCULATE-STATS.\n            \n           \n           IF WS-MAX-VAL > WS-GLOBAL-MAX\n               MOVE WS-MAX-VAL TO WS-GLOBAL-MAX\n           END-IF\n           ADD WS-SUM TO WS-GLOBAL-SUM.\n       \n       WRITE-STATS.\n           \n           MOVE WS-MIN-VAL TO MIN-VAL-OUT\n           MOVE WS-MAX-VAL TO MAX-VAL-OUT\n           MOVE WS-SUM TO SUM-VAL-OUT\n           \n           MOVE '     ' TO SPACE1\n                           SPACE2\n           WRITE OUTPUT-RECORD.\n           \n       \n       WRITE-GLOBAL-STATS.\n          \n           MOVE WS-GLOBAL-MIN TO MIN-VAL-OUT\n           MOVE WS-GLOBAL-MAX TO MAX-VAL-OUT\n           MOVE WS-GLOBAL-SUM TO SUM-VAL-OUT\n           WRITE OUTPUT-RECORD.\n           \n       \n       CLEANUP.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "1,3,4,5     \n3,2,18,45,6                                                                                             "
      },
      "outputs": {
        "output.txt": "0001.00     0005.00     000013.00\n0003.00     0006.00     000074.00\n0001.00     0006.00     000087.00\n"
      }
    },
    {
      "Program_name": "task_func_10",
      "Cobol_Eval": "Write a COBOL program that reads population data from an input file named 'input.txt', validates the country names against a predefined list, and writes the country name and population to an output file named 'output.txt' if the country is valid and has a positive population.\n\nThe program should follow the standard COBOL division structure:\n- IDENTIFICATION DIVISION with PROGRAM-ID \n- ENVIRONMENT DIVISION defining input and output files\n- DATA DIVISION with FILE SECTION and WORKING-STORAGE SECTION\n- PROCEDURE DIVISION containing the program logic\n\nAdhere to COBOL coding conventions:\n- Division headers and paragraph names in Area A (columns 8-11) \n- Statements in Area B (columns 12-72)\n- Use consistent indentation, especially in PROCEDURE DIVISION\n\nThe input file contains records with the country name and population. The program should check if each country name exists in a table of valid countries defined in WORKING-STORAGE. If the country is valid and its population is greater than zero, write the country name and population to the output file.\n\nInclude appropriate error handling, such as checking for the end of the input file. Open the files, process the records, and close the files in separate paragraphs in the PROCEDURE DIVISION.\n\nThe output file should have a header line indicating the columns, and each detail line should show the country name and population separated by a colon and space.\n\nFocus on the overall functionality and flow of the program. The specific algorithms and detailed COBOL syntax are left to the implementer.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. POPULATION-REPORT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n           05 COUNTRY-NAME    PIC X(20).\n           05 FILLER         PIC X.\n           05 POPULATION     PIC 9(9).\n           \n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD.\n           05 OUT-COUNTRY    PIC X(20).\n           05 FILLER         PIC X(2) VALUE ': '.\n           05 OUT-POPULATION PIC 9(9).\n           \n       WORKING-STORAGE SECTION.\n       01 WS-FLAGS.\n           05 EOF-FLAG       PIC X VALUE 'N'.\n           \n       01 WS-VALID-COUNTRIES.\n           05 FILLER         PIC X(20) VALUE 'India'.\n           05 FILLER         PIC X(20) VALUE 'China'.\n           05 FILLER         PIC X(20) VALUE 'Sri Lanka'.\n       01 WS-COUNTRY-TABLE REDEFINES WS-VALID-COUNTRIES.\n           05 WS-VALID-COUNTRY PIC X(20) OCCURS 3 TIMES.\n           \n       01 WS-COUNTERS.\n           05 I              PIC 9 VALUE 1.\n           05 VALID-FLAG     PIC X VALUE 'N'.\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-RECORDS UNTIL EOF-FLAG = 'Y'\n           PERFORM CLEANUP\n           STOP RUN.\n           \n       INITIALIZATION.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE\n           WRITE OUTPUT-RECORD FROM 'Country   Population'\n           WRITE OUTPUT-RECORD FROM '--------------------'.\n           \n       PROCESS-RECORDS.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO EOF-FLAG\n               NOT AT END\n                   PERFORM VALIDATE-AND-WRITE\n           END-READ.\n           \n       VALIDATE-AND-WRITE.\n           display 'validate and write'\n           DISPLAY COUNTRY-NAME\n           DISPLAY POPULATION \n           MOVE 'N' TO VALID-FLAG\n           PERFORM VARYING I FROM 1 BY 1 until I > 3 \n               or VALID-FLAG = 'Y'\n               display 'country name:' country-name\n               IF COUNTRY-NAME = WS-VALID-COUNTRY(I) \n                   MOVE 'Y' TO VALID-FLAG \n               END-IF\n           END-PERFORM\n           \n           IF VALID-FLAG = 'Y'\n               display 'population:' population\n               IF POPULATION > 0\n                       MOVE COUNTRY-NAME TO OUT-COUNTRY\n                       MOVE POPULATION TO OUT-POPULATION\n                       display 'out-country' out-country\n                       display 'out-population ' out-population\n                       display 'output is:' output-record\n                       WRITE OUTPUT-RECORD\n                    \n               END-IF\n           END-IF.\n           \n       CLEANUP.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "India               331002651\nChina               67886011\nAfghanistan         755898\nSri Lanka           78854678\nJapan               145278"
      },
      "outputs": {
        "output.txt": "Country   Population\n--------------------\nIndia                 31002651\nChina                 7886011\nSri Lanka             8854678\n"
      }
    },
    {
      "Program_name": "task_func_11",
      "Cobol_Eval": "Write a valid COBOL program that reads a file named 'input.txt' containing filenames (one per line), analyzes each filename, and writes the results to an output file named 'output.txt'. For each input filename, determine and output the following:\n\n1. Whether the filename contains a '.' character, indicating it is a file \n2. Whether the filename contains any special characters besides letters, numbers, '_' or '.'\n3. Whether the filename contains any numeric characters\n\nThe program should follow standard COBOL structure with IDENTIFICATION, ENVIRONMENT, DATA and PROCEDURE divisions. Use proper COBOL formatting conventions, with division headers and paragraph names in Area A (columns 8-11) and statements in Area B (columns 12-72). Indent and structure the code, especially in the PROCEDURE DIVISION, to enhance readability.\n\nIn the output file, include both the original filename and the analysis results on each line. The results should indicate \"is_file: Y/N\", \"has_special: Y/N\", and \"has_numbers: Y/N\" based on the criteria above.\n\nEnsure the program can handle input files with multiple filenames, processing each one and writing out the analysis until the end of the input file is reached. Include appropriate error handling.\n\nFocus on the overall functionality and flow of the program. The specific implementation details are left to your discretion, but the program must be syntactically valid COBOL code.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. FILE-VALIDATOR.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n           01 INPUT-RECORD.\n               05 FILE-NAME-IN      PIC X(20).\n       \n       FD  OUTPUT-FILE.\n           01 OUTPUT-RECORD.\n               05 FILE-NAME-OUT     PIC X(20).\n                \n               05 RESULT-TEXT      PIC X(100).\n       \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05 WS-EOF              PIC X VALUE 'N'.\n           05 WS-IS-FILE          PIC X VALUE 'N'.\n           05 WS-HAS-SPECIAL      PIC X VALUE 'N'.\n           05 WS-HAS-NUMBERS      PIC X VALUE 'N'.\n       \n       01  WS-COUNTERS.\n           05 WS-I                PIC 99 VALUE 1.\n           05 WS-LEN              PIC 99 VALUE 0.\n       \n       01  WS-TEMP.\n           05 WS-CHAR            PIC X.\n           05 WS-RESULT          PIC X(100).\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INIT-PARA\n           PERFORM PROCESS-PARA UNTIL WS-EOF = 'Y'\n           PERFORM CLOSE-PARA\n           STOP RUN.\n       \n       INIT-PARA.\n           OPEN INPUT INPUT-FILE\n                OUTPUT OUTPUT-FILE.\n       \n       PROCESS-PARA.\n            \n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   PERFORM CHECK-CONDITIONS                   \n                   PERFORM WRITE-OUTPUT\n                    \n           END-READ.\n       \n       CHECK-CONDITIONS.\n            \n           MOVE 'N' TO WS-IS-FILE\n           MOVE 'N' TO WS-HAS-SPECIAL\n           MOVE 'N' TO WS-HAS-NUMBERS\n           \n           PERFORM VARYING WS-I FROM 1 BY 1 \n               UNTIL WS-I > FUNCTION LENGTH(FILE-NAME-IN)\n               OR FILE-NAME-IN(WS-I:1) = SPACES\n               MOVE FILE-NAME-IN(WS-I:1) TO WS-CHAR\n                \n               IF WS-CHAR = '.'\n                    \n                   MOVE 'Y' TO WS-IS-FILE\n               END-IF\n               \n               IF WS-CHAR IS NUMERIC\n                    \n                   MOVE 'Y' TO WS-HAS-NUMBERS\n               END-IF\n               \n               IF NOT (WS-CHAR IS ALPHABETIC OR \n                      WS-CHAR IS NUMERIC OR \n                      WS-CHAR = '_' OR \n                      WS-CHAR = '.')\n                    \n                   MOVE 'Y' TO WS-HAS-SPECIAL\n               END-IF\n           END-PERFORM.\n       \n       WRITE-OUTPUT.\n            \n           MOVE SPACES TO WS-RESULT\n           STRING 'is_file: ' \n                  FUNCTION TRIM(WS-IS-FILE)\n                  ', has_special: '\n                  FUNCTION TRIM(WS-HAS-SPECIAL)\n                  ', has_numbers: '\n                  FUNCTION TRIM(WS-HAS-NUMBERS)\n               INTO WS-RESULT\n            \n           \n           MOVE FILE-NAME-IN TO FILE-NAME-OUT\n           MOVE WS-RESULT TO RESULT-TEXT\n                         \n           WRITE OUTPUT-RECORD.\n       \n       CLOSE-PARA.\n           CLOSE INPUT-FILE\n                 OUTPUT-FILE.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "filename1.txt\ntestingfile.txt\nanthertest@file.docx\nnotafile\n"
      },
      "outputs": {
        "output.txt": "filename1.txt       is_file: Y, has_special: N, has_numbers: Y\ntestingfile.txt     is_file: Y, has_special: N, has_numbers: N\nanthertest@file.docxis_file: Y, has_special: Y, has_numbers: N\nnotafile            is_file: N, has_special: N, has_numbers: N\n"
      }
    },
    {
      "Program_name": "task_func_12",
      "Cobol_Eval": "Write a valid COBOL program that reads patient billing data from an input file called 'input.txt', processes the data, and writes a summary report to an output file called 'output.txt'. The program should follow the standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE DIVISION) and adhere to COBOL coding conventions for Area A, Area B, and indentation.\n\nThe input file contains records with patient name, age, service date, and surgery cost. The program should sort the input records by patient name, then calculate the total cost of surgeries for each unique patient.\n\nThe output file should contain one record per patient, including their name, age, and total surgery cost. Records should only be written for patients with a non-blank name.\n\nUse a sort file for the intermediate sorting step. Declare all necessary file descriptions, record layouts, and working storage items in the DATA DIVISION. \n\nIn the PROCEDURE DIVISION, include paragraphs to initialize files, perform the sort, process the sorted records to accumulate costs per patient, write output records, and close the files when processing is complete.\n\nAim to produce clean, readable COBOL code, but focus on the overall program structure and functionality rather than implementation specifics. The generated program should achieve the same end result as the provided example when given equivalent input data.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. PATIENT-BILLING.\n      \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT SORT-FILE\n               ASSIGN TO 'SORTWORK'.\n      \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 IN-NAME              PIC X(10).\n           05 IN-AGE              PIC 9(02).\n           05 IN-DATE             PIC X(10).\n           05 IN-SURGERY-COST     PIC 9(05).\n      \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 OUT-NAME            PIC X(10).\n           05 FILL1             PIC X(02) VALUE SPACES.\n           05 OUT-AGE             PIC 9(02).\n           05 FILL2             PIC X(02) VALUE SPACES.\n           05 OUT-TOTAL-COST      PIC 9(06).\n      \n       SD  SORT-FILE.\n       01  SORT-RECORD.\n           05 SORT-NAME           PIC X(10).\n           05 SORT-AGE            PIC 9(02).\n           05 SORT-DATE           PIC X(10).\n           05 SORT-SURGERY-COST   PIC 9(05).\n      \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05 WS-EOF              PIC X VALUE 'N'.\n      \n       01  WS-WORK-AREAS.\n           05 WS-PREV-NAME        PIC X(10).\n           05 WS-CURR-AGE         PIC 9(02).\n           05 WS-TOTAL-COST       PIC 9(06) VALUE ZERO.\n      \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM 100-INIT-PARA\n           PERFORM 200-SORT-PARA\n           PERFORM 300-PROCESS-PARA\n           PERFORM 400-CLOSE-PARA\n           STOP RUN.\n      \n       100-INIT-PARA.\n           OPEN INPUT  INPUT-FILE\n                OUTPUT OUTPUT-FILE.\n      \n       200-SORT-PARA.\n           SORT SORT-FILE\n               ON ASCENDING KEY SORT-NAME\n               USING INPUT-FILE\n               GIVING INPUT-FILE.\n      \n       300-PROCESS-PARA.\n            \n           READ INPUT-FILE\n               AT END MOVE 'Y' TO WS-EOF\n           END-READ\n      \n           IF WS-EOF = 'N'\n               MOVE IN-NAME TO WS-PREV-NAME\n               MOVE IN-AGE  TO WS-CURR-AGE\n               MOVE IN-SURGERY-COST TO WS-TOTAL-COST\n           END-IF\n      \n           PERFORM UNTIL WS-EOF = 'Y'\n               READ INPUT-FILE\n                   AT END\n                       MOVE 'Y' TO WS-EOF\n                       PERFORM 350-WRITE-TOTAL\n                   NOT AT END\n                       IF IN-NAME NOT = WS-PREV-NAME\n                       AND IN-NAME > 0\n                           PERFORM 350-WRITE-TOTAL\n                           MOVE IN-NAME TO WS-PREV-NAME\n                           MOVE IN-AGE  TO WS-CURR-AGE\n                           MOVE IN-SURGERY-COST TO WS-TOTAL-COST\n                       ELSE\n                           ADD IN-SURGERY-COST TO WS-TOTAL-COST\n                       END-IF\n               END-READ\n           END-PERFORM.\n      \n       350-WRITE-TOTAL.\n           MOVE WS-PREV-NAME   TO OUT-NAME\n           MOVE WS-CURR-AGE    TO OUT-AGE\n           MOVE WS-TOTAL-COST  TO OUT-TOTAL-COST\n           MOVE '  ' TO FILL1\n                        FILL2. \n           IF WS-PREV-NAME <> ' ' \n            WRITE OUTPUT-RECORD FROM OUTPUT-RECORD\n           END-IF.\n      \n       400-CLOSE-PARA.\n           CLOSE INPUT-FILE\n                 OUTPUT-FILE.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "Palekit   3211-02-202321600\nPalekit   3212-02-202302600\nNikhil    4213-02-202302650\nNikhil    4214-02-202311400\nNikhil    4215-02-202302780\nSomesh    3516-02-202302610\nSomesh    3517-02-202313650\nSomesh    3518-02-202331600\nSomesh    3519-02-202302600\nPanit     3220-02-202301650"
      },
      "outputs": {
        "output.txt": "Palekit     32  024200\nNikhil      42  016830\nSomesh      35  050460\nPanit       32  001650\n"
      }
    },
    {
      "Program_name": "task_func_13",
      "Cobol_Eval": "Write a valid COBOL program that reads customer names from an input file called 'input.txt', sorts the names in ascending order, validates that each name contains only alphabetic characters (no numbers), and writes the sorted valid names to an output file called 'output.txt'. The program should follow standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE DIVISION), adhere to COBOL Area A and B formatting conventions, and use proper COBOL indentation, especially in the PROCEDURE DIVISION. \n\nThe program should open the input file, read customer names one at a time, check if each name is valid (contains no numeric characters), and if valid, release the name record to a temporary sort file. After reading all records, close the input file. Then sort the temporary file by customer name in ascending sequence.\n\nNext, the sorted records should be returned one at a time from the sort file, moved to an output record, and written to the output file. After all sorted records are written, close the output file. \n\nFinally, display the total records read, number of invalid name records encountered, and a message indicating processing is complete.\n\nRemember, this is a high-level description of the program's functionality and requirements. Implement this specification using proper COBOL syntax, but do not worry about matching the provided 'Expected Program' exactly. The goal is to create a COBOL program that produces the same result, while adhering to the specified COBOL formatting and structural requirements.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. CUSTSORT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT SORT-FILE\n               ASSIGN TO 'SORTWORK'.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 CUSTOMER-NAME    PIC X(50).\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 SORTED-NAME      PIC X(50).\n           \n       SD  SORT-FILE.\n       01  SORT-RECORD.\n           05 SORT-NAME        PIC X(50).\n           \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05 WS-EOF-FLAG      PIC X VALUE 'N'.\n           05 WS-VALID-FLAG    PIC X VALUE 'Y'.\n           \n       01  WS-COUNTERS.\n           05 WS-READ-COUNT    PIC 9(5) VALUE 0.\n           05 WS-ERROR-COUNT   PIC 9(5) VALUE 0.\n           05 WS-COUNT         PIC 9(5) VALUE 0. \n           \n       01  WS-NAME-CHECK.\n           05 WS-CHAR         PIC X OCCURS 50 TIMES.\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM 100-INIT-PARA\n           PERFORM 200-PROCESS-PARA\n           PERFORM 300-CLOSE-PARA\n           STOP RUN.\n           \n       100-INIT-PARA.\n           display 'init para:' \n           SORT SORT-FILE\n               ON ASCENDING KEY SORT-NAME\n               INPUT PROCEDURE IS 400-INPUT-PROC\n               OUTPUT PROCEDURE IS 500-OUTPUT-PROC.\n               \n       200-PROCESS-PARA.\n           display 'process para:'\n           DISPLAY \"Processing Complete\"\n           DISPLAY \"Records Read: \" WS-COUNT\n           DISPLAY \"Invalid Records: \" WS-ERROR-COUNT.\n           \n       300-CLOSE-PARA.\n           EXIT.\n           \n       400-INPUT-PROC SECTION.\n       410-READ-INPUT.\n           initialize ws-count\n           OPEN INPUT INPUT-FILE\n           PERFORM UNTIL WS-EOF-FLAG = 'Y'\n               READ INPUT-FILE\n                   AT END\n                       MOVE 'Y' TO WS-EOF-FLAG\n                   NOT AT END\n                        \n                       ADD 1 TO WS-COUNT\n                        \n                       PERFORM 420-VALIDATE-NAME\n                       IF WS-VALID-FLAG = 'Y'\n                           MOVE INPUT-RECORD TO SORT-RECORD\n                           RELEASE SORT-RECORD\n                       END-IF\n               END-READ\n           END-PERFORM\n           CLOSE INPUT-FILE.\n           \n       420-VALIDATE-NAME.\n            \n           MOVE 'Y' TO WS-VALID-FLAG\n           MOVE CUSTOMER-NAME TO WS-NAME-CHECK\n           PERFORM VARYING WS-READ-COUNT FROM 1 BY 1\n               UNTIL WS-READ-COUNT > 50 OR\n                   WS-CHAR(WS-READ-COUNT) = SPACE\n                   \n                    \n                   IF WS-CHAR(WS-READ-COUNT) IS NUMERIC \n                        MOVE 'N' TO WS-VALID-FLAG\n                        ADD 1 TO WS-ERROR-COUNT\n                   END-IF\n           END-PERFORM.\n           \n       500-OUTPUT-PROC SECTION.\n       510-WRITE-OUTPUT.\n            \n           OPEN OUTPUT OUTPUT-FILE\n           PERFORM UNTIL EXIT\n               RETURN SORT-FILE\n                   AT END\n                       EXIT PERFORM\n                   NOT AT END\n                       MOVE SORT-RECORD TO OUTPUT-RECORD\n                       WRITE OUTPUT-RECORD\n               END-RETURN\n           END-PERFORM\n           CLOSE OUTPUT-FILE.\n           \n       END PROGRAM CUSTSORT.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "PaulamiSaha\nTester1name\nJoseph\nKetlyn"
      },
      "outputs": {
        "output.txt": "Joseph\nKetlyn\nPaulamiSaha\n"
      }
    },
    {
      "Program_name": "task_func_14",
      "Cobol_Eval": "Write a COBOL program that processes a CSV file containing dates and values. The program should:\n\n1. Read the CSV file specified by the input filename 'task_func14_inp'. \n2. Extract records where the date matches the current date.\n3. Sort the extracted records by value in ascending order.\n4. Write the sorted records to a new CSV file specified by the output filename 'task_func14_out'.\n5. Handle any file I/O errors and empty input files gracefully.\n\nEnsure the generated COBOL program adheres to the following requirements:\n\n1. Use valid COBOL syntax throughout the program.\n2. Structure the program using the standard COBOL division headers (IDENTIFICATION DIVISION, DATA DIVISION, PROCEDURE DIVISION). \n3. Follow COBOL formatting conventions, placing division headers and paragraph names in Area A (columns 8-11) and statements in Area B (columns 12-72).\n4. Improve code readability by applying consistent indentation, especially within the PROCEDURE DIVISION.\n\nThe program should be efficient, maintainable, and follow best practices for COBOL programming. Focus on clearly describing the program's functionality and purpose without providing detailed implementation instructions or algorithms.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. DATE-CSV-PROCESSOR.       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'task_func14_inp'\n               ORGANIZATION IS LINE SEQUENTIAL\n               FILE STATUS IS WS-INPUT-STATUS.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'task_func14_out'\n               ORGANIZATION IS LINE SEQUENTIAL\n               FILE STATUS IS WS-OUTPUT-STATUS.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n           01 INPUT-RECORD.\n               05 IR-DATE         PIC X(10).\n               05 FILLER          PIC X(01).\n               05 IR-VALUE        PIC X(05).\n       \n       FD  OUTPUT-FILE.\n           01 OUTPUT-RECORD       PIC X(80).\n\n       \n       WORKING-STORAGE SECTION.\n       01  WS-INPUT-STATUS        PIC XX.\n       01  WS-OUTPUT-STATUS       PIC XX.\n       01  WS-EOF                 PIC X VALUE 'N'.\n       \n       01  WS-CURRENT-DATE.\n           05 WS-CURR-YEAR        PIC 9(4).\n           05 WS-CURR-MONTH       PIC 9(2).\n           05 WS-CURR-DAY         PIC 9(2).\n           05 FILLER              PIC X(13).\n       \n       01  WS-DATE-COMPARE.\n           05 WS-COMP-YEAR        PIC 9(4).\n           05 FILLER              PIC X VALUE '-'.\n           05 WS-COMP-MONTH       PIC 9(2).\n           05 FILLER              PIC X VALUE '-'.\n           05 WS-COMP-DAY         PIC 9(2).\n       \n       01  WS-HEADER              PIC X(16) VALUE 'DateColumn,Value'.\n       01  WS-TEMP-VALUE          PIC 9(3).\n       01  WS-ARRAY-SIZE          PIC 9(3) VALUE 0.\n       01  WS-IDX                 PIC 9(3).\n       01  WS-IDX2                PIC 9(3).\n       01  WS-READ-COUNT          PIC 9(3).\n       01  WS-OUT-RECORD.\n           05 WS-OR-DATE          PIC X(10).\n           05 WS-OR-FILLER1       PIC X(01) VALUE ','.\n           05 WS-OR-VALUE         PIC X(03).\n           05 WS-OR-FILLER2       PIC X(66) VALUE SPACES.\n       \n       01  WS-MAX-RECORDS         PIC 9(4) VALUE 100.\n       01  WS-RECORD-TABLE OCCURS 100 TIMES.\n           05 WS-REC-DATE         PIC X(10).\n           05 WS-REC-VALUE        PIC 9(3).\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZE-PARA\n           PERFORM PROCESS-FILE\n           IF WS-READ-COUNT = 0 \n              DISPLAY \"Error : Empty CSV file\" \n           END-IF\n           PERFORM SORT-AND-OUTPUT\n           PERFORM CLEANUP-PARA\n           STOP RUN.\n       \n       INITIALIZE-PARA.\n           MOVE FUNCTION CURRENT-DATE TO WS-CURRENT-DATE\n           STRING WS-CURR-YEAR DELIMITED BY SIZE\n                  '-'\n                  WS-CURR-MONTH DELIMITED BY SIZE\n                  '-'\n                  WS-CURR-DAY DELIMITED BY SIZE\n             INTO WS-DATE-COMPARE\n           OPEN INPUT INPUT-FILE\n           IF WS-INPUT-STATUS NOT = '00'\n               DISPLAY 'Error opening input file: ' WS-INPUT-STATUS\n               STOP RUN\n           END-IF\n           OPEN OUTPUT OUTPUT-FILE\n           WRITE OUTPUT-RECORD FROM WS-HEADER.\n       \n       PROCESS-FILE.\n           READ INPUT-FILE\n                AT END SET WS-EOF TO 'Y'\n           END-READ\n           PERFORM UNTIL WS-EOF = 'Y'\n               IF INPUT-RECORD <> WS-HEADER\n                  ADD 1 TO WS-READ-COUNT\n               END-IF\n               IF IR-DATE = WS-DATE-COMPARE\n                   ADD 1 TO WS-ARRAY-SIZE\n                   MOVE IR-DATE  TO WS-REC-DATE(WS-ARRAY-SIZE)\n                   MOVE IR-VALUE TO WS-REC-VALUE(WS-ARRAY-SIZE)\n               END-IF\n               READ INPUT-FILE\n\t\t    AT END  SET WS-EOF TO 'Y'                      \n               END-READ\n           END-PERFORM.\n       \n       SORT-AND-OUTPUT.\n           PERFORM VARYING WS-IDX FROM 1 BY 1 \n               UNTIL WS-IDX > WS-ARRAY-SIZE - 1\n               PERFORM VARYING WS-IDX2 FROM WS-IDX BY 1 \n                   UNTIL WS-IDX2 > WS-ARRAY-SIZE\n                   IF WS-REC-VALUE(WS-IDX2) < WS-REC-VALUE(WS-IDX)\n                       MOVE WS-REC-VALUE(WS-IDX) TO WS-TEMP-VALUE\n                       MOVE WS-REC-VALUE(WS-IDX2) \n                           TO WS-REC-VALUE(WS-IDX)\n                       MOVE WS-TEMP-VALUE TO WS-REC-VALUE(WS-IDX2)\n                   END-IF\n               END-PERFORM\n           END-PERFORM\n           \n           PERFORM VARYING WS-IDX FROM 1 BY 1 \n               UNTIL WS-IDX > WS-ARRAY-SIZE\n               MOVE WS-REC-DATE(WS-IDX)  TO WS-OR-DATE\n               MOVE WS-REC-VALUE(WS-IDX) TO WS-OR-VALUE\n               WRITE OUTPUT-RECORD       FROM WS-OUT-RECORD\n           END-PERFORM.\n       \n       CLEANUP-PARA.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "task_func14_inp",
      "output_file_names": "task_func14_out",
      "inputs": {
        "task_func14_inp": "DateColumn,Value\n2024-12-25,150\n2024-12-25,100\n2023-12-25,200\n"
      },
      "outputs": {
        "task_func14_out": "DateColumn,Value\n"
      }
    },
    {
      "Program_name": "task_func_15",
      "Cobol_Eval": "Write a COBOL program that generates all possible combinations of animals and foods. The program should:\n\n1. Read a list of animals from an input file named 'task_func15_inp1'. If the file is empty, use a default list of 10 animals.\n\n2. Read a list of foods from an input file named 'task_func15_inp2'. If the file is empty, use a default list of 10 foods. \n\n3. Generate all possible animal-food combinations in the format \"Animal:Food|\" and write each combination to an output file named 'task_func15_out', with one combination per line.\n\n4. Handle up to a maximum of 10 animals and 10 foods. If either input file contains more than 10 items, display an error message and stop the program.\n\nThe COBOL program should follow this structure:\n- IDENTIFICATION DIVISION with the program name\n- ENVIRONMENT DIVISION to define the input and output files \n- DATA DIVISION to define the file layouts, working storage, and any tables or counters needed\n- PROCEDURE DIVISION containing the main program logic and any necessary paragraphs\n\nEnsure the COBOL code follows proper formatting conventions, with division headers and paragraph names in Area A (columns 8-11) and statements in Area B (columns 12-72). Use standard COBOL indentation, especially in the PROCEDURE DIVISION, to enhance readability.\n\nFocus on clearly describing the program's functionality and purpose without providing detailed COBOL syntax or revealing the specific algorithms to use. The LLM should determine the best way to implement the program based on these requirements.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ANIMAL-FOOD-COMBINATIONS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT ANIMAL-FILE ASSIGN TO 'task_func15_inp1'\n           ORGANIZATION IS LINE SEQUENTIAL.\n           \n           SELECT FOOD-FILE ASSIGN TO 'task_func15_inp2'\n           ORGANIZATION IS LINE SEQUENTIAL.\n           \n           SELECT OUTPUT-FILE ASSIGN TO 'task_func15_out'\n           ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  ANIMAL-FILE.\n       01  ANIMAL-RECORD.\n           05 ANIMAL-NAME    PIC X(20).\n           \n       FD  FOOD-FILE.\n       01  FOOD-RECORD.\n           05 FOOD-NAME      PIC X(20).\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD     PIC X(400).\n       \n       WORKING-STORAGE SECTION.\n       01  WS-EOF-FLAGS.\n           05 ANIMAL-EOF     PIC X VALUE 'N'.\n           05 FOOD-EOF       PIC X VALUE 'N'.           \n       01  WS-TABLES.\n           05 ANIMAL-TABLE OCCURS 10 TIMES.\n              10 ANIMAL-ITEM   PIC X(20).\n           05 FOOD-TABLE OCCURS 10 TIMES.\n              10 FOOD-ITEM     PIC X(20).\n           05 WS-OUT-TABLE OCCURS 10 TIMES.\n              10 WS-X          PIC X(400).    \n       01  WS-COUNTERS.\n           05 ANIMAL-COUNT     PIC 99 VALUE ZERO.\n           05 FOOD-COUNT       PIC 99 VALUE ZERO. \n       01  WS-OUTPUT-LINE      PIC X(400) VALUE SPACES.\n       01  WS-INDEXES.\n           05 WS-I             PIC 99.\n           05 WS-J             PIC 99.\n       01  WS-COUNTS.\n           05 WS-LEN           PIC 9(3) VALUE 0.\n           05 WS-RES-MOD-LEN   PIC 9(3) VALUE 0.\n       01  WS-COMBINATION      PIC X(42) VALUE SPACES.\n\n\n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZE-PARA\n           PERFORM READ-ANIMALS\n           PERFORM READ-FOODS\n           PERFORM PROCESS-COMBINATIONS\n           PERFORM CLOSE-FILES\n           STOP RUN.\n           \n       INITIALIZE-PARA.\n           OPEN INPUT ANIMAL-FILE\n                      FOOD-FILE\n                OUTPUT OUTPUT-FILE.\n           \n       READ-ANIMALS.\n           PERFORM UNTIL ANIMAL-EOF = 'Y' \n               READ ANIMAL-FILE\n                   AT END\n                       MOVE 'Y' TO ANIMAL-EOF\n                   NOT AT END\n                       ADD 1 TO ANIMAL-COUNT\n                       IF ANIMAL-COUNT > 10\n                          DISPLAY \"MAX ANIMAL COUNT OF 10 IS REACHED\"\n                          STOP RUN\n                       ELSE      \n                          MOVE ANIMAL-NAME TO ANIMAL-ITEM(ANIMAL-COUNT)  \n                       END-IF             \n               END-READ\n           END-PERFORM.\n         \n           IF ANIMAL-COUNT = 0\n               MOVE 'Dog'      TO ANIMAL-ITEM(1)\n               MOVE 'Cat'      TO ANIMAL-ITEM(2)\n               MOVE 'Elephant' TO ANIMAL-ITEM(3)\n               MOVE 'Tiger'    TO ANIMAL-ITEM(4)\n               MOVE 'Lion'     TO ANIMAL-ITEM(5)\n               MOVE 'Zebra'    TO ANIMAL-ITEM(6)\n               MOVE 'Giraffe'  TO ANIMAL-ITEM(7)\n               MOVE 'Bear'     TO ANIMAL-ITEM(8)\n               MOVE 'Monkey'   TO ANIMAL-ITEM(9)\n               MOVE 'Kangaroo' TO ANIMAL-ITEM(10)\n               MOVE 10 TO ANIMAL-COUNT\n           END-IF.\n         \n       READ-FOODS.\n           PERFORM UNTIL FOOD-EOF = 'Y'\n               READ FOOD-FILE\n                   AT END\n                       MOVE 'Y' TO FOOD-EOF\n                   NOT AT END\n                       ADD 1 TO FOOD-COUNT\n                       IF FOOD-COUNT > 10\n                          DISPLAY \"MAX FOOD COUNT OF 10 IS REACHED\"\n                          STOP RUN\n                       ELSE      \n                          MOVE FOOD-NAME TO FOOD-ITEM(FOOD-COUNT)\n                       END-IF\n               END-READ\n           END-PERFORM.\n           \n           IF FOOD-COUNT = 0\n               MOVE 'Meat'    TO FOOD-ITEM(1)\n               MOVE 'Fish'    TO FOOD-ITEM(2)\n               MOVE 'Grass'   TO FOOD-ITEM(3)\n               MOVE 'Fruits'  TO FOOD-ITEM(4)\n               MOVE 'Insects' TO FOOD-ITEM(5)\n               MOVE 'Seeds'   TO FOOD-ITEM(6)\n               MOVE 'Leaves'  TO FOOD-ITEM(7)\n               MOVE 'Vegetables'\n                              TO FOOD-ITEM(8)\n               MOVE 'Sugarcane'   \n                              TO FOOD-ITEM(9)\n               MOVE 'Hay'     TO FOOD-ITEM(10)\n\n               MOVE 10        TO FOOD-COUNT\n           END-IF.\n           \n       PROCESS-COMBINATIONS.\n           PERFORM VARYING WS-I FROM 1 BY 1 UNTIL WS-I > ANIMAL-COUNT         \n               PERFORM VARYING WS-J FROM 1 BY 1 UNTIL WS-J > FOOD-COUNT \n                   INITIALIZE WS-COMBINATION                                    \n                   STRING ANIMAL-ITEM(WS-I) DELIMITED BY SPACE\n                          ':' DELIMITED BY SIZE\n                          FOOD-ITEM(WS-J) DELIMITED BY SPACE\n                          '|' DELIMITED BY SIZE\n                          INTO WS-COMBINATION\n                   END-STRING\n                    \n                   IF (WS-J = 1) THEN\n                       COMPUTE WS-RES-MOD-LEN = 1\n                   END-IF\n                   INSPECT WS-COMBINATION TALLYING WS-LEN \n                       FOR CHARACTERS BEFORE INITIAL ' '                                       \n                    MOVE WS-COMBINATION\n                      TO WS-OUT-TABLE(WS-I)(WS-RES-MOD-LEN:WS-LEN)                   \n                   COMPUTE WS-RES-MOD-LEN = WS-RES-MOD-LEN + WS-LEN                    \n                   INITIALIZE WS-LEN                     \n               END-PERFORM   \n                  \n               MOVE WS-OUT-TABLE(WS-I)(1:WS-RES-MOD-LEN)  \n                                    TO  WS-OUTPUT-LINE                          \n               WRITE OUTPUT-RECORD FROM WS-OUTPUT-LINE\n               INITIALIZE WS-RES-MOD-LEN    \n                          OUTPUT-RECORD                       \n           END-PERFORM.\n           \n       CLOSE-FILES.\n           CLOSE ANIMAL-FILE\n                 FOOD-FILE\n                 OUTPUT-FILE.\n",
      "input_file_names": [
        "task_func15_inp1",
        "task_func15_inp2"
      ],
      "output_file_names": "task_func15_out",
      "inputs": {
        "task_func15_inp1": "",
        "task_func15_inp2": ""
      },
      "outputs": {
        "task_func15_out": "Dog:Meat|Dog:Fish|Dog:Grass|Dog:Fruits|Dog:Insects|Dog:Seeds|Dog:Leaves|Dog:Vegetables|Dog:Sugarcane|Dog:Hay|\nCat:Meat|Cat:Fish|Cat:Grass|Cat:Fruits|Cat:Insects|Cat:Seeds|Cat:Leaves|Cat:Vegetables|Cat:Sugarcane|Cat:Hay|\nElephant:Meat|Elephant:Fish|Elephant:Grass|Elephant:Fruits|Elephant:Insects|Elephant:Seeds|Elephant:Leaves|Elephant:Vegetables|Elephant:Sugarcane|Elephant:Hay|\nTiger:Meat|Tiger:Fish|Tiger:Grass|Tiger:Fruits|Tiger:Insects|Tiger:Seeds|Tiger:Leaves|Tiger:Vegetables|Tiger:Sugarcane|Tiger:Hay|\nLion:Meat|Lion:Fish|Lion:Grass|Lion:Fruits|Lion:Insects|Lion:Seeds|Lion:Leaves|Lion:Vegetables|Lion:Sugarcane|Lion:Hay|\nZebra:Meat|Zebra:Fish|Zebra:Grass|Zebra:Fruits|Zebra:Insects|Zebra:Seeds|Zebra:Leaves|Zebra:Vegetables|Zebra:Sugarcane|Zebra:Hay|\nGiraffe:Meat|Giraffe:Fish|Giraffe:Grass|Giraffe:Fruits|Giraffe:Insects|Giraffe:Seeds|Giraffe:Leaves|Giraffe:Vegetables|Giraffe:Sugarcane|Giraffe:Hay|\nBear:Meat|Bear:Fish|Bear:Grass|Bear:Fruits|Bear:Insects|Bear:Seeds|Bear:Leaves|Bear:Vegetables|Bear:Sugarcane|Bear:Hay|\nMonkey:Meat|Monkey:Fish|Monkey:Grass|Monkey:Fruits|Monkey:Insects|Monkey:Seeds|Monkey:Leaves|Monkey:Vegetables|Monkey:Sugarcane|Monkey:Hay|\nKangaroo:Meat|Kangaroo:Fish|Kangaroo:Grass|Kangaroo:Fruits|Kangaroo:Insects|Kangaroo:Seeds|Kangaroo:Leaves|Kangaroo:Vegetables|Kangaroo:Sugarcane|Kangaroo:Hay|\n"
      }
    },
    {
      "Program_name": "task_func_16",
      "Cobol_Eval": "Write a valid COBOL program that calculates the average time difference between timestamps read from an input file. The program should follow standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE DIVISION), adhere to Area A and B coding conventions, and use proper indentation, especially in the PROCEDURE DIVISION.\n\nThe program should:\n1. Read timestamp strings in 'YYYY-MM-DDThh:mm:ss.sss' format from a line sequential input file named 'task_func16_inp'. \n2. Parse and store the valid timestamps.\n3. Calculate the average difference in seconds between consecutive timestamps, ignoring the date portion.\n4. Write the formatted average difference to a line sequential output file named 'task_func16_out'.\n\nHandle cases where the input file contains less than 2 valid timestamps. The program should execute cleanly and produce the expected output file given a properly formatted input file.\n\nFocus on clearly describing the program's purpose, inputs, outputs, and key functionality without specifying detailed COBOL syntax or algorithms. Allow the LLM to determine the specific implementation while adhering to the provided COBOL coding style and structural requirements.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. TIMESTAMP-DIFF-CALC.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE ASSIGN TO 'task_func16_inp'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE ASSIGN TO 'task_func16_out'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n           01 INPUT-RECORD.\n               05 TIMESTAMP-STR PIC X(26).\n       \n       FD OUTPUT-FILE.\n           01 OUTPUT-RECORD PIC X(20).\n       \n       WORKING-STORAGE SECTION.\n       01 WS-EOF-FLAG PIC X VALUE 'N'.\n       01 WS-TIMESTAMP-TABLE.\n           05 WS-TIMESTAMPS OCCURS 100 TIMES.\n               10 WS-YEAR    PIC 9(4).\n               10 WS-MONTH   PIC 9(2).\n               10 WS-DAY     PIC 9(2).\n               10 WS-HOUR    PIC 9(2).\n               10 WS-MINUTE  PIC 9(2).\n               10 WS-SECOND  PIC 9(2).\n               10 WS-MSEC    PIC 9(3).\n\n       01 WS-NUM-TIMESTAMP.\n\t  03 WS-NUM-DATE.\n             05 WS-NUM-YEAR     PIC 9999.\n             05 WS-NUM-MONTH    PIC 99.\n             05 WS-NUM-DAY      PIC 99.\n          03 WS-NUM-TIME.\n             05 WS-NUM-HOUR     PIC 99.\n             05 WS-NUM-MIN      PIC 99.\n             05 WS-NUM-SEC      PIC 99.\n             05 WS-NUM-MSEC     PIC 999999.\n\n       01 WS-COUNTERS.\n           05 WS-TIMESTAMP-COUNT PIC 9(4) VALUE 0.\n           05 WS-INDEX           PIC 9(4) VALUE 1.\n       \n       01 WS-CALCULATIONS.\n           05 WS-TOTAL-DIFF     PIC 9(10)V9(3) VALUE 0.\n           05 WS-AVG-DIFF       PIC 9(10)V9(3) VALUE 0.\n           05 WS-TEMP-DIFF      PIC 9(10)V9(3).\n               \n       01 WS-FORMATTED-OUTPUT   PIC -Z(9)9.9(3).\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-TIMESTAMPS UNTIL WS-EOF-FLAG = 'Y'\n           PERFORM CALCULATE-AVERAGE\n           PERFORM WRITE-OUTPUT\n           PERFORM CLEANUP\n           STOP RUN.\n       \n       INITIALIZATION.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n       \n       PROCESS-TIMESTAMPS.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF-FLAG                      \n           END-READ\n           \n           IF (WS-EOF-FLAG = 'N' AND  TIMESTAMP-STR > ' ')\n                PERFORM PARSE-TIMESTAMP\n           END-IF.\n\n       PARSE-TIMESTAMP.\n           \n           MOVE TIMESTAMP-STR(1:4)  TO WS-NUM-YEAR\n           MOVE TIMESTAMP-STR(6:2)  TO WS-NUM-MONTH\n           MOVE TIMESTAMP-STR(9:2)  TO WS-NUM-DAY\n           MOVE TIMESTAMP-STR(12:2) TO WS-NUM-HOUR\n           MOVE TIMESTAMP-STR(15:2) TO WS-NUM-MIN\n           MOVE TIMESTAMP-STR(18:2) TO WS-NUM-SEC\n           MOVE TIMESTAMP-STR(21:3) TO WS-NUM-MSEC\n           IF  FUNCTION TEST-FORMATTED-DATETIME\n                              (\"YYYY-MM-DDThh:mm:ss.sss\", \n                               TIMESTAMP-STR ) = 0\n               ADD 1                TO WS-TIMESTAMP-COUNT\n               MOVE WS-NUM-TIMESTAMP\n                            TO WS-TIMESTAMPS (WS-TIMESTAMP-COUNT)\n             \n            ELSE\n               DISPLAY \"INVALID DATE IN \" TIMESTAMP-STR\n            END-IF.\n                 \n       CALCULATE-AVERAGE.\n           IF WS-TIMESTAMP-COUNT < 2\n               MOVE 0 TO WS-AVG-DIFF\n           ELSE\n               PERFORM VARYING WS-INDEX FROM 1 BY 1\n                   UNTIL WS-INDEX >= WS-TIMESTAMP-COUNT\n                   COMPUTE WS-TEMP-DIFF =\n                       (WS-HOUR(WS-INDEX + 1) * 3600 +\n                        WS-MINUTE(WS-INDEX + 1) * 60 +\n                        WS-SECOND(WS-INDEX + 1)) -\n                       (WS-HOUR(WS-INDEX) * 3600 +\n                        WS-MINUTE(WS-INDEX) * 60 +\n                        WS-SECOND(WS-INDEX))\n                   ADD WS-TEMP-DIFF TO WS-TOTAL-DIFF\n               END-PERFORM\n               COMPUTE WS-AVG-DIFF = WS-TOTAL-DIFF /\n                   (WS-TIMESTAMP-COUNT - 1)\n           END-IF.\n       \n       WRITE-OUTPUT.\n           MOVE WS-AVG-DIFF TO WS-FORMATTED-OUTPUT\n           WRITE OUTPUT-RECORD FROM WS-FORMATTED-OUTPUT.\n       \n       CLEANUP.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "task_func16_inp",
      "output_file_names": "task_func16_out",
      "inputs": {
        "task_func16_inp": "2009-03-30T16:31:32.123\n2009-03-30T17:33:34.123\n2009-03-30T18:33:34.123\n"
      },
      "outputs": {
        "task_func16_out": "       3661.000\n"
      }
    },
    {
      "Program_name": "task_func_17",
      "Cobol_Eval": "Write a COBOL program that extracts phone numbers from an input file named 'input.ps', formats them with country codes, and writes the formatted numbers to an output file named 'output.ps'. The program should adhere to the following requirements:\n\n1. Be a valid COBOL program with the standard COBOL division structure:\n   - IDENTIFICATION DIVISION \n   - ENVIRONMENT DIVISION\n   - DATA DIVISION\n   - PROCEDURE DIVISION\n2. Follow COBOL coding conventions:\n   - Division headers and paragraph names in Area A (columns 8-11)\n   - Statements in Area B (columns 12-72) \n3. Use standard COBOL indentation, especially in the PROCEDURE DIVISION, to improve readability\n4. In the PROCEDURE DIVISION:\n   - Open the input and output files\n   - Read records from the input file\n   - Extract 10-digit phone numbers from each record \n   - Determine the country code based on the first digit of the phone number\n   - Format the phone number with the country code, parentheses, and spaces\n   - Write each formatted number to the output file\n   - Close the files after processing\n5. Include a counter in WORKING-STORAGE to track the number of phone numbers processed\n\nThe input file contains records with phone numbers embedded within other text. The phone numbers are always 10 consecutive digits. The first digit indicates the country: '2' for India (country code +91) and '1' for the UK (country code +44).\n\nThe output file should contain one formatted phone number per record in this format: \n+XX (XXX) XXX XXXX\n\nFocus on the program's functionality and adhere to COBOL's structure and formatting conventions. Implementation details are left to the discretion of the programmer.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. PHONE-NUMBER-EXTRACTOR.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD             PIC X(80).\n       \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD            PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05  WS-EOF-FLAG          PIC X VALUE 'N'.\n               88  END-OF-FILE      VALUE 'Y'.\n           \n       01  WS-WORK-AREAS.\n           05  WS-LINE              PIC X(80).\n           05  WS-PHONE-NUMBER      PIC X(15).\n           05  WS-FORMATTED-NUMBER  PIC X(25).\n           05  WS-COUNTRY-CODE      PIC X(3).\n           05  WS-POSITION          PIC 99.\n           05  WS-LENGTH            PIC 99.\n           \n       01  WS-COUNTERS.\n           05  WS-PHONE-COUNT       PIC 99 VALUE 0.\n           \n       PROCEDURE DIVISION.\n       100-MAIN-PARA.\n           PERFORM 200-INIT-PARA\n           PERFORM 300-PROCESS-PARA UNTIL END-OF-FILE\n           PERFORM 400-CLOSE-PARA\n           STOP RUN.\n           \n       200-INIT-PARA.\n           OPEN INPUT  INPUT-FILE\n                OUTPUT OUTPUT-FILE.\n           \n       300-PROCESS-PARA.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF-FLAG\n               NOT AT END\n                   PERFORM 310-EXTRACT-PHONE\n           END-READ.\n           \n       310-EXTRACT-PHONE.\n           MOVE INPUT-RECORD TO WS-LINE\n           PERFORM VARYING WS-POSITION FROM 1 BY 1\n               UNTIL WS-POSITION > 80\n               OR WS-LINE(WS-POSITION) = SPACES\n               IF WS-LINE(WS-POSITION:1) IS NUMERIC\n                   PERFORM 320-VALIDATE-PHONE\n               END-IF\n           END-PERFORM.\n           \n       320-VALIDATE-PHONE.\n           IF WS-LINE(WS-POSITION:10) IS NUMERIC\n               MOVE WS-LINE(WS-POSITION:10) TO WS-PHONE-NUMBER\n               PERFORM 330-FORMAT-PHONE\n           END-IF.\n           \n       330-FORMAT-PHONE.\n           EVALUATE WS-PHONE-NUMBER(1:1)\n               WHEN '2' MOVE '+91' TO WS-COUNTRY-CODE\n               WHEN '1' MOVE '+44' TO WS-COUNTRY-CODE\n               WHEN OTHER CONTINUE\n           END-EVALUATE\n           \n           STRING WS-COUNTRY-CODE ' ('\n                  WS-PHONE-NUMBER(1:3) ') '\n                  WS-PHONE-NUMBER(4:3) ' '\n                  WS-PHONE-NUMBER(7:4)\n               INTO WS-FORMATTED-NUMBER\n           \n           WRITE OUTPUT-RECORD FROM WS-FORMATTED-NUMBER\n           ADD 1 TO WS-PHONE-COUNT.\n           \n       400-CLOSE-PARA.\n           CLOSE INPUT-FILE\n                 OUTPUT-FILE.\n           \n       END PROGRAM PHONE-NUMBER-EXTRACTOR.\n\n",
      "input_file_names": "input.ps",
      "output_file_names": "output.ps",
      "inputs": {
        "input.ps": "2341677829\n1552778719\n2556366762"
      },
      "outputs": {
        "output.ps": "+91 (234) 167 7829\n+44 (155) 277 8719\n+91 (255) 636 6762\n"
      }
    },
    {
      "Program_name": "task_func_18",
      "Cobol_Eval": "Write a valid COBOL program that reads customer records from an input file named 'task_func18_inp', formats the data into mailing labels, and writes the formatted labels to an output file named 'task_func18_out'. \n\nThe program should follow the standard COBOL division structure with IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION. Adhere to COBOL coding conventions, placing division headers and paragraph names in Area A (columns 8-11) and statements in Area B (columns 12-72). Use consistent indentation, especially in the PROCEDURE DIVISION, to enhance readability.\n\nThe input file contains records with customer name, street address, city, state, and zip code. The program should create mailing labels with the customer name, address, city, state and zip duplicated side-by-side. Separate the labels with a line of dashes. \n\nIn the DATA DIVISION, define the record layouts for reading the input file and writing the formatted labels to the output file. In the PROCEDURE DIVISION, include paragraphs to open the files, read and process each input record, format and write the mailing label lines, and close the files after processing.\n\nThe program should be complete, self-contained and ready to compile and execute, reading from the specified input file and producing the formatted mailing labels in the output file.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. MAILLABEL.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'task_func18_inp'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'task_func18_out'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  CUSTOMER-RECORD.\n           05 CUST-NAME           PIC X(20).\n           05 CUST-FILL1          PIC X.\n           05 STREET-ADDR         PIC X(20).\n           05 CUST-FILL2          PIC X.\n           05 CITY                PIC X(10).\n           05 CUST-FILL3          PIC X.\n           05 STATE               PIC X(03).\n           05 CUST-FILL4          PIC X.\n           05 ZIP-CODE            PIC X(05).\n           05 FILLER              PIC X(18) VALUE SPACES.\n           \n       FD  OUTPUT-FILE.\n       01  PRINT-LINE            PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       01  WS-EOF                PIC X VALUE 'N'.\n       01  WS-DASHES             PIC X(80) VALUE ALL '-'.\n       \n       01  WS-NAME-LINE.\n           05 LEFT-LABEL.\n               10 NAME-1         PIC X(20).\n               10 FILLER         PIC X(16) VALUE SPACES.\n           05 RIGHT-LABEL.\n               10 NAME-2         PIC X(20).\n               10 FILLER         PIC X(16) VALUE SPACES.\n           05 WS-NAME-FILLER     PIC X(8)  VALUE SPACES. \n               \n       01  WS-ADDRESS-LINE.\n           05 ADDR-1             PIC X(20).\n           05 FILLER             PIC X(16) VALUE SPACES.\n           05 ADDR-2             PIC X(20).\n           05 FILLER             PIC X(16) VALUE SPACES.\n           05 WS-ADDR-FILLER     PIC X(8)  VALUE SPACES. \n           \n       01  WS-CITY-LINE.\n           05 CITY-STATE-ZIP-1.\n               10 WS-CITY-1      PIC X(10).\n               10 FILLER         PIC X VALUE ','.\n               10 WS-STATE-1     PIC X(02).\n               10 FILLER         PIC X VALUE ','.\n               10 WS-ZIP-1       PIC X(05).\n           05 FILLER             PIC X(17) VALUE SPACES.\n           05 CITY-STATE-ZIP-2.\n               10 WS-CITY-2      PIC X(10).\n               10 FILLER         PIC X VALUE ','.\n               10 WS-STATE-2     PIC X(02).\n               10 FILLER         PIC X VALUE ','.\n               10 WS-ZIP-2       PIC X(05).\n           05 FILLER             PIC X(17) VALUE SPACES.\n          \n         01 WS-OUT-RECORD        PIC X(80) VALUE SPACES.\n         01 WS-RECORD-COUNT      PIC 9(03) VALUE ZEROS.\n\n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INIT-PARA\n           PERFORM PROCESS-PARA UNTIL WS-EOF = 'Y'\n           PERFORM CLOSE-PARA\n           STOP RUN.\n           \n       INIT-PARA.\n           OPEN INPUT  INPUT-FILE\n                OUTPUT OUTPUT-FILE.\n           \n       PROCESS-PARA.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   ADD 1    TO WS-RECORD-COUNT\n                   PERFORM PRINT-MAILING-LABEL\n           END-READ.\n           \n       PRINT-MAILING-LABEL.\n\n           IF WS-RECORD-COUNT = 1\n              MOVE WS-DASHES     TO WS-OUT-RECORD\n              WRITE PRINT-LINE   FROM WS-OUT-RECORD\n           END-IF     \n           \n           MOVE CUST-NAME     TO NAME-1 NAME-2\n           MOVE WS-NAME-LINE  TO WS-OUT-RECORD\n           WRITE PRINT-LINE   FROM WS-OUT-RECORD                              \n        \n           MOVE STREET-ADDR   TO ADDR-1 ADDR-2\n           MOVE WS-ADDRESS-LINE TO WS-OUT-RECORD\n           WRITE PRINT-LINE   FROM WS-OUT-RECORD\n                    \n           MOVE CITY         TO WS-CITY-1 WS-CITY-2\n           MOVE STATE        TO WS-STATE-1 WS-STATE-2\n           MOVE ZIP-CODE     TO WS-ZIP-1 WS-ZIP-2\n           MOVE WS-CITY-LINE TO WS-OUT-RECORD\n           WRITE PRINT-LINE  FROM WS-OUT-RECORD\n                                   \n           MOVE WS-DASHES    TO WS-OUT-RECORD\n           WRITE PRINT-LINE  FROM WS-OUT-RECORD. \n                       \n           \n       CLOSE-PARA.\n           CLOSE INPUT-FILE\n                 OUTPUT-FILE.\n\n",
      "input_file_names": "task_func18_inp",
      "output_file_names": "task_func18_out",
      "inputs": {
        "task_func18_inp": "CUSTOMER1           ,123 CROSS ST        ,NEW YORK  ,NY ,10158\nCUSTOMER2           ,456 MAIN ST         ,MIAMI     ,FL ,33431 "
      },
      "outputs": {
        "task_func18_out": "--------------------------------------------------------------------------------\nCUSTOMER1                           CUSTOMER1\n123 CROSS ST                        123 CROSS ST\nNEW YORK  ,NY,10158                 NEW YORK  ,NY,10158\n--------------------------------------------------------------------------------\nCUSTOMER2                           CUSTOMER2\n456 MAIN ST                         456 MAIN ST\nMIAMI     ,FL,33431                 MIAMI     ,FL,33431\n--------------------------------------------------------------------------------\n"
      }
    },
    {
      "Program_name": "task_func_19",
      "Cobol_Eval": "Write a valid COBOL program that calculates statistics (mean, median, and standard deviation) from employee salary data read from an input file. The program should follow standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE DIVISION) and formatting conventions (Area A for division and paragraph headers, Area B for statements). Use appropriate indentation, especially in the PROCEDURE DIVISION, to enhance readability.\n\nThe program should:\n1. Read employee records containing name, age, and salary from an input file named 'M3input.ps'. \n2. Store the salary values in a working storage array.\n3. Sort the salary array in ascending order.\n4. Calculate the mean, median, and standard deviation of the salaries.\n5. Write the calculated statistics to an output file named 'M3output.ps', with each statistic on a separate line preceded by its name.\n\nEnsure the program follows COBOL best practices for structure, naming, and data handling. The solution should be a complete, executable COBOL program that reads the input, processes the data, and produces the expected output file.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. CALC-STATISTICS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE ASSIGN TO 'M3input.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE ASSIGN TO 'M3output.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n           05 EMP-NAME        PIC X(20).\n           05 EMP-AGE         PIC 9(2).\n           05 EMP-SALARY      PIC 9(7).\n       \n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD.\n           05 STAT-NAME       PIC X(10).\n           05 STAT-VALUE      PIC 9(7)V99 VALUE ZERO.\n       \n       WORKING-STORAGE SECTION.\n       01 WS-EOF             PIC X VALUE 'N'.\n       01 WS-ARRAY.\n           05 SALARY-ARRAY OCCURS 100 TIMES\n               INDEXED BY I J.\n               10 SALARY-ITEM PIC 9(7) .\n       01 WS-COUNT           PIC 9(4) VALUE ZERO.\n       01 WS-TOTAL           PIC 9(8)  VALUE ZERO.\n       01 WS-MEAN            PIC 9(7)V99 VALUE ZERO.\n       01 WS-MEDIAN          PIC 9(7)V99 VALUE ZERO.\n       01 WS-STD-DEV         PIC 9(7)V99 VALUE ZERO.\n       01 WS-TEMP            PIC 9(7)V99 VALUE ZERO.\n       01 WS-VARIANCE        PIC 9(10)V99 VALUE ZERO.\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INIT-PARA\n           PERFORM READ-DATA-PARA\n           PERFORM SORT-ARRAY-PARA\n           PERFORM CALC-STATISTICS-PARA\n           PERFORM WRITE-OUTPUT-PARA\n           PERFORM CLOSE-FILES-PARA\n           STOP RUN.\n       \n       INIT-PARA.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n       \n       READ-DATA-PARA.\n           INITIALIZE WS-TOTAL\n           display \"read-data-para\"\n           PERFORM UNTIL WS-EOF = 'Y'\n               READ INPUT-FILE\n                   AT END\n                       MOVE 'Y' TO WS-EOF\n                   NOT AT END\n                       display \"INPUT-RECORD\" INPUT-RECORD\n                       ADD 1 TO WS-COUNT\n                       display \"salary:\" emp-salary\n                       MOVE EMP-SALARY TO SALARY-ITEM(WS-COUNT)\n                       display \"salary:\" emp-salary\n                       ADD EMP-SALARY TO WS-TOTAL\n                       display \"intermediete total\" ws-total\n               END-READ\n           END-PERFORM.\n       \n       SORT-ARRAY-PARA.\n           display \"sort para\"\n           PERFORM VARYING I FROM 1 BY 1 \n               UNTIL I > WS-COUNT - 1\n               PERFORM VARYING J FROM I BY 1 \n                   UNTIL J > WS-COUNT\n                   IF SALARY-ITEM(I) > SALARY-ITEM(J)\n                       MOVE SALARY-ITEM(I) TO WS-TEMP\n                       MOVE SALARY-ITEM(J) TO SALARY-ITEM(I)\n                       MOVE WS-TEMP TO SALARY-ITEM(J)\n                   END-IF\n               END-PERFORM\n           END-PERFORM.\n       \n       CALC-STATISTICS-PARA.\n           display \"calc stat\" \n           display \"count\" ws-count\n           display \"total:\" ws-total \n           COMPUTE WS-MEAN = WS-TOTAL / (WS-COUNT - 1)\n           display \"mean:\" ws-mean\n           IF FUNCTION MOD((WS-COUNT - 1), 2) = 0\n               COMPUTE WS-MEDIAN = (SALARY-ITEM(WS-COUNT / 2) +\n                   SALARY-ITEM(((WS-COUNT - 1) / 2) + 1)) / 2\n           ELSE\n               COMPUTE WS-MEDIAN = \n                   SALARY-ITEM((WS-COUNT) / 2)\n           END-IF\n           display \"median:\" ws-median\n           \n           MOVE ZERO TO WS-VARIANCE\n           PERFORM VARYING I FROM 1 BY 1 UNTIL I > (WS-COUNT - 1)\n               COMPUTE WS-TEMP = SALARY-ITEM(I) - WS-MEAN\n               COMPUTE WS-TEMP = WS-TEMP * WS-TEMP\n               ADD WS-TEMP TO WS-VARIANCE\n           END-PERFORM\n           COMPUTE WS-VARIANCE = WS-VARIANCE / (WS-COUNT - 1)\n           COMPUTE WS-STD-DEV = FUNCTION SQRT(WS-VARIANCE).\n           display \"std dev:\" ws-std-dev.\n       \n       WRITE-OUTPUT-PARA.\n           INITIALIZE OUTPUT-RECORD\n           display \"write output\"\n           MOVE 'MEAN' TO STAT-NAME\n           MOVE WS-MEAN TO STAT-VALUE\n           display \"outmean:\" output-record\n           WRITE OUTPUT-RECORD.  \n           \n           MOVE 'MEDIAN' TO STAT-NAME\n           MOVE WS-MEDIAN TO STAT-VALUE\n          display \"outmedian:\" output-record\n           WRITE OUTPUT-RECORD.  \n           \n           MOVE 'STD DEV' TO STAT-NAME\n           MOVE WS-STD-DEV TO STAT-VALUE\n           display \"outstd:\" output-record\n           WRITE OUTPUT-RECORD.\n       \n       CLOSE-FILES-PARA.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.",
      "input_file_names": "M3input.ps",
      "output_file_names": "M3output.ps",
      "inputs": {
        "M3input.ps": "John                305000000   \nBob                 356000000\nDavid               325800000\nMichael             406500000\nChris               295400000\nKaren               366100000"
      },
      "outputs": {
        "M3output.ps": "MEAN      497142857\nMEDIAN    540000000\nSTD DEV   000196847\n"
      }
    },
    {
      "Program_name": "task_func_20",
      "Cobol_Eval": "Write a COBOL program that calculates home loan amounts for customers based on their age, salary, and credit score. The program should:\n\n1. Read customer data from an input file named 'input.txt', with each record containing the customer's name, age, annual salary, and credit score. \n\n2. Calculate the maximum loan amount for each customer using the following criteria:\n   - The base loan amount is 4 times the annual salary\n   - The loan amount is adjusted by an age factor:\n     - 1.0 for age 30 or below \n     - 1.2 for age 31-40\n     - 1.1 for age 41-50\n     - 0.9 for age above 50\n   - The loan amount is further adjusted by a credit score factor:  \n     - 1.3 for score 750 or above\n     - 1.2 for score 700-749\n     - 1.1 for score 650-699\n     - 1.0 for score below 650\n\n3. Write each customer's name and their calculated maximum loan amount to an output file named 'output.txt'.\n\nEnsure the program follows standard COBOL structure:  \n- IDENTIFICATION DIVISION with PROGRAM-ID\n- ENVIRONMENT DIVISION with INPUT-OUTPUT SECTION for file handling \n- DATA DIVISION with FILE SECTION and WORKING-STORAGE SECTION for data definitions\n- PROCEDURE DIVISION with main processing logic  \n\nAdhere to COBOL coding conventions:\n- Division headers and paragraph names in Area A (columns 8-11)\n- Statements in Area B (columns 12-72)  \n- Use consistent indentation, especially in PROCEDURE DIVISION\n\nThe generated COBOL program must be syntactically valid.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. HOMELOAN-CALC.\n      \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n      \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n           05 IN-CUST-NAME        PIC X(20).\n           05 IN-CUST-AGE         PIC 9(02).\n           05 IN-CUST-SALARY      PIC 9(06).\n           05 IN-CREDIT-SCORE     PIC 9(03).\n      \n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD.\n           05 OUT-CUST-NAME       PIC X(20).\n           05 FILL1               PIC X(05) VALUE SPACES.\n           05 OUT-LOAN-AMOUNT     PIC 9(07).\n      \n       WORKING-STORAGE SECTION.\n       01 WS-FLAGS.\n           05 WS-EOF              PIC X(01) VALUE 'N'.\n      \n       01 WS-CALCULATIONS.\n           05 WS-LOAN-AMOUNT      PIC 9(07) VALUE 0.\n           05 WS-AGE-FACTOR       PIC 9V99   VALUE 0.\n           05 WS-SALARY-FACTOR    PIC 9V99   VALUE 0.\n           05 WS-CREDIT-FACTOR    PIC 9V99   VALUE 0.\n      \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM OPEN-FILES\n           PERFORM PROCESS-RECORDS UNTIL WS-EOF = 'Y'\n           PERFORM CLOSE-FILES\n           STOP RUN.\n      \n       OPEN-FILES.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n      \n       PROCESS-RECORDS.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   display IN-CUST-NAME \n                   display IN-CUST-AGE    \n                   display IN-CUST-SALARY   \n                   display IN-CREDIT-SCORE    \n\n                   PERFORM CALCULATE-LOAN-AMOUNT\n                   PERFORM WRITE-OUTPUT\n           END-READ.\n      \n       CALCULATE-LOAN-AMOUNT.\n           EVALUATE TRUE\n               WHEN IN-CUST-AGE <= 30\n                   MOVE 1.00 TO WS-AGE-FACTOR\n               WHEN IN-CUST-AGE <= 40\n                   MOVE 1.20 TO WS-AGE-FACTOR\n               WHEN IN-CUST-AGE <= 50\n                   MOVE 1.10 TO WS-AGE-FACTOR\n               WHEN OTHER\n                   MOVE 0.90 TO WS-AGE-FACTOR\n           END-EVALUATE\n      \n           EVALUATE TRUE\n               WHEN IN-CREDIT-SCORE >= 750\n                   MOVE 1.30 TO WS-CREDIT-FACTOR\n               WHEN IN-CREDIT-SCORE >= 700\n                   MOVE 1.20 TO WS-CREDIT-FACTOR\n               WHEN IN-CREDIT-SCORE >= 650\n                   MOVE 1.10 TO WS-CREDIT-FACTOR\n               WHEN OTHER\n                   MOVE 1.00 TO WS-CREDIT-FACTOR\n           END-EVALUATE\n           display in-cust-salary\n           display ws-age-factor\n           display ws-credit-factor\n           COMPUTE WS-LOAN-AMOUNT = IN-CUST-SALARY * 4 *\n                                   WS-AGE-FACTOR *\n                                   WS-CREDIT-FACTOR\n            display 'loan-amount:' ws-loan-amount.\n      \n       WRITE-OUTPUT.\n           MOVE IN-CUST-NAME TO OUT-CUST-NAME\n           MOVE WS-LOAN-AMOUNT TO OUT-LOAN-AMOUNT\n           MOVE '     '        TO FILL1  \n           display 'output1:' output-record \n           WRITE OUTPUT-RECORD FROM OUTPUT-RECORD.\n      \n       CLOSE-FILES.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "JohnSmith           28055000720\nAliceBrown          38077000680\nWilliamButch        29155677600\t "
      },
      "outputs": {
        "output.txt": "JohnSmith                0264000\nAliceBrown               0406560\nWilliamButch             0622708\n"
      }
    },
    {
      "Program_name": "task_func_21",
      "Cobol_Eval": "Create a valid COBOL program that generates sales data records based on input parameters. The program should:\n\n1. Follow the standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE divisions). \n\n2. Adhere to COBOL formatting conventions, using Area A for division and paragraph headers and Area B for statements.\n\n3. Use standard COBOL indentation, especially in the PROCEDURE DIVISION, to improve readability.\n\nThe program will:\n- Read an input file named \"input.txt\" containing an epoch timestamp, random seed, and list of product names\n- Validate the epoch timestamp is before the current date/time  \n- Generate a random sales quantity between 10-50 for each product\n- Write an output record for each product to a file named \"sales.txt\" containing:\n  - Product name\n  - Sale date (epoch date + time of sale generation) \n  - Sale quantity\n- Convert the epoch timestamp to a date and increment it by 1 day after each product's record is written\n- Handle invalid input data and file errors gracefully\n\nAim to create clean, readable COBOL code that achieves this sales data generation functionality. Let me know if you have any other questions!\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SALES-DATA-GENERATOR.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE ASSIGN TO \"input.txt\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE ASSIGN TO \"sales.txt\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 EPOCH-TIME        PIC 9(14).\n           05 RANDOM-SEED      PIC 9(4).\n           05 PRODUCT-LIST     PIC X(50) OCCURS 5 TIMES.\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 PRODUCT-NAME     PIC X(20).\n           05 SALE-DATE       PIC X(23).\n           05 SALE-QUANTITY   PIC 999.\n           \n       WORKING-STORAGE SECTION.\n       01  WS-CURRENT-DATE.\n           05 WS-CURR-DATE.\n               10 WS-CURR-YEAR     PIC 9(4).\n               10 WS-CURR-MONTH    PIC 99.\n               10 WS-CURR-DAY      PIC 99.\n           05 WS-CURR-TIME.\n               10 WS-CURR-HOUR     PIC 99.\n               10 WS-CURR-MIN      PIC 99.\n               10 WS-CURR-SEC      PIC 99.\n               10 WS-CURR-MS       PIC 99.\n               \n       01  WS-EPOCH-DATE.\n           05 WS-EPOCH-YEAR    PIC 9(4).\n           05 WS-EPOCH-MONTH   PIC 99.\n           05 WS-EPOCH-DAY     PIC 99.\n           \n       01  WS-COUNTERS.\n           05 WS-DAY-COUNTER   PIC 9(5) VALUE 0.\n           05 WS-PROD-INDEX    PIC 9 VALUE 1.\n           \n       01  WS-RANDOM.\n           05 WS-RANDOM-NUM    PIC 9(4)V9(4).\n           05 WS-SALES-QTY     PIC 999.\n           \n       01  WS-DEFAULT-PRODUCTS.\n           05 WS-PROD-NAME     PIC X(20) OCCURS 5 TIMES.\n             \n               \n       PROCEDURE DIVISION.\n       MAIN-LOGIC.\n           MOVE \"Product1\" TO WS-PROD-NAME (1)\n           MOVE \"Product2\" TO WS-PROD-NAME (2)\n           MOVE \"Product3\" TO WS-PROD-NAME (3)\n           MOVE \"Product4\" TO WS-PROD-NAME (4)\n           MOVE \"Product5\" TO WS-PROD-NAME (5).\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-SALES-DATA\n           PERFORM CLEANUP\n           STOP RUN.\n           \n       INITIALIZATION.\n           display 'initialization'\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE\n           MOVE FUNCTION CURRENT-DATE TO WS-CURRENT-DATE\n           READ INPUT-FILE\n               AT END DISPLAY \"Empty input file\"\n               GO TO CLEANUP\n           END-READ\n           \n           IF EPOCH-TIME > FUNCTION NUMVAL(WS-CURRENT-DATE)\n               DISPLAY \"Epoch time must be before current time\"\n               GO TO CLEANUP\n           END-IF\n           \n           COMPUTE WS-RANDOM-NUM = FUNCTION RANDOM(RANDOM-SEED)\n           \n           PERFORM CONVERT-EPOCH-TO-DATE\n           .\n           \n       PROCESS-SALES-DATA.\n           display 'process sales data'\n                             \n           PERFORM VARYING WS-PROD-INDEX FROM 1 BY 1\n              UNTIL WS-PROD-INDEX > 5\n                   \n              COMPUTE WS-RANDOM-NUM = FUNCTION RANDOM\n              COMPUTE WS-SALES-QTY = 10 + \n                       (WS-RANDOM-NUM * 41)\n                   \n              MOVE WS-PROD-NAME(WS-PROD-INDEX) \n                       TO PRODUCT-NAME\n              MOVE WS-EPOCH-DATE TO SALE-DATE(1:8)\n              MOVE WS-CURR-TIME TO SALE-DATE(9:)\n              MOVE WS-SALES-QTY TO SALE-QUANTITY\n              PERFORM UPDATE-EPOCH-DATE     \n              WRITE OUTPUT-RECORD\n                   END-WRITE\n              ADD 1 TO WS-EPOCH-DAY\n           END-PERFORM\n     \n           .\n           \n       CONVERT-EPOCH-TO-DATE.\n           display 'epoch time:' epoch-time\n           MOVE EPOCH-TIME(1:4) TO WS-EPOCH-YEAR\n           MOVE EPOCH-TIME(5:2) TO WS-EPOCH-MONTH\n           MOVE EPOCH-TIME(7:2) TO WS-EPOCH-DAY\n           MOVE WS-CURRENT-DATE(9:) TO WS-CURR-TIME\n           display 'curr-time:' ws-curr-time\n           .\n           \n       UPDATE-EPOCH-DATE.\n           display 'update epoch date'\n           IF WS-EPOCH-DAY > 31\n               MOVE 1 TO WS-EPOCH-DAY\n               ADD 1 TO WS-EPOCH-MONTH\n               IF WS-EPOCH-MONTH > 12\n                   MOVE 1 TO WS-EPOCH-MONTH\n                   ADD 1 TO WS-EPOCH-YEAR\n               END-IF\n           END-IF\n           .\n           \n       CLEANUP.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE\n           .\n\n",
      "input_file_names": "input.txt",
      "output_file_names": "sales.txt",
      "inputs": {
        "input.txt": "2021172051807 24  product1"
      },
      "outputs": {
        "sales.txt": "Product1            2021172014160725       042\nProduct2            2021172114160725       010\nProduct3            2021172214160725       018\nProduct4            2021172314160725       025\nProduct5            2021172414160725       016\n"
      }
    },
    {
      "Program_name": "task_func_22",
      "Cobol_Eval": "Write a COBOL program that reads student data from an input file named \"input.txt\", processes the data to find the student with the highest marks and the student with the maximum height, and writes the results to two separate output files named \"output-marks.txt\" and \"output-height.txt\".\n\nThe program should follow these COBOL-specific requirements:\n1. Be a valid COBOL program with proper syntax. \n2. Include the standard IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, and PROCEDURE DIVISION in the proper order.\n3. Adhere to COBOL's Area A (columns 8-11) and Area B (columns 12-72) conventions for division headers, paragraph names, and statements.\n4. Use standard COBOL indentation, especially in the PROCEDURE DIVISION, to enhance readability.\n\nThe input file contains records with each student's name, marks, and height. The program should validate the input data, ensuring the name is alphabetic and the marks and height are numeric. For valid records, it determines the student with the highest marks and the student with the maximum height. \n\nThe output files should contain the name and corresponding value (marks or height) of the student with the highest marks and maximum height respectively.\n\nStructure the program appropriately in the PROCEDURE DIVISION with paragraphs to initialize, process the data, validate the records, update the current maxima, write the output, and close the files. Use suitable data structures in WORKING-STORAGE to hold the data being processed.\n\nFocus on clearly describing the program's purpose, inputs, outputs, and key functionality without specifying detailed COBOL syntax or algorithms. The LLM should be able to understand the requirements and create a COBOL program that meets the specified functionality and formatting constraints.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. STUDENT-ANALYSIS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO \"input.txt\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE-MARKS\n               ASSIGN TO \"output-marks.txt\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE-HEIGHT\n               ASSIGN TO \"output-height.txt\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  STUDENT-RECORD.\n           05 STUDENT-NAME        PIC X(20).\n           05 STUDENT-MARKS       PIC 9(3).\n           05 STUDENT-HEIGHT      PIC 9(3).\n           \n       FD  OUTPUT-FILE-MARKS.\n       01  MARKS-RECORD.\n           05 OUT-NAME-MARKS      PIC X(20).            \n           05 OUT-MARKS           PIC 9(3).\n           \n       FD  OUTPUT-FILE-HEIGHT.\n       01  HEIGHT-RECORD.\n           05 OUT-NAME-HEIGHT     PIC X(20).\n           05 OUT-HEIGHT          PIC 9(3).\n           \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05 WS-EOF             PIC X VALUE 'N'.\n           \n       01  WS-HIGHEST-MARKS.\n           05 WS-MAX-MARKS       PIC 9(3) VALUE ZEROS.\n           05 WS-MAX-NAME-MARKS  PIC X(20).\n           \n       01  WS-HIGHEST-HEIGHT.\n           05 WS-MAX-HEIGHT      PIC 9(3) VALUE ZEROS.\n           05 WS-MAX-NAME-HEIGHT PIC X(20).\n           \n       01  WS-VALID-CHECK.\n           05 WS-NAME-VALID      PIC X VALUE 'Y'.\n           05 WS-MARKS-VALID     PIC X VALUE 'Y'.\n           05 WS-HEIGHT-VALID    PIC X VALUE 'Y'.\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INIT-PARA\n           PERFORM PROCESS-PARA UNTIL WS-EOF = 'Y'\n           PERFORM WRITE-OUTPUT-PARA\n           PERFORM CLOSE-PARA\n           STOP RUN.\n           \n       INIT-PARA.\n           display 'init para'\n           OPEN INPUT INPUT-FILE\n                OUTPUT OUTPUT-FILE-MARKS\n                OUTPUT OUTPUT-FILE-HEIGHT.\n                \n       PROCESS-PARA.\n           display 'process para' \n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   PERFORM VALIDATE-DATA\n                   IF WS-NAME-VALID = 'Y' AND \n                      WS-MARKS-VALID = 'Y' AND\n                      WS-HEIGHT-VALID = 'Y'\n                       PERFORM UPDATE-MAXIMA\n                   END-IF\n           END-READ.\n           \n       VALIDATE-DATA.\n           display 'validate-data'\n           MOVE 'Y' TO WS-NAME-VALID\n           MOVE 'Y' TO WS-MARKS-VALID\n           MOVE 'Y' TO WS-HEIGHT-VALID\n           display 'student name:' student-name\n           display 'student marks:' student-marks\n           display 'student height:' student-height \n           IF STUDENT-NAME IS NOT ALPHABETIC\n               MOVE 'N' TO WS-NAME-VALID\n           END-IF\n           display 'name valid:' ws-name-valid\n           IF STUDENT-MARKS IS NOT NUMERIC\n               MOVE 'N' TO WS-MARKS-VALID\n           END-IF\n           display 'marks valid:' ws-marks-valid\n           \n           IF STUDENT-HEIGHT IS NOT NUMERIC\n               MOVE 'N' TO WS-HEIGHT-VALID\n           END-IF\n           display 'height valid:' ws-height-valid  .\n           \n       UPDATE-MAXIMA.\n           display 'update-maxima' \n           IF STUDENT-MARKS > WS-MAX-MARKS\n               MOVE STUDENT-MARKS TO WS-MAX-MARKS\n               MOVE STUDENT-NAME TO WS-MAX-NAME-MARKS\n           END-IF\n           \n           IF STUDENT-HEIGHT > WS-MAX-HEIGHT\n               MOVE STUDENT-HEIGHT TO WS-MAX-HEIGHT\n               MOVE STUDENT-NAME TO WS-MAX-NAME-HEIGHT\n           END-IF\n           .\n  \n           \n       WRITE-OUTPUT-PARA.\n           display 'write output'\n           MOVE WS-MAX-NAME-MARKS TO OUT-NAME-MARKS\n           MOVE WS-MAX-MARKS TO OUT-MARKS\n           WRITE MARKS-RECORD\n           \n           MOVE WS-MAX-NAME-HEIGHT TO OUT-NAME-HEIGHT\n           MOVE WS-MAX-HEIGHT TO OUT-HEIGHT\n           WRITE HEIGHT-RECORD.\n           \n       CLOSE-PARA.\n           CLOSE INPUT-FILE\n                 OUTPUT-FILE-MARKS\n                 OUTPUT-FILE-HEIGHT.\n\n",
      "input_file_names": "input.txt",
      "output_file_names": [
        "output-height.txt",
        "output-marks.txt"
      ],
      "inputs": {
        "input.txt": "Rajesh              094151\nRashan              065160\nIndranil            092140\nChrist              085155\nJohn                098160\n"
      },
      "outputs": {
        "output-height.txt": "Rashan              160\n",
        "output-marks.txt": "John                098\n"
      }
    },
    {
      "Program_name": "task_func_23",
      "Cobol_Eval": "Write a valid COBOL program that generates historical stock price data for a specified number of days in the past. The program should:\n\n1. Read an input file named 'task_func23_inp' containing the number of days to generate stock prices for. \n\n2. Generate randomized stock prices for 4 companies (AMZN, GOOGL, MSFT, FB) for each date going back the specified number of days from the current date.\n\n3. Write the generated stock price data to an output file named 'task_func23_out' with fields for the date and each company's stock price, separated by commas.\n\nEnsure the program follows standard COBOL structure with IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE divisions. Use appropriate indentation, especially in the PROCEDURE DIVISION, and follow Area A/B conventions for division headers, paragraph names, and statements.\n\nHandle errors for issues like the input file being empty or containing invalid data. Include a header row in the output file.\n\nFocus on what the program needs to accomplish functionally, rather than specific implementation details or algorithms. The generated program should produce the same end result as the original.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. STOCK-PRICE-GENERATOR.\n      \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n                     \n       SELECT INPUT-FILE ASSIGN TO 'task_func23_inp'\n       ORGANIZATION IS LINE SEQUENTIAL\n       FILE STATUS IS WS-FS1.\n\n       SELECT OUTPUT-FILE ASSIGN TO 'task_func23_out'\n       ORGANIZATION IS LINE SEQUENTIAL\n       FILE STATUS IS WS-FS2.\n      \n       DATA DIVISION.\n       FILE SECTION.\n       \n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n          05 IN-NUM-DAYS            PIC 9(4).\n          05 IN-FILLER              PIC X(80) VALUE SPACES.\n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD.\n           05 OUT-DATE              PIC X(10).\n           05 OUT-DELIM1            PIC X.\n           05 OUT-STOCK1            PIC ZZ9.99.\n           05 OUT-DELIM2            PIC X.\n           05 OUT-STOCK2            PIC ZZ9.99.\n           05 OUT-DELIM3            PIC X.\n           05 OUT-STOCK3            PIC ZZ9.99.\n           05 OUT-DELIM4            PIC X.\n           05 OUT-STOCK4            PIC ZZ9.99.\n           \n       WORKING-STORAGE SECTION.\n       01 WS-FS1                    PIC X(02).\n          88 WS-FS1-OK              VALUE \"00\".\n          88 WS-FS1-EOF             VALUE \"10\".\n       01 WS-FS2                    PIC X(02).\n          88 WS-FS2-OK              VALUE \"00\".\n          88 WS-FS2-EOF             VALUE \"10\".\n       01 WS-EOF                    PIC X VALUE 'N'.\n       01 WS-RANDOM-SEED            PIC 9(8) VALUE 42.\n       01 WS-RANDOM-NUM             PIC 9(8)V9(8).\n       01 WS-STOCK-PRICE            PIC 999V999999.\n       01 WS-EDI-STK-PRICE          PIC Z99.999999.\n       01 WS-REC-COUNT              PIC 9.                 \n       01 WS-CURR-DT                PIC 9(8).\n       01 WS-DATE.\n           05 WS-YEAR          PIC 9(4).\n           05 WS-MONTH         PIC 99.\n           05 WS-DAY           PIC 99.\n       01 WS-DATE-OUT-NUM     PIC 9(8).\n       01 WS-FORMATTED-DATE   PIC X(10).\n       01 WS-INT-BACKDT       PIC S9(9) BINARY.\n       01 WS-DAYS             PIC S9(4) BINARY. \n       01 WS-BACKDT-STR       PIC 9(8).\n       01 WS-DATE-MET         PIC X VALUE 'N'.\n       01 DAYS-IN-PAST        PIC S9(04) BINARY.\n       01 WS-HEADER           PIC X(132) \n           VALUE 'STOCK DATE,AMZN,GOOGL,MSFT,FB'.\n\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-STOCKS\n           PERFORM CLOSE-PARA\n           STOP RUN.\n           \n       INITIALIZATION.\n\n           OPEN  INPUT  INPUT-FILE\n                 OUTPUT OUTPUT-FILE\n\n           IF NOT WS-FS1-OK\n              DISPLAY \"Error opening Input file:\" WS-FS1\n              PERFORM CLOSE-PARA\n              STOP RUN\n           END-IF\n\n           IF NOT WS-FS2-OK\n              DISPLAY \"Error opening Output file:\" WS-FS2\n              PERFORM CLOSE-PARA\n              STOP RUN\n           END-IF    \n      \n           PERFORM UNTIL WS-EOF = 'Y'\n             READ INPUT-FILE \n                  AT END MOVE 'Y' TO WS-EOF\n                  NOT AT END  \n                    ADD 1 TO WS-REC-COUNT            \n                    IF NOT WS-FS1-OK\n                       DISPLAY \"Error in Reading Input: \" WS-FS1\n                       PERFORM CLOSE-PARA\n                       STOP RUN\n                   END-IF  \n              END-READ\n            END-PERFORM\n\n           IF WS-REC-COUNT = 0\n              DISPLAY \"Input cannot be empty: \" WS-FS1\n              PERFORM CLOSE-PARA\n              STOP RUN\n           ELSE IF WS-REC-COUNT > 1     \n              DISPLAY \"Invalid input: \" WS-FS1\n              PERFORM CLOSE-PARA\n              STOP RUN\n              END-IF\n           END-IF\n           \n           MOVE IN-NUM-DAYS TO DAYS-IN-PAST           \n\n           WRITE OUTPUT-RECORD FROM WS-HEADER\n           MOVE FUNCTION CURRENT-DATE(1:8) TO WS-CURR-DT\n           .                                         \n             \n       PROCESS-STOCKS.\n           MOVE DAYS-IN-PAST TO WS-DAYS\n           PERFORM UNTIL WS-DAYS <= 0 \n              COMPUTE WS-INT-BACKDT = \n              FUNCTION INTEGER-OF-DATE(WS-CURR-DT) - WS-DAYS                                \n              COMPUTE WS-DATE-OUT-NUM = \n              FUNCTION DATE-OF-INTEGER(WS-INT-BACKDT)                                 \n              MOVE WS-DATE-OUT-NUM TO WS-DATE\n              PERFORM GENERATE-LINE\n              WRITE OUTPUT-RECORD\n              COMPUTE WS-DAYS = WS-DAYS - 1                         \n           END-PERFORM.\n           \n       GENERATE-LINE.\n           INITIALIZE OUTPUT-RECORD\n           MOVE WS-YEAR TO WS-FORMATTED-DATE(1:4)\n           MOVE '-' TO WS-FORMATTED-DATE(5:1)\n           MOVE WS-MONTH TO WS-FORMATTED-DATE(6:2)\n           MOVE '-' TO WS-FORMATTED-DATE(8:1)\n           MOVE WS-DAY TO WS-FORMATTED-DATE(9:2)\n           MOVE WS-FORMATTED-DATE TO OUT-DATE\n           MOVE ',' TO OUT-DELIM1\n                       OUT-DELIM2\n                       OUT-DELIM3\n                       OUT-DELIM4\n           COMPUTE WS-RANDOM-NUM = FUNCTION RANDOM(WS-RANDOM-SEED) \n           COMPUTE WS-STOCK-PRICE = WS-RANDOM-NUM * 114 + WS-DAYS\n           MOVE WS-STOCK-PRICE TO OUT-STOCK1              \n           COMPUTE WS-RANDOM-NUM = FUNCTION RANDOM(WS-RANDOM-SEED) \n           COMPUTE WS-STOCK-PRICE = WS-RANDOM-NUM * 107 + WS-DAYS\n           MOVE WS-STOCK-PRICE TO OUT-STOCK2   \n           COMPUTE WS-RANDOM-NUM = FUNCTION RANDOM(WS-RANDOM-SEED) \n           COMPUTE WS-STOCK-PRICE = WS-RANDOM-NUM * 118 + WS-DAYS\n           MOVE WS-STOCK-PRICE TO OUT-STOCK3  \n           COMPUTE WS-RANDOM-NUM = FUNCTION RANDOM(WS-RANDOM-SEED) \n           COMPUTE WS-STOCK-PRICE = WS-RANDOM-NUM * 105 + WS-DAYS\n           MOVE WS-STOCK-PRICE TO OUT-STOCK4  \n           .\n       CLOSE-PARA.\n           \n           CLOSE INPUT-FILE\n                 OUTPUT-FILE.\n",
      "input_file_names": "task_func23_inp",
      "output_file_names": "task_func23_out",
      "inputs": {
        "task_func23_inp": "0010"
      },
      "outputs": {
        "task_func23_out": "STOCK DATE,AMZN,GOOGL,MSFT,FB\n2025-02-07, 74.88, 70.90, 77.16, 69.76\n2025-02-08, 73.88, 69.90, 76.16, 68.76\n2025-02-09, 72.88, 68.90, 75.16, 67.76\n2025-02-10, 71.88, 67.90, 74.16, 66.76\n2025-02-11, 70.88, 66.90, 73.16, 65.76\n2025-02-12, 69.88, 65.90, 72.16, 64.76\n2025-02-13, 68.88, 64.90, 71.16, 63.76\n2025-02-14, 67.88, 63.90, 70.16, 62.76\n2025-02-15, 66.88, 62.90, 69.16, 61.76\n2025-02-16, 65.88, 61.90, 68.16, 60.76\n"
      }
    },
    {
      "Program_name": "task_func_24",
      "Cobol_Eval": "Write a COBOL program that compares two CSV files line by line and generates a report file showing the differences between them. The program should:\n\n1. Read input from two files: 'task_func24_inp1' and 'task_func24_inp2'. \n2. Compare each line from the two files. If the lines are identical, write the line to the output file 'task_func24_out' with a blank status. If the lines differ, write both lines to the output file with '-' and '+' status indicators respectively.\n3. If one file has more lines than the other, write the extra lines to the output file with the appropriate '-' or '+' status.\n4. The output file should have this CSV format: Line Number, Status (' ', '-' or '+'), Line Content.\n\nEnsure the program follows standard COBOL structure:  \n- IDENTIFICATION DIVISION with PROGRAM-ID\n- ENVIRONMENT DIVISION with INPUT-OUTPUT SECTION for file handling \n- DATA DIVISION with FILE SECTION and WORKING-STORAGE SECTION for data definitions\n- PROCEDURE DIVISION with main processing logic\n\nAdhere to COBOL coding conventions:\n- Division headers and paragraph names in Area A (columns 8-11) \n- Statements in Area B (columns 12-72)\n- Use consistent indentation, especially in PROCEDURE DIVISION\n\nHandle file open/close and any errors appropriately. The program should be a complete, executable COBOL program.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. CSV-COMPARE.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT FILE1 ASSIGN TO 'task_func24_inp1'\n               ORGANIZATION IS LINE SEQUENTIAL\n               FILE STATUS IS WS-FILE1-STATUS.\n               \n           SELECT FILE2 ASSIGN TO 'task_func24_inp2'\n               ORGANIZATION IS LINE SEQUENTIAL\n               FILE STATUS IS WS-FILE2-STATUS.\n               \n           SELECT REPORT-FILE ASSIGN TO 'task_func24_out'\n               ORGANIZATION IS LINE SEQUENTIAL\n               FILE STATUS IS WS-REPORT-STATUS.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  FILE1.\n       01  FILE1-REC.\n           05 F1-DATA    PIC X(50).\n           \n       FD  FILE2.\n       01  FILE2-REC.\n           05 F2-DATA    PIC X(50).\n           \n       FD  REPORT-FILE.\n       01  REPORT-REC.\n           05 REP-DATA   PIC X(100).\n           \n       WORKING-STORAGE SECTION.\n       01  WS-FILE-STATUS.\n           05 WS-FILE1-STATUS     PIC XX.\n           05 WS-FILE2-STATUS     PIC XX.\n           05 WS-REPORT-STATUS    PIC XX.\n           \n       01  WS-COUNTERS.\n           05 WS-LINE-NUM         PIC 9(6) VALUE 0.\n           \n       01  WS-FLAGS.\n           05 WS-EOF1             PIC X VALUE 'N'.\n           05 WS-EOF2             PIC X VALUE 'N'.\n           \n       01  WS-REPORT-LINE.\n           05 WS-RPT-LINE-NUM     PIC 9(6).\n           05 FILLER              PIC X VALUE ','.\n           05 WS-RPT-STATUS       PIC X.\n           05 FILLER              PIC X VALUE ','.\n           05 WS-RPT-CONTENT      PIC X(100).\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-FILES UNTIL WS-EOF1 = 'Y' AND WS-EOF2 = 'Y'\n           PERFORM CLEANUP\n           STOP RUN.\n           \n       INITIALIZATION.\n           OPEN INPUT FILE1\n           IF WS-FILE1-STATUS NOT = '00'\n               DISPLAY 'Error opening FILE1: ' WS-FILE1-STATUS\n               PERFORM CLEANUP\n               STOP RUN\n           END-IF\n           \n           OPEN INPUT FILE2\n           IF WS-FILE2-STATUS NOT = '00'\n               DISPLAY 'Error opening FILE2: ' WS-FILE2-STATUS\n               PERFORM CLEANUP\n               STOP RUN\n           END-IF\n           \n           OPEN OUTPUT REPORT-FILE\n           IF WS-REPORT-STATUS NOT = '00'\n               DISPLAY 'Error opening REPORT: ' WS-REPORT-STATUS\n               PERFORM CLEANUP\n               STOP RUN\n           END-IF\n           \n           MOVE 'Line Number,Status,Content' TO REP-DATA\n           WRITE REPORT-REC.\n           \n       PROCESS-FILES.\n           ADD 1 TO WS-LINE-NUM\n           \n           IF WS-EOF1 = 'N' \n               READ FILE1\n                   AT END MOVE 'Y' TO WS-EOF1\n                   NOT AT END \n                      CONTINUE                  \n               END-READ\n           END-IF\n           \n           IF WS-EOF2 = 'N'\n               READ FILE2\n                   AT END MOVE 'Y' TO WS-EOF2\n                   NOT AT END CONTINUE\n               END-READ\n           END-IF\n           \n           IF (WS-EOF1 = 'N' AND WS-EOF2 = 'N' )\n               AND (F1-DATA <> ' ') AND (F2-DATA <> ' ')\n               IF F1-DATA = F2-DATA\n                   MOVE ' ' TO WS-RPT-STATUS\n                   MOVE F1-DATA TO WS-RPT-CONTENT\n               ELSE\n                   MOVE '-' TO WS-RPT-STATUS\n                   MOVE F1-DATA TO WS-RPT-CONTENT\n                   PERFORM WRITE-REPORT-LINE\n                   MOVE '+' TO WS-RPT-STATUS\n                   MOVE F2-DATA TO WS-RPT-CONTENT\n               END-IF\n               PERFORM WRITE-REPORT-LINE\n           ELSE\n               IF (WS-EOF1 = 'N') AND F1-DATA <> ' '\n                   MOVE '-' TO WS-RPT-STATUS\n                   MOVE F1-DATA TO WS-RPT-CONTENT\n                   PERFORM WRITE-REPORT-LINE\n               END-IF\n               IF (WS-EOF2 = 'N' ) AND F2-DATA <> ' '                 \n                   MOVE '+' TO WS-RPT-STATUS\n                   MOVE F2-DATA TO WS-RPT-CONTENT\n                   PERFORM WRITE-REPORT-LINE\n               END-IF\n           END-IF.\n           \n       WRITE-REPORT-LINE.\n           MOVE WS-LINE-NUM TO WS-RPT-LINE-NUM\n           STRING WS-RPT-LINE-NUM DELIMITED BY SIZE\n                  ',' DELIMITED BY SIZE\n                  WS-RPT-STATUS DELIMITED BY SIZE\n                  ',' DELIMITED BY SIZE\n                  WS-RPT-CONTENT DELIMITED BY SIZE\n                  INTO REP-DATA\n           WRITE REPORT-REC.\n           \n       CLEANUP.\n           CLOSE FILE1\n           CLOSE FILE2\n           CLOSE REPORT-FILE.\n",
      "input_file_names": [
        "task_func24_inp1",
        "task_func24_inp2"
      ],
      "output_file_names": "task_func24_out",
      "inputs": {
        "task_func24_inp1": "Name,Age\nAlice,30\nAvantika,23\nBob,25\nAnubhav 41",
        "task_func24_inp2": "Name,Age\nAlice,31\nArun,32\nBob,25\n\n"
      },
      "outputs": {
        "task_func24_out": "Line Number,Status,Content\n000001, ,Name,Age\n000002,-,Alice,30\n000002,+,Alice,31\n000003,-,Avantika,23\n000003,+,Arun,32\n000004, ,Bob,25\n000005,-,Anubhav 41\n"
      }
    },
    {
      "Program_name": "task_func_25",
      "Cobol_Eval": "Write a valid COBOL program that calculates statistics from employee data. The program should:\n\n1. Read a column name from the file 'task_func25_inp1'. The column name will be one of: Age, Salary, or Experience. \n\n2. Read employee records from the file 'task_func25_inp2'. Each record contains an employee's age, salary, and years of experience.\n\n3. Extract the values from the specified column for each employee record. \n\n4. Calculate the sum, mean, minimum, and maximum of the values from the specified column.\n\n5. Write the calculated statistics to the output file 'task_func25_out' in CSV format.\n\nEnsure the program follows the standard COBOL division structure:\n\n- IDENTIFICATION DIVISION with PROGRAM-ID\n- ENVIRONMENT DIVISION with INPUT-OUTPUT SECTION and FILE-CONTROL \n- DATA DIVISION with FILE SECTION, FD entries, and WORKING-STORAGE SECTION\n- PROCEDURE DIVISION with main processing logic\n\nUse proper COBOL coding conventions:\n\n- Division headers and paragraph names in Area A (columns 8-11)  \n- Statements in Area B (columns 12-72)\n- Consistent indentation, especially in PROCEDURE DIVISION\n\nHandle potential errors, such as:\n\n- Invalid column name specified\n- Issues opening/reading/writing files\n- No employee records found\n\nThe program should be well-structured, readable, and modular, with separate paragraphs or sections for distinct processing steps.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. EMPLOYEE-STATS.\n      \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT COLUMN-FILE ASSIGN TO 'task_func25_inp1'\n           ORGANIZATION IS LINE SEQUENTIAL\n           FILE STATUS IS WS-FS1.\n\n           SELECT EMPLOYEE-FILE ASSIGN TO 'task_func25_inp2'\n           ORGANIZATION IS LINE SEQUENTIAL\n           FILE STATUS IS WS-FS2.\n\n           SELECT OUTPUT-FILE ASSIGN TO 'task_func25_out'\n           ORGANIZATION IS LINE SEQUENTIAL\n           FILE STATUS IS WS-FS3.\n      \n       DATA DIVISION.\n       FILE SECTION.\n\n       FD COLUMN-FILE.\n       01 COLUMN-RECORD.\n           05 COLUMN-NAME      PIC X(10).\n           05 COLUMN-FILLER    PIC X(70).\n\n       FD EMPLOYEE-FILE.\n       01 EMPLOYEE-RECORD.\n           05 EMP-AGE        PIC X(3).\n           05 FILLER         PIC X.\n           05 EMP-SALARY     PIC 9(10).\n           05 FILLER         PIC X.\n           05 EMP-EXPERIENCE PIC 9(2).\n           05 FILLER         PIC X(04).\n      \n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD.\n           05 OUT-SUM        PIC Z(9)9.99.\n           05 OUT-FILLER1    PIC X.\n           05 OUT-MEAN       PIC Z(9)9.99.\n           05 OUT-FILLER2    PIC X.\n           05 OUT-MIN        PIC Z(9)9.\n           05 OUT-FILLER3    PIC X.\n           05 OUT-MAX        PIC Z(9)9.\n      \n       WORKING-STORAGE SECTION.\n       01 WS-EOF            PIC X VALUE 'N'.\n       01 WS-FS1                    PIC X(02).\n          88 WS-FS1-OK              VALUE \"00\".\n          88 WS-FS1-EOF             VALUE \"10\".\n       01 WS-FS2                    PIC X(02).\n          88 WS-FS2-OK              VALUE \"00\".\n          88 WS-FS2-EOF             VALUE \"10\".\n        01 WS-FS3                    PIC X(02).\n          88 WS-FS3-OK              VALUE \"00\".\n          88 WS-FS3-EOF             VALUE \"10\".     \n       01 WS-VALID-COLUMN   PIC X VALUE 'N'.\n       01 WS-RECORD-COUNT   PIC 9(5) VALUE 0.      \n       01 WS-SUM            PIC 9(10)V99 VALUE 0.\n       01 WS-MEAN           PIC 9(10)V99 VALUE 0.\n       01 WS-MIN            PIC 9(10) VALUE 9999999999.\n       01 WS-MAX            PIC 9(10) VALUE 0. \n       01 WS-CURRENT-VALUE  PIC 9(10) VALUE 0.\n       01 WS-OUTPUT-STRING  PIC X(80).\n       01 WS-HEADER-SKIP    PIC X VALUE 'Y'.\n       01 WS-OUTPUT-HEADER  PIC X(30) VALUE\n                            \"Sum,Mean,Min,Max\".\n       01 WS-HEADER         PIC X(21) VALUE 'Age,Salary,Experience'.\n       01 WS-ERROR-MSG      PIC X(50).\n            \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           \n           PERFORM INITIALIZATION-PARA          \n\n           PERFORM READ-COLUMN-FILE\n\n           PERFORM VALIDATE-COLUMN\n           \n           IF WS-VALID-COLUMN = 'N'\n               DISPLAY 'Invalid column specified'\n               STOP RUN\n           END-IF            \n                   \n           PERFORM PROCESS-EMPLOYEE-FILE UNTIL WS-EOF = 'Y'\n           \n           PERFORM CALCULATE-STATISTICS\n           \n           WRITE OUTPUT-RECORD FROM WS-OUTPUT-HEADER\n\n           PERFORM WRITE-OUTPUT\n           \n           PERFORM CLOSE-FILES\n\n           STOP RUN.\n      \n       INITIALIZATION-PARA.\n\n           OPEN INPUT COLUMN-FILE\n           IF WS-FS1 NOT = '00'\n               MOVE 'Error opening column file' TO WS-ERROR-MSG\n               PERFORM ERROR-HANDLER\n           END-IF\n           \n           OPEN INPUT EMPLOYEE-FILE\n           IF WS-FS2 NOT = '00'\n               MOVE 'Error opening employee file' TO WS-ERROR-MSG\n               PERFORM ERROR-HANDLER\n           END-IF\n           \n           OPEN OUTPUT OUTPUT-FILE\n           IF WS-FS3 NOT = '00'\n               MOVE 'Error opening output file' TO WS-ERROR-MSG\n               PERFORM ERROR-HANDLER\n           END-IF.\n\n       READ-COLUMN-FILE.\n     \n           PERFORM UNTIL WS-EOF = 'Y'\n             READ COLUMN-FILE \n                  AT END MOVE 'Y' TO WS-EOF\n                  NOT AT END  \n                    ADD 1 TO WS-RECORD-COUNT            \n                    IF NOT WS-FS1-OK\n                       MOVE \"Error in Reading Input \" TO WS-ERROR-MSG\n                       PERFORM ERROR-HANDLER                    \n                   END-IF  \n              END-READ\n            END-PERFORM\n\n            IF WS-RECORD-COUNT = 0\n              MOVE \"Input cannot be empty \" TO WS-ERROR-MSG \n              PERFORM ERROR-HANDLER\n           ELSE IF WS-RECORD-COUNT > 1     \n              MOVE \"Invalid input \" TO WS-ERROR-MSG \n              PERFORM ERROR-HANDLER\n              END-IF\n           END-IF\n           \n           MOVE 0 TO WS-RECORD-COUNT\n           MOVE 'N' TO WS-EOF.\n         \n\n       PROCESS-EMPLOYEE-FILE.\n           READ EMPLOYEE-FILE\n               AT END MOVE 'Y' TO WS-EOF\n                NOT AT END\n                   IF WS-HEADER-SKIP = 'Y'\n                       MOVE 'N' TO WS-HEADER-SKIP\n                   ELSE\n                       PERFORM PROCESS-RECORDS THRU PROCESS-RECORDS-EXIT                      \n                   END-IF\n           END-READ.\n      \n       VALIDATE-COLUMN.\n\n            IF COLUMN-NAME = 'Age' OR 'Salary' OR 'Experience'\n               MOVE 'Y' TO WS-VALID-COLUMN\n           ELSE\n               MOVE 'Invalid column specified' TO WS-ERROR-MSG\n               PERFORM ERROR-HANDLER\n           END-IF.\n\n       PROCESS-RECORDS.\n     \n           IF (EMPLOYEE-RECORD  > ' ' ) AND\n              (EMPLOYEE-RECORD <>  WS-HEADER)\n              CONTINUE\n           ELSE\n              GO TO PROCESS-RECORDS-EXIT\n           END-IF\n\n           ADD 1 TO WS-RECORD-COUNT\n           \n           EVALUATE COLUMN-NAME\n               WHEN 'Age'\n                   MOVE EMP-AGE TO WS-CURRENT-VALUE\n               WHEN 'Salary'\n                   MOVE EMP-SALARY TO WS-CURRENT-VALUE\n               WHEN 'Experience'\n                   MOVE EMP-EXPERIENCE TO WS-CURRENT-VALUE\n           END-EVALUATE        \n\n           ADD WS-CURRENT-VALUE TO WS-SUM          \n\n           IF WS-CURRENT-VALUE < WS-MIN\n               MOVE WS-CURRENT-VALUE TO WS-MIN\n           END-IF          \n\n           IF WS-CURRENT-VALUE > WS-MAX\n               MOVE WS-CURRENT-VALUE TO WS-MAX\n           END-IF.\n                \n       PROCESS-RECORDS-EXIT.\n           EXIT.\n\n       CALCULATE-STATISTICS.\n           \n           IF WS-RECORD-COUNT = 0\n              MOVE 0 TO WS-SUM\n              MOVE 0 TO WS-MEAN\n              MOVE 0 TO WS-MIN\n              MOVE 0 TO WS-MAX\n           ELSE\n               COMPUTE WS-MEAN = WS-SUM / WS-RECORD-COUNT\n           END-IF.\n\n       WRITE-OUTPUT.\n           INITIALIZE OUTPUT-RECORD          \n           MOVE WS-SUM  TO OUT-SUM\n           MOVE WS-MEAN TO OUT-MEAN\n           MOVE WS-MIN  TO OUT-MIN\n           MOVE WS-MAX  TO OUT-MAX\n           MOVE ','     TO OUT-FILLER1\n                           OUT-FILLER2\n                           OUT-FILLER3\n           WRITE OUTPUT-RECORD.\n\n        CLOSE-FILES.\n\n          CLOSE COLUMN-FILE\n                EMPLOYEE-FILE\n                OUTPUT-FILE.\n            \n        ERROR-HANDLER.\n           DISPLAY WS-ERROR-MSG\n           PERFORM CLOSE-FILES\n           STOP RUN.\n             \n        END PROGRAM EMPLOYEE-STATS.\n\n\n",
      "input_file_names": [
        "task_func25_inp1",
        "task_func25_inp2"
      ],
      "output_file_names": "task_func25_out",
      "inputs": {
        "task_func25_inp1": "Experience",
        "task_func25_inp2": "Age,Salary,Experience\n025,0000050000,02\n030,0000075000,05\n035,0000100000,07\n040,0000125000,10\n045,0000150000,12"
      },
      "outputs": {
        "task_func25_out": "Sum,Mean,Min,Max\n        36.00,         7.20,         2,        12\n"
      }
    },
    {
      "Program_name": "task_func_26",
      "Cobol_Eval": "Write a COBOL program that generates a monthly sales report. The program should:\n\n1. Read sales data from an input file named 'task_func26_inp'. Each record contains the department number, salesperson ID, and sales amount. \n\n2. Process the sales data, keeping a running total of sales for each department.\n\n3. Whenever the department number changes, print the total sales for the previous department.\n\n4. Generate a report that is written to an output file named 'task_func26_out'. The report should include a heading with a page number, detail lines showing each salesperson's sales, and a summary line for each department's total sales.\n\nEnsure the COBOL program follows these guidelines:\n\n1. It must be a valid COBOL program.\n\n2. Use the standard COBOL division structure: IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, and PROCEDURE DIVISION. \n\n3. Follow COBOL coding conventions for Area A (columns 8-11) and Area B (columns 12-72).\n\n4. Use standard COBOL indentation to improve readability, especially in the PROCEDURE DIVISION.\n\nHandle any file errors gracefully. The program should keep track of variables like end-of-file condition, current department, page count, line count, etc. as needed to control the flow and format the report properly.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SALES-REPORT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'task_func26_inp'\n               ORGANIZATION IS LINE SEQUENTIAL\n               FILE STATUS IS WS-FS1.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'task_func26_out'\n               ORGANIZATION IS LINE SEQUENTIAL\n               FILE STATUS IS WS-FS2.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE\n          LABEL RECORDS ARE STANDARD.\n       01 INPUT-RECORD.\n           05 IN-DEPT-NO           PIC 9(02).\n           05 IN-FILLER1           PIC X.\n           05 IN-SALES-ID          PIC 9(04).\n           05 IN-FILLER2           PIC X.\n           05 IN-SALES-AMT         PIC 9(06)V99. \n           05 IN-FILLER3           PIC X(40) VALUE SPACES.        \n           \n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD            PIC X(132).\n       \n       WORKING-STORAGE SECTION.\n       01 EOF                      PIC 9 VALUE 0.\n       01 WS-FS1                   PIC X(02).\n          88 WS-FS1-OK             VALUE \"00\".\n          88 WS-FS1-EOF            VALUE \"10\".\n       01 WS-FS2                   PIC X(02).\n          88 WS-FS2-OK             VALUE \"00\".\n           \n       01 WS-VARIABLES.\n           05 WS-CURR-DEPT         PIC X(02) VALUE SPACES.\n           05 WS-DEPT-TOTAL        PIC 9(08)V99.\n           05 WS-FIRST-REC         PIC X VALUE 'Y'.\n           05 WS-LINE-CT           PIC 9(02) VALUE ZEROS.\n           05 WS-PAGE-CT           PIC 9(02) VALUE ZEROS.\n           05 WS-REC-CT            PIC 9(02) VALUE ZEROS.\n\n       01 WS-INP-HEADER            PIC X(40).\n           \n       01 WS-DETAIL-LINE.\n           05 FILLER               PIC X(11) VALUE SPACES.\n           05 WS-DET-DEPT          PIC X(02).\n           05 FILLER               PIC X(09) VALUE SPACES.         \n           05 WS-DET-ID            PIC X(04).\n           05 FILLER               PIC X(14) VALUE SPACES.\n           05 WS-DET-AMT           PIC $Z(06).99.\n           \n       01 WS-TOTAL-LINE.\n           05 FILLER               PIC X(60) VALUE SPACES.\n           05 FILLER               PIC X(27) \n              VALUE 'Total Sales for Department '.\n           05 WS-TOT-DEPT          PIC X(02).\n           05 FILLER               PIC X(04) VALUE ' is '.\n           05 WS-TOT-AMT           PIC $Z(07).99.\n           05 FILLER               PIC X(20) VALUE SPACES.         \n   \n       01 WS-HEADER-1.\n           05 FILLER               PIC X(49) VALUE SPACES.\n           05 FILLER               PIC X(21) VALUE \n              'MONTHLY STATUS REPORT'.\n           05 FILLER               PIC X(09) VALUE SPACES.\n           05 WS-HDR1-PGNO-OUT     PIC 9(02).\n           05 FILLER               PIC X(46) VALUE SPACES.\n  \n       01 WS-HEADER-2.\n           05 FILLER               PIC X(10) VALUE SPACES.\n           05 FILLER               PIC X(10) VALUE 'DEPT'.\n           05 FILLER               PIC X(20) VALUE\n              'SALESPERSON NO'.\n           05 FILLER               PIC X(12) VALUE \n              'AMT OF SALES'.     \n           05 FILLER               PIC X(80) VALUE SPACES.           \n           \n       PROCEDURE DIVISION.\n       000-MAIN-PARA.\n           PERFORM 100-INIT-PARA\n           PERFORM 200-WRITE-HEADING\n           INITIALIZE INPUT-RECORD\n           READ INPUT-FILE INTO INPUT-RECORD\n               AT END \n                   MOVE 1           TO EOF    \n               NOT AT END  \n                   IF NOT WS-FS1-OK\n                       DISPLAY \"Error in Reading Input: \" WS-FS1\n                   END-IF              \n           END-READ         \n          \n           PERFORM UNTIL EOF = 1 \n              INITIALIZE INPUT-RECORD\n              READ INPUT-FILE INTO INPUT-RECORD\n               AT END \n                   MOVE 1           TO EOF    \n               NOT AT END  \n                   IF NOT WS-FS1-OK\n                       DISPLAY \"Error in Reading Input: \" WS-FS1\n                   END-IF \n                   ADD 1            TO WS-REC-CT                \n                   PERFORM 300-PROCESS-PARA\n              END-READ         \n          \n           END-PERFORM\n           \n           PERFORM 400-CLOSE-PARA\n\n           STOP RUN.\n           \n       100-INIT-PARA.\n           OPEN INPUT INPUT-FILE\n              OUTPUT OUTPUT-FILE\n\n           INITIALIZE INPUT-RECORD\n\n           IF NOT WS-FS1-OK\n              DISPLAY \"Error opening Input file:\" WS-FS1\n           END-IF\n\n           IF NOT WS-FS2-OK\n              DISPLAY \"Error opening Output file:\" WS-FS2\n           END-IF.                   \n       \n       200-WRITE-HEADING.\n           ADD 1 TO WS-PAGE-CT\n           MOVE WS-PAGE-CT      TO WS-HDR1-PGNO-OUT\n           WRITE OUTPUT-RECORD FROM WS-HEADER-1\n                 AFTER ADVANCING PAGE\n           WRITE OUTPUT-RECORD FROM WS-HEADER-2\n                 AFTER ADVANCING 2 LINES\n           MOVE ZEROS           TO  WS-LINE-CT.  \n\n       300-PROCESS-PARA.\n                   \n           EVALUATE TRUE\n               WHEN WS-FIRST-REC = 'Y' \n                    MOVE IN-DEPT-NO TO WS-CURR-DEPT                   \n                    MOVE 'N'        TO WS-FIRST-REC\n               WHEN IN-DEPT-NO <> WS-CURR-DEPT\n                    PERFORM 310-CONTROL-BREAK\n           END-EVALUATE       \n\n           IF WS-LINE-CT > 25\n              PERFORM  200-WRITE-HEADING\n           END-IF\n\n           PERFORM 320-WRITE-DETAIL.\n\n       310-CONTROL-BREAK.\n           MOVE WS-DEPT-TOTAL      TO WS-TOT-AMT\n           MOVE WS-CURR-DEPT       TO WS-TOT-DEPT\n           WRITE OUTPUT-RECORD FROM WS-TOTAL-LINE\n                 AFTER ADVANCING 2 LINES\n           ADD 1                   TO WS-LINE-CT\n           MOVE ZEROS              TO WS-DEPT-TOTAL\n           MOVE WS-CURR-DEPT TO WS-TOT-DEPT.           \n           \n       320-WRITE-DETAIL.\n           MOVE IN-DEPT-NO          TO WS-DET-DEPT    \n                                       WS-CURR-DEPT                     \n           MOVE IN-SALES-ID         TO WS-DET-ID\n           MOVE IN-SALES-AMT        TO WS-DET-AMT\n           WRITE OUTPUT-RECORD FROM WS-DETAIL-LINE\n                 AFTER ADVANCING 2 LINES          \n           ADD 1                   TO WS-LINE-CT\n           ADD IN-SALES-AMT        TO WS-DEPT-TOTAL.           \n               \n       400-CLOSE-PARA.\n           MOVE WS-DEPT-TOTAL      TO WS-TOT-AMT\n           MOVE WS-CURR-DEPT       TO WS-TOT-DEPT\n           WRITE OUTPUT-RECORD   FROM WS-TOTAL-LINE\n                 AFTER ADVANCING 2 LINES\n           CLOSE INPUT-FILE\n                 OUTPUT-FILE.\n\n\n",
      "input_file_names": "task_func26_inp",
      "output_file_names": "task_func26_out",
      "inputs": {
        "task_func26_inp": "Dept_No,Sales_Id,Sales_Amount\n01,1234,00100000\n01,4567,00010000\n01,8901,00010000\n02,1894,00024260\n02,2461,50093200"
      },
      "outputs": {
        "task_func26_out": "\f                                                 MONTHLY STATUS REPORT         01\n\n          DEPT      SALESPERSON NO      AMT OF SALES\n\n           01         1234              $  1000.00\n\n           01         4567              $   100.00\n\n           01         8901              $   100.00\n\n                                                            Total Sales for Department 01 is $   1200.00\n\n           02         1894              $   242.60\n\n           02         2461              $500932.00\n\n                                                            Total Sales for Department 02 is $ 501174.60\n"
      }
    },
    {
      "Program_name": "task_func_27",
      "Cobol_Eval": "Write a valid COBOL program that calculates compound interest over a period of years for bank accounts. The program should:\n\n- Follow the standard COBOL division structure with IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE divisions \n- Use proper COBOL formatting conventions for Area A (columns 8-11) and Area B (columns 12-72)\n- Indent code appropriately, especially in the PROCEDURE DIVISION, to improve readability\n\nThe program will read an input file named 'task_func27_inp' containing records with:\n- Account number \n- Depositor name\n- Principal amount\n- Interest rate \n- Number of years for the investment\n\nIt should process each record and calculate the new balance and accrued interest for each year based on the provided principal, rate and investment period.\n\nThe program should generate a report written to an output file named 'task_func27_out'. For each input record, the report should include:\n- A header with the account details\n- A table showing the year, new balance, and accrued interest amount for each year in the investment period\n\nEnsure the program properly handles opening and closing the input and output files. It should check for any file errors and display appropriate messages.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. COMPOUND-INTEREST.       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE ASSIGN TO 'task_func27_inp'\n           ORGANIZATION IS LINE SEQUENTIAL\n           FILE STATUS IS WS-FS1.\n         \n           SELECT OUTPUT-FILE ASSIGN TO 'task_func27_out'\n           ORGANIZATION IS LINE SEQUENTIAL\n           FILE STATUS IS WS-FS2.\n      \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE      \n          LABEL RECORDS ARE STANDARD\n          RECORD CONTAINS 80 CHARACTERS.\n       01 INPUT-RECORD.\n          05 IN-ACCT-NO        PIC X(5).\n          05 FILLER            PIC X.\n          05 IN-DEPOSITOR-NAME\n                               PIC X(20).\n          05 FILLER            PIC X.\n          05 IN-PRINCIPAL      PIC 9(5).\n          05 FILLER            PIC X.\n          05 IN-RATE           PIC V99.\n          05 FILLER            PIC X.\n          05 IN-PERIOD-OF-INV  PIC 99.\n          05 IN-FILLER         PIC X(46) VALUE SPACES.\n       \n       FD OUTPUT-FILE\n          LABEL RECORDS ARE OMITTED\n          RECORD CONTAINS 80 CHARACTERS.\n       01 OUTPUT-RECORD        PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       01 WS-EOF              PIC X VALUE 'N'.\n       01 WS-FS1                   PIC X(02).\n          88 WS-FS1-OK             VALUE \"00\".\n          88 WS-FS1-EOF            VALUE \"10\".\n       01 WS-FS2                   PIC X(02).\n          88 WS-FS2-OK             VALUE \"00\".   \n    \n       01 WS-HEADER1.\n          05 FILLER           PIC X(40) VALUE SPACES.\n          05 FILLER           PIC X(40) \n             VALUE 'PRINCIPAL TABLE'.\n     \n       01 WS-HEADER2.\n          05 FILLER           PIC X(10) VALUE SPACES.\n          05 FILLER           PIC X(10) \n             VALUE 'ACCT NO'.         \n          05 H2-ACCT-NO-OUT    PIC X(5).\n         \n       01 WS-HEADER3.\n          05 FILLER           PIC X(10) VALUE SPACES.\n          05 FILLER           PIC X(15) \n             VALUE 'DEPOSITOR NAME'.         \n          05 H3-NAME-OUT      PIC X(20).\n \n       01 WS-HEADER4.\n          05 FILLER           PIC X(10) VALUE SPACES.\n          05 FILLER           PIC X(10) \n             VALUE 'PRINCIPAL'.         \n          05 H4-PRINCIPAL-OUT PIC $ZZ,ZZZ.\n         \n       01 WS-HEADER5.\n          05 FILLER           PIC X(10) VALUE SPACES.\n          05 FILLER           PIC X(5) \n             VALUE 'RATE'.         \n          05 H5-RATE-OUT      PIC .99.\n       \n       01 WS-HEADER6.\n          05 FILLER           PIC X(10) VALUE SPACES.         \n          05 FILLER           PIC X(12) \n             VALUE 'NO OF YEARS'.         \n          05 H6-PERIOD-OUT    PIC Z9.\n\n        01 COLUMN-HEADINGS.\n          05 FILLER           PIC X(27) VALUE SPACES.\n          05 FILLER           PIC X(13) \n             VALUE 'YEAR'.    \n          05 FILLER           PIC X(20)\n             VALUE 'NEW BALANCE'.\n          05 FILLER           PIC X(20)\n             VALUE 'ACCRUED INTEREST'.\n\n       01 WS-DETAIL-LINE.\n          05 FILLER           PIC X(28) VALUE SPACES.\n          05 WS-YEAR-OUT      PIC Z9.\n          05 FILLER           PIC X(10) VALUE SPACES.\n          05 WS-NEW-BAL-OUT   PIC $ZZZ,ZZZ.99.\n          05 FILLER           PIC X(09) VALUE SPACES.\n          05 WS-ACCRUED-INT-OUT   PIC $ZZ,ZZZ.99.\n       \n       01 WS-CALCULATIONS.\n          05 WS-NEW-BALANCE   PIC 9(6)V99.          \n          05 WS-YEAR-CTR      PIC 99.\n            \n       PROCEDURE DIVISION.\n       000-MAIN-PARA.\n      \n           PERFORM 100-INITIALIZATION\n           READ INPUT-FILE\n               AT END MOVE 'Y' TO WS-EOF\n               NOT AT END              \n                    IF NOT WS-FS1-OK\n                       DISPLAY \"Error in Reading Input: \" WS-FS1\n                   END-IF          \n           END-READ.\n           \n           PERFORM 200-PROCESS-RECORDS UNTIL WS-EOF = 'Y'\n           PERFORM 300-CLOSE-PARA      \n           STOP RUN.\n       \n       100-INITIALIZATION.\n           OPEN INPUT INPUT-FILE\n                OUTPUT OUTPUT-FILE\n           \n           INITIALIZE INPUT-RECORD\n\n           IF NOT WS-FS1-OK\n              DISPLAY \"Error opening Input file:\" WS-FS1\n              STOP RUN\n           END-IF\n\n           IF NOT WS-FS2-OK\n              DISPLAY \"Error opening Output file:\" WS-FS2\n              STOP RUN\n           END-IF            \n                 \n           READ INPUT-FILE\n               AT END MOVE 'Y' TO WS-EOF\n               NOT AT END \n                   IF NOT WS-FS1-OK\n                       DISPLAY \"Error in Reading Input: \" WS-FS1\n                       STOP RUN\n                   END-IF          \n           END-READ.\n\n       200-PROCESS-RECORDS.\n           PERFORM 220-PRINT-HEADER\n \n           PERFORM 240-COMPUTE-INTEREST VARYING WS-YEAR-CTR FROM 1 BY 1\n              UNTIL WS-YEAR-CTR >   IN-PERIOD-OF-INV\n\n           READ INPUT-FILE\n               AT END MOVE 'Y' TO WS-EOF\n               NOT AT END            \n                    IF NOT WS-FS1-OK\n                       DISPLAY \"Error in Reading Input: \" WS-FS1\n                       STOP RUN\n                   END-IF                \n           END-READ.\n\n       220-PRINT-HEADER.\n           \n           WRITE OUTPUT-RECORD FROM WS-HEADER1\n                 AFTER ADVANCING PAGE        \n           MOVE IN-ACCT-NO        TO H2-ACCT-NO-OUT \n           MOVE IN-DEPOSITOR-NAME TO H3-NAME-OUT\n           MOVE IN-PRINCIPAL      TO H4-PRINCIPAL-OUT\n           MOVE IN-RATE           TO H5-RATE-OUT\n           MOVE IN-PERIOD-OF-INV  TO H6-PERIOD-OUT\n           WRITE OUTPUT-RECORD FROM WS-HEADER2\n                 AFTER ADVANCING 3 LINES                 \n           WRITE OUTPUT-RECORD FROM WS-HEADER3\n                 AFTER ADVANCING 2 LINES                              \n           WRITE OUTPUT-RECORD FROM WS-HEADER4\n                 AFTER ADVANCING 2 LINES   \n           WRITE OUTPUT-RECORD FROM WS-HEADER5\n                 AFTER ADVANCING 2 LINES        \n           WRITE OUTPUT-RECORD FROM WS-HEADER6\n                AFTER ADVANCING 2 LINES              \n           WRITE OUTPUT-RECORD FROM COLUMN-HEADINGS\n                AFTER ADVANCING 2 LINES.\n                        \n        240-COMPUTE-INTEREST.\n           \n           MOVE WS-YEAR-CTR TO WS-YEAR-OUT\n        \n           COMPUTE WS-NEW-BALANCE = IN-PRINCIPAL *\n                   ( 1 + IN-RATE) ** WS-YEAR-CTR\n          \n           MOVE WS-NEW-BALANCE TO WS-NEW-BAL-OUT\n           \n           SUBTRACT IN-PRINCIPAL FROM WS-NEW-BALANCE\n                    GIVING WS-ACCRUED-INT-OUT\n     \n           WRITE OUTPUT-RECORD FROM WS-DETAIL-LINE\n                 AFTER ADVANCING 2 LINES.\n          \n         300-CLOSE-PARA.\n           CLOSE INPUT-FILE \n                 OUTPUT-FILE.\n",
      "input_file_names": "task_func27_inp",
      "output_file_names": "task_func27_out",
      "inputs": {
        "task_func27_inp": "Account_No,Depositor_Name,Principal,Interest_Rate,Period_of_inv\n12345,DEBBY BROWN         ,10000,01,05\n23456,MARCUS XIVAN        ,00500,05,20\n45567,XEQUUXIX            ,10300,56,05\n42347,XEQAFX              ,00300,56,03"
      },
      "outputs": {
        "task_func27_out": "\f                                        PRINCIPAL TABLE\n\n\n          ACCT NO   12345\n\n          DEPOSITOR NAME DEBBY BROWN\n\n          PRINCIPAL $10,000\n\n          RATE .01\n\n          NO OF YEARS  5\n\n                           YEAR         NEW BALANCE         ACCRUED INTEREST\n\n                             1          $ 10,100.00         $   100.00\n\n                             2          $ 10,201.00         $   201.00\n\n                             3          $ 10,303.01         $   303.01\n\n                             4          $ 10,406.04         $   406.04\n\n                             5          $ 10,510.10         $   510.10\f                                        PRINCIPAL TABLE\n\n\n          ACCT NO   23456\n\n          DEPOSITOR NAME MARCUS XIVAN\n\n          PRINCIPAL $   500\n\n          RATE .05\n\n          NO OF YEARS 20\n\n                           YEAR         NEW BALANCE         ACCRUED INTEREST\n\n                             1          $    525.00         $    25.00\n\n                             2          $    551.25         $    51.25\n\n                             3          $    578.81         $    78.81\n\n                             4          $    607.75         $   107.75\n\n                             5          $    638.14         $   138.14\n\n                             6          $    670.04         $   170.04\n\n                             7          $    703.55         $   203.55\n\n                             8          $    738.72         $   238.72\n\n                             9          $    775.66         $   275.66\n\n                            10          $    814.44         $   314.44\n\n                            11          $    855.16         $   355.16\n\n                            12          $    897.92         $   397.92\n\n                            13          $    942.82         $   442.82\n\n                            14          $    989.96         $   489.96\n\n                            15          $  1,039.46         $   539.46\n\n                            16          $  1,091.43         $   591.43\n\n                            17          $  1,146.00         $   646.00\n\n                            18          $  1,203.30         $   703.30\n\n                            19          $  1,263.47         $   763.47\n\n                            20          $  1,326.64         $   826.64\f                                        PRINCIPAL TABLE\n\n\n          ACCT NO   45567\n\n          DEPOSITOR NAME XEQUUXIX\n\n          PRINCIPAL $10,300\n\n          RATE .56\n\n          NO OF YEARS  5\n\n                           YEAR         NEW BALANCE         ACCRUED INTEREST\n\n                             1          $ 16,068.00         $ 5,768.00\n\n                             2          $ 25,066.08         $14,766.08\n\n                             3          $ 39,103.08         $28,803.08\n\n                             4          $ 61,000.81         $50,700.81\n\n                             5          $ 95,161.26         $84,861.26\f                                        PRINCIPAL TABLE\n\n\n          ACCT NO   42347\n\n          DEPOSITOR NAME XEQAFX\n\n          PRINCIPAL $   300\n\n          RATE .56\n\n          NO OF YEARS  3\n\n                           YEAR         NEW BALANCE         ACCRUED INTEREST\n\n                             1          $    468.00         $   168.00\n\n                             2          $    730.08         $   430.08\n\n                             3          $  1,138.92         $   838.92\n"
      }
    },
    {
      "Program_name": "task_func_28",
      "Cobol_Eval": "Create a valid COBOL program that reads data records from an input file named 'task_func28_inp', identifies duplicate records, counts the number of occurrences of each duplicate record, and writes the duplicate records and their counts to an output file named 'task_func28_out'. \n\nEnsure the program follows the standard COBOL division structure:\n- IDENTIFICATION DIVISION with PROGRAM-ID \n- ENVIRONMENT DIVISION with INPUT-OUTPUT SECTION for file assignments\n- DATA DIVISION with FILE SECTION and WORKING-STORAGE SECTION for data definitions\n- PROCEDURE DIVISION containing the program logic\n\nOrganize the PROCEDURE DIVISION into logical paragraphs for improved readability. Use COBOL best practices for indentation and adhere to Area A (columns 8-11) for division headers and paragraph names, and Area B (columns 12-72) for statements.\n\nThe program should handle up to a maximum of 100 input records, and gracefully terminate with an error message if this limit is exceeded. Records are a maximum of 80 characters wide.\n\nThe output file should contain one line per duplicate record found, with each line consisting of the duplicate record data followed by ': ' and then the count of occurrences, e.g. \"DUPLICATE-RECORD: 9999\" where 9999 is the number of times that record appears in the input file.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. FIND-DUPLICATES.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'task_func28_inp'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'task_func28_out'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD             PIC X(80).\n       \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD            PIC X(132).\n       \n       WORKING-STORAGE SECTION.\n       01  WS-EOF-FLAG             PIC X VALUE 'N'.\n           88 WS-EOF               VALUE 'Y'.\n       \n       01  WS-COUNTERS.\n           05 WS-ROW-COUNT         PIC 9(3) VALUE 0.\n           05 WS-DUP-COUNT         PIC 9(3) VALUE 0.\n       \n       01  WS-MAX-ROWS             PIC 9(3) VALUE 100.\n       \n       01  WS-TABLE.\n           05 WS-INP-ROW OCCURS 100 TIMES INDEXED BY WS-IDX.\n               10 WS-INP-ROW-DATA  PIC X(80).\n               10 WS-INP-ROW-COUNT PIC 9(2) VALUE 0.\n               10 WS-INP-PROCESSED PIC X VALUE 'N'.\n       \n       01  WS-OUTPUT-LINE.\n           05 WS-OUT-DATA          PIC X(80).\n           05 FILLER               PIC X(2) VALUE ': '.\n           05 WS-OUT-COUNT         PIC Z(4)9.\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZE-PARA\n           PERFORM READ-INPUT-FILE\n           PERFORM PROCESS-DUPLICATES\n           PERFORM WRITE-OUTPUT-FILE\n           PERFORM CLOSE-FILES\n           STOP RUN.\n       \n       INITIALIZE-PARA.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE\n           MOVE 'N' TO WS-EOF-FLAG.\n       \n       READ-INPUT-FILE.\n           PERFORM UNTIL WS-EOF\n               READ INPUT-FILE\n                   AT END\n                       SET WS-EOF TO TRUE\n                   NOT AT END\n                          ADD 1 TO WS-ROW-COUNT\n                          IF WS-ROW-COUNT > WS-MAX-ROWS\n                             DISPLAY \"Error : Maximum count exceeded\" \n                             STOP RUN\n                          ELSE\n                             MOVE INPUT-RECORD \n                             TO WS-INP-ROW-DATA(WS-ROW-COUNT)\n                          END-IF\n               END-READ\n           END-PERFORM.\n       \n       PROCESS-DUPLICATES.\n           PERFORM VARYING WS-IDX FROM 1 BY 1\n               UNTIL WS-IDX > WS-ROW-COUNT\n               IF WS-INP-PROCESSED(WS-IDX) = 'N'\n                   MOVE 1 TO WS-INP-ROW-COUNT(WS-IDX)\n                   MOVE 'Y' TO WS-INP-PROCESSED(WS-IDX)\n                   PERFORM COUNT-DUPLICATES\n               END-IF\n           END-PERFORM.\n       \n       COUNT-DUPLICATES.\n           PERFORM VARYING WS-DUP-COUNT FROM WS-IDX BY 1\n               UNTIL WS-DUP-COUNT > WS-ROW-COUNT\n               IF (WS-INP-ROW-DATA(WS-IDX) = \n                   WS-INP-ROW-DATA(WS-DUP-COUNT))\n                   AND WS-IDX NOT = WS-DUP-COUNT\n                   ADD 1 TO WS-INP-ROW-COUNT(WS-IDX)\n                   MOVE 'Y' TO WS-INP-PROCESSED(WS-DUP-COUNT)\n               END-IF\n           END-PERFORM.\n       \n       WRITE-OUTPUT-FILE.\n           PERFORM VARYING WS-IDX FROM 1 BY 1\n               UNTIL WS-IDX > WS-ROW-COUNT\n               IF WS-INP-ROW-COUNT(WS-IDX) > 1\n                   MOVE WS-INP-ROW-DATA(WS-IDX)  TO WS-OUT-DATA\n                   MOVE WS-INP-ROW-COUNT(WS-IDX) TO WS-OUT-COUNT\n                   WRITE OUTPUT-RECORD FROM WS-OUTPUT-LINE\n               END-IF\n           END-PERFORM.\n       \n       CLOSE-FILES.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n\n",
      "input_file_names": "task_func28_inp",
      "output_file_names": "task_func28_out",
      "inputs": {
        "task_func28_inp": "Name,Age,City\nAlice,25,Newyork\nBob,30,London\nAlice,25,Newyork\nAlice,25,Newyork\nBob,30,London\nCharlie,35,Paris"
      },
      "outputs": {
        "task_func28_out": "Alice,25,Newyork                                                                :     3\nBob,30,London                                                                   :     2\n"
      }
    },
    {
      "Program_name": "task_func_29",
      "Cobol_Eval": "Write a valid COBOL program that analyzes an input file containing records with a person's name and age, identifies duplicate names, and outputs the number of duplicates found for each age. \n\nThe program should:\n- Follow the standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE divisions)\n- Use proper COBOL formatting conventions for Area A (columns 8-11) and Area B (columns 12-72) \n- Apply standard COBOL indentation, especially in the PROCEDURE DIVISION, to enhance readability\n\nThe program will:  \n- Read records from an input file named \"input.ps\" containing an ID, name, and age for each person\n- Track and count the number of duplicate names found for each age\n- Write an output file \"output.ps\" listing each age and the count of name duplicates for that age\n- Handle empty input files and invalid age values (e.g. negative ages)\n\nFocus on clearly describing the program's purpose and functionality without implementation specifics. Adhere to the provided COBOL structural and formatting requirements to produce a readable, properly organized COBOL program.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. DUPLICATE-AGE-DISTRIBUTION.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 RECORD-ID       PIC X(5).\n           05 PERSON-NAME     PIC X(20).\n           05 PERSON-AGE      PIC 99V99.\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 AGE-OUT        PIC X(3).\n           05 FILLER-SP         PIC X VALUE SPACE.\n           05 COUNT-OUT      PIC X(3).\n           \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05 WS-EOF-FLAG    PIC X VALUE 'N'.\n           05 WS-EMPTY-FLAG  PIC X VALUE 'Y'.\n           \n       01  WS-COUNTERS.\n           05 WS-RECORD-COUNT    PIC 9(5) VALUE 0.\n           05 WS-AGE-COUNT       PIC 9(3) VALUE 0.\n           \n       01  WS-TABLE.\n           05 WS-ENTRIES OCCURS 50 TIMES INDEXED BY I J.\n               10 WS-NAME        PIC X(20).\n               10 WS-AGE         PIC 99.\n               10 WS-DUPLICATE   PIC X VALUE 'N'.\n               10 WS-COUNT       PIC 999 VALUE 0.\n               \n       01  WS-AGE-INT           PIC 999.\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZE-PARA\n           INITIALIZE WS-RECORD-COUNT\n           MOVE 'AGE' TO AGE-OUT\n           MOVE ' '   TO FILLER-SP\n           MOVE 'CNT' TO COUNT-OUT\n           WRITE OUTPUT-RECORD  \n           PERFORM READ-INPUT-PARA UNTIL WS-EOF-FLAG = 'Y'\n           \n  \n           IF WS-EMPTY-FLAG = 'Y'\n               DISPLAY 'Error: Empty dataset'\n               STOP RUN\n           END-IF\n           \n           PERFORM PROCESS-DUPLICATES-PARA\n           PERFORM WRITE-OUTPUT-PARA\n           \n           CLOSE INPUT-FILE OUTPUT-FILE\n           STOP RUN.\n           \n       INITIALIZE-PARA.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n           \n       READ-INPUT-PARA.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF-FLAG\n               NOT AT END\n                   \n                   MOVE 'N' TO WS-EMPTY-FLAG\n                   ADD 1 TO WS-RECORD-COUNT\n                   PERFORM VALIDATE-AND-STORE-PARA\n           END-READ.\n           \n       VALIDATE-AND-STORE-PARA.\n           IF PERSON-AGE < ZERO\n               DISPLAY 'Error: Negative age found'\n               STOP RUN\n           END-IF\n           \n           COMPUTE WS-AGE-INT = FUNCTION INTEGER(PERSON-AGE)\n           \n           MOVE PERSON-NAME TO WS-NAME(WS-RECORD-COUNT)\n           MOVE WS-AGE-INT TO WS-AGE(WS-RECORD-COUNT)\n           display WS-NAME(WS-RECORD-COUNT)\n           display WS-AGE(WS-RECORD-COUNT).\n           \n       PROCESS-DUPLICATES-PARA.\n           display 'rec-count' WS-RECORD-COUNT\n           PERFORM VARYING I FROM 1 BY 1 \n                   UNTIL I = WS-RECORD-COUNT\n               PERFORM VARYING J FROM 1 BY 1 \n                       UNTIL J = WS-RECORD-COUNT\n                    display 'I1:' ws-name(I)\n                     display 'j1:'WS-NAME(J) \n\n                   IF I NOT = J AND \n                      WS-NAME(I) = WS-NAME(J)\n                      MOVE 'Y' TO WS-DUPLICATE(I)\n                      MOVE 'Y' TO WS-DUPLICATE(J)\n                      ADD 1 TO WS-COUNT(WS-AGE(I))\n                      display 'I:' ws-name(I)\n                      display 'j:'WS-NAME(J) \n\n                   END-IF\n                   \n               END-PERFORM\n           END-PERFORM.\n           \n       WRITE-OUTPUT-PARA.\n           PERFORM VARYING I FROM 1 BY 1 \n                   UNTIL I > WS-RECORD-COUNT\n               IF WS-DUPLICATE(I) = 'Y' AND WS-COUNT(WS-AGE(I)) > 0\n                   MOVE WS-AGE(I) TO AGE-OUT\n                   MOVE WS-COUNT(WS-AGE(I)) TO COUNT-OUT\n                   move ' ' to FILLER-SP\n                   WRITE OUTPUT-RECORD\n                   MOVE 0 TO WS-COUNT(WS-AGE(I))\n               END-IF\n           END-PERFORM.           \n       CLEANUP.\n           CLOSE INPUT-FILE\n                 OUTPUT-FILE.\n",
      "input_file_names": "input.ps",
      "output_file_names": "output.ps",
      "inputs": {
        "input.ps": "00001AliceJohnson        25 \n00002BobBuilder          26 \n00003AliceJohnson        25 \n00004JacobBrunos         36\n00005AgelasJames         29\n00006AgelasJames         29\n00007AgelasJames         29\n00008SteffetGary         33.9\n00009SteffetGary         33.9\t\t"
      },
      "outputs": {
        "output.ps": "AGE CNT\n25  002\n29  006\n34  002\n"
      }
    },
    {
      "Program_name": "task_func_30",
      "Cobol_Eval": "Write a valid COBOL program that reads text from an input file named \"input.txt\", counts the frequency of each unique word, and writes the words and their frequencies to an output file named \"output.txt\". \n\nThe program should follow the standard COBOL division structure:\n- IDENTIFICATION DIVISION with PROGRAM-ID and AUTHOR\n- ENVIRONMENT DIVISION to define input and output files \n- DATA DIVISION to define variables, tables, and file record layouts\n- PROCEDURE DIVISION containing the main program logic\n\nAdhere to COBOL coding conventions:\n- Division headers and paragraph names in Area A (columns 8-11) \n- Statements in Area B (columns 12-72)\n- Use consistent indentation, especially in PROCEDURE DIVISION, to improve readability\n\nThe program should:\n1. Open the input file, read it line by line, and break each line into individual words\n2. Build a table to store each unique word and a count of its occurrences \n3. Write each unique word and its final frequency count to the output file\n4. Close the files and stop the program\n\nHandle potential errors with input and output files gracefully. Use descriptive variable and paragraph names to make the code self-documenting.\n\nThe input will be plain text. The output should list each unique word in the input along with the number of times it occurred, one word per line, in the format:\nword - frequency\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. WORD-FREQUENCY-COUNTER.\n       AUTHOR. ASSISTANT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL\n               FILE STATUS IS WS-INPUT-STATUS.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL\n               FILE STATUS IS WS-OUTPUT-STATUS.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 INPUT-TEXT    PIC X(1000).\n\n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 OUTPUT-TEXT   PIC X(1000).\n\n       WORKING-STORAGE SECTION.\n       01  WS-FILE-STATUS.\n           05 WS-INPUT-STATUS  PIC XX.\n           05 WS-OUTPUT-STATUS PIC XX.\n\n       01  WS-WORD-TABLE.\n           05 WS-WORD-ENTRY OCCURS 1000 TIMES\n              INDEXED BY WS-IDX.\n              10 WS-WORD      PIC X(30).\n              10 WS-FREQUENCY PIC 9(5).\n\n\n       01  WS-FINAL-TABLE.\n           05 WS-FINAL-ENTRY OCCURS 1000 TIMES\n              INDEXED BY WS-FIN-IDX.\n              10 WS-FIN-WORD  PIC X(30).\n              10 WS-FIN-FREQ  PIC 9(5).\n\n       01 WS-SORTED-TABLE.\n           05 WS-SORTED-ENTRY  OCCURS 1000 TIMES \n              INDEXED BY WS-SORT-IDX.\n              10 WS-SORT-WORD  PIC X(30).\n              10 WS-SORT-FREQ  PIC 9(5).\n  \n       01  WS-COUNTERS.\n           05 WS-WORD-COUNT    PIC 9(5) VALUE 0.\n           05 WS-UNIQUE-WORDS  PIC 9(5) VALUE 0.\n           05 WS-TOP-TEN-IDX   PIC 9(2) VALUE 1.\n\n       01  WS-TEMP-VARIABLES.\n           05 WS-CURRENT-WORD  PIC X(30).\n           05 WS-FOUND-FLAG    PIC 9    VALUE 0.\n           05 WS-MOVE-FLAG    PIC X    VALUE 'N'.\n           05 WS-I             PIC 9(5).\n           05 WS-J             PIC 9(5).\n           05 WS-IDY             PIC 9(5).\n           05 WS-TEMP-FREQ     PIC 9(5).\n           05 WS-TEMP-WORD     PIC X(30).\n           05 L                 PIC 9(3). \n           05 TEMP-FIN      PIC 9(5).  \n           05 WS-COUNTER      PIC 9(5).\n           05 WS-FLAG-STATUS     PIC X.\n          \n\n       PROCEDURE DIVISION.\n       MAIN-LOGIC.\n           PERFORM INITIALIZE-PROGRAM\n           PERFORM PROCESS-INPUT-FILE\n           PERFORM UPDATE-WORD-COUNT\n      *     PERFORM SORT-WORD-TABLE\n            \n           PERFORM CLEANUP-PROGRAM\n           STOP RUN.\n\n       INITIALIZE-PROGRAM.\n      * Initialize the program and open files\n           INITIALIZE WS-WORD-TABLE\n           INITIALIZE WS-FLAG-STATUS  \n           OPEN INPUT INPUT-FILE\n           IF WS-INPUT-STATUS NOT = \"00\"\n               DISPLAY \"Error opening input file: \" WS-INPUT-STATUS\n               PERFORM CLEANUP-PROGRAM\n               STOP RUN\n           END-IF\n           OPEN OUTPUT OUTPUT-FILE\n           IF WS-OUTPUT-STATUS NOT = \"00\"\n               DISPLAY \"Error opening output file: \" WS-OUTPUT-STATUS\n               PERFORM CLEANUP-PROGRAM\n               STOP RUN\n           END-IF.\n\n       PROCESS-INPUT-FILE.\n      * Read and process input file\n           PERFORM UNTIL WS-INPUT-STATUS NOT = \"00\"\n               READ INPUT-FILE\n                   AT END EXIT PERFORM\n               END-READ\n               PERFORM PROCESS-LINE\n           END-PERFORM.\n\n       PROCESS-LINE.\n      * Process each line and count words\n           initialize L\n            \n           \n           INSPECT FUNCTION REVERSE (INPUT-TEXT) TALLYING L FOR\n           LEADING SPACES\n           \n           COMPUTE L = (LENGTH OF INPUT-TEXT - L ) + 1\n            \n           MOVE SPACES TO WS-CURRENT-WORD\n           PERFORM VARYING WS-I FROM 1 BY 1 \n               UNTIL WS-I > L\n               IF INPUT-TEXT(WS-I:1) <> Spaces\n                   ADD  1 TO WS-J\n                   MOVE INPUT-TEXT(WS-I:1) TO \n                   WS-CURRENT-WORD(WS-J:1)\n                   \n                    \n               ELSE\n                   IF WS-CURRENT-WORD NOT = SPACES\n                        \n                       ADD 1 TO WS-UNIQUE-WORDS\n                       MOVE WS-CURRENT-WORD TO WS-WORD(WS-UNIQUE-WORDS)\n                       MOVE 1 TO WS-FREQUENCY(WS-UNIQUE-WORDS)\n                       INITIALIZE WS-CURRENT-WORD\n                       MOVE 1 TO WS-J\n                   END-IF\n               END-IF\n           END-PERFORM.\n\n       UPDATE-WORD-COUNT.\n      * Update word frequency count\n            \n           INITIALIZE WS-COUNTER\n           MOVE 1 TO WS-FIN-IDX        \n           PERFORM VARYING WS-IDX FROM 1 BY 1 \n               UNTIL WS-IDX > WS-UNIQUE-WORDS\n\n                 \n               INITIALIZE  TEMP-FIN\n               MOVE 'N' TO WS-FLAG-STATUS \n                \n               PERFORM VARYING WS-IDY  FROM 1 BY 1\n                 UNTIL WS-IDY > WS-UNIQUE-WORDS OR\n                  WS-WORD(WS-IDY) = SPACES\n                    \n                    IF WS-WORD(WS-IDX) = WS-WORD(WS-IDY)  \n                    AND WS-IDX <> WS-IDY       \n                      \n                      MOVE 'Y' TO WS-FLAG-STATUS\n                      ADD 1 TO  TEMP-FIN  \n                      \n               END-PERFORM \n               IF WS-FLAG-STATUS = 'Y'\n                  ADD 1 TO TEMP-FIN \n                  MOVE WS-WORD(WS-IDX) TO WS-FIN-WORD(WS-FIN-IDX) \n                   \n                  MOVE TEMP-FIN    TO WS-FIN-FREQ(WS-FIN-IDX)\n                   \n                ELSE   \n                  ADD 1 TO WS-FIN-IDX\n               END-IF\n                                 \n                 \n           END-PERFORM\n           PERFORM VARYING WS-IDX FROM 1 BY 1\n           UNTIL WS-IDX > WS-FIN-IDX\n              MOVE 'N' TO WS-MOVE-FLAG\n              IF WS-FIN-WORD(WS-IDX) > SPACES\n                  \n                 PERFORM VARYING WS-IDY FROM 1 BY 1 \n                 UNTIL  WS-IDY > WS-IDX OR WS-MOVE-FLAG = 'Y'\n                   \n \n                    IF WS-FIN-WORD(WS-IDX) = WS-FIN-WORD(WS-IDY)\n                      IF WS-IDX <> WS-IDY\n                       MOVE 'Y' TO WS-MOVE-FLAG\n                      END-IF\n                    END-IF\n                 END-PERFORM\n              END-IF \n              IF WS-MOVE-FLAG = 'N' and  WS-FIN-WORD(WS-IDX) > SPACES \n                       initialize OUTPUT-TEXT   \n                       MOVE WS-FIN-WORD(WS-IDX) TO WS-SORT-WORD(WS-IDX)\n                       MOVE WS-FIN-FREQ(WS-IDX) TO WS-SORT-FREQ(WS-IDX)\n                       \n                       \n                       STRING WS-SORT-WORD(WS-IDX) DELIMITED BY SIZE\n                        \" - \"                    DELIMITED BY SIZE\n                       WS-SORT-FREQ (WS-IDX) \n                                             DELIMITED BY SIZE\n                      INTO OUTPUT-TEXT\n                     \n                      WRITE OUTPUT-RECORD FROM OUTPUT-TEXT\n                 \n              END-IF \n           END-PERFORM\n             \n            \n           .\n\n \n    \n       CLEANUP-PROGRAM.\n      * Close files and cleanup\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n\n\n\n\n        STOP RUN.\n           \n           \n  \n\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "I am a IT resource working in IT company in Bangalore . Bangalore is a beautiful city."
      },
      "outputs": {
        "output.txt": " IT                            - 00002\n Bangalore                     - 00002\n a                             - 00002\n"
      }
    },
    {
      "Program_name": "task_func_31",
      "Cobol_Eval": "Create a valid COBOL program that reads weather data from an input file named 'weather-input.txt', processes the data to calculate weather statistics, and writes the results to an output file named 'weather-output.txt'. The program should adhere to the standard COBOL division structure (IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION) and follow COBOL formatting conventions for Area A and Area B. Use standard COBOL indentation to improve readability.\n\nThe input file contains records with temperature, humidity, and pressure values. The program should calculate the maximum, minimum, and average temperature from the input data. \n\nIn the output file, write the calculated maximum temperature, minimum temperature, and average temperature, each on a separate line with an appropriate label.\n\nEnsure the program handles file opening, reading input records, processing data, writing output records, and closing files properly within the PROCEDURE DIVISION.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. WEATHER-STATS.\n      \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'weather-input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'weather-output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n      \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n           05 TEMPERATURE     PIC S9(2)V9.\n           05 FILLER          PIC X(5).\n           05 HUMIDITY        PIC 9(2).\n           05 FILLER          PIC X(5).\n           05 PRESSURE        PIC 9(4).\n      \n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD.\n           05 OUTPUT-DESC    PIC X(20).\n           05 OUTPUT-TEMP    PIC 999.9 .\n          \n      \n       WORKING-STORAGE SECTION.\n       01 WS-FLAGS.\n           05 WS-EOF          PIC X VALUE 'N'.\n      \n       01 WS-COUNTERS.\n           05 WS-RECORD-COUNT PIC 9(4) VALUE 0.\n      \n       01 WS-CALCULATIONS.\n           05 WS-MAX-TEMP     PIC S9(3)V9(1) VALUE 000.0.\n           05 WS-MIN-TEMP     PIC S9(3)V9(1) VALUE 999.9.\n           05 WS-TOTAL-TEMP   PIC S9(3)V9(1) VALUE 0.\n           05 WS-AVG-TEMP     PIC S9(2)V9(1).\n      \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-RECORDS UNTIL WS-EOF = 'Y'\n           PERFORM CALCULATE-STATISTICS\n           PERFORM WRITE-OUTPUT\n           PERFORM CLEANUP\n           STOP RUN.\n      \n       INITIALIZATION.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n      \n       PROCESS-RECORDS.\n            \n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   PERFORM PROCESS-TEMPERATURE\n           END-READ.\n      \n       PROCESS-TEMPERATURE.\n            \n           ADD 1 TO WS-RECORD-COUNT\n           ADD TEMPERATURE TO WS-TOTAL-TEMP\n           \n           IF TEMPERATURE > WS-MAX-TEMP\n               MOVE TEMPERATURE TO WS-MAX-TEMP\n           END-IF\n      \n           IF TEMPERATURE < WS-MIN-TEMP\n               MOVE TEMPERATURE TO WS-MIN-TEMP\n           END-IF.\n           \n      \n       CALCULATE-STATISTICS.\n            \n           IF WS-RECORD-COUNT > 0\n               COMPUTE WS-AVG-TEMP = WS-TOTAL-TEMP / WS-RECORD-COUNT\n           END-IF.\n      \n       WRITE-OUTPUT.\n           \n           INITIALIZE output-record\n           display 'ws-max-temp' ws-max-temp\n           MOVE 'MAXIMAM TEMP:' TO OUTPUT-DESC\n           move ws-max-temp to output-temp\n           \n           WRITE OUTPUT-RECORD \n           INITIALIZE output-record \n           MOVE 'MINIMAM TEMP:' TO OUTPUT-DESC\n           move ws-MIN-temp to output-temp\n           WRITE OUTPUT-RECORD \n\n           INITIALIZE output-record \n           MOVE 'AVERGE TEMP:' TO OUTPUT-DESC\n           move ws-AVG-temp to output-temp\n           WRITE OUTPUT-RECORD \n\n           .\n      \n       CLEANUP.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n\n",
      "input_file_names": "weather-input.txt",
      "output_file_names": "weather-output.txt",
      "inputs": {
        "weather-input.txt": "225      60     1012\n182\t 65\t1013\n250\t 58\t1010\n201\t 70\t1011\n193\t 55\t1009\n218\t 63\t1014\n237\t 61\t1013\n243\t 62\t1012\n261\t 68\t1015\n220\t 64\t1011\n197      66\t1010\n188\t 72\t1008\n210\t 59\t1013\n274\t 75\t1012\n293\t 80\t1010\n235\t 67\t1015\n249\t 62\t1011\n202\t 71\t1009\n211\t 64\t1013\n190\t 65\t1010\n223\t 60\t1014\n257\t 62\t1012\n280\t 74\t1007\n234\t 66\t1011\n248\t 63\t1013\n221\t 58\t1010\n209\t 60\t1012\n215\t 59\t1014\n227\t 62\t1011\n194\t 64\t1010"
      },
      "outputs": {
        "weather-output.txt": "MAXIMAM TEMP:       029.3\nMINIMAM TEMP:       018.2\nAVERGE TEMP:        022.5\n"
      }
    },
    {
      "Program_name": "task_func_32",
      "Cobol_Eval": "Create a valid COBOL program that reads vehicle speed data from an input file named 'input.txt', calculates the average speed for each vehicle type, and writes the results to an output file named 'output.txt'. The program should adhere to the standard COBOL division structure (IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION) and follow COBOL formatting conventions for Area A (columns 8-11) and Area B (columns 12-72). Use standard COBOL indentation to improve readability.\n\nThe input file contains records with the vehicle type and speed. The program should accumulate the total speed and count for each vehicle type while reading the file. After processing all records, calculate the average speed for each vehicle type that has at least one entry. Write output records containing the vehicle type and its average speed.\n\nIn the DATA DIVISION, define the necessary file and record structures for input and output, as well as any working storage variables needed for processing. In the PROCEDURE DIVISION, use appropriate COBOL statements to implement the program logic, including opening and closing files, reading input records, updating totals, calculating averages, and writing output records.\n\nEnsure the program is well-structured, readable, and follows COBOL best practices. The goal is to efficiently process the vehicle speed data and generate accurate average speed results for each vehicle type present in the input file.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. VEHICLE-SPEED-REPORT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n           05 IN-VEHICLE-TYPE     PIC X(10).\n           05 FILLER              PIC X(10).\n           05 IN-SPEED            PIC 99V99.\n       \n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD.\n           05 OUT-VEHICLE-TYPE     PIC X(10).\n           05 OUT-DATA             PIC X(10).  \n           05 OUT-AVG-SPEED        PIC 99.99.\n       \n       WORKING-STORAGE SECTION.\n       01 WS-EOF                  PIC X VALUE 'N'.\n       01 WS-COUNTERS.\n           05 CAR-COUNT           PIC 99 VALUE ZERO.\n           05 BUS-COUNT           PIC 99 VALUE ZERO.\n           05 TRUCK-COUNT         PIC 99 VALUE ZERO.\n           05 BIKE-COUNT          PIC 99 VALUE ZERO.\n       \n       01 WS-TOTALS.\n           05 CAR-TOTAL           PIC 999V99 VALUE ZERO.\n           05 BUS-TOTAL           PIC 999V99 VALUE ZERO.\n           05 TRUCK-TOTAL         PIC 999V99 VALUE ZERO.\n           05 BIKE-TOTAL          PIC 999V99 VALUE ZERO.\n       \n       01 WS-AVERAGES.\n           05 CAR-AVG             PIC 99V99 VALUE ZERO.\n           05 BUS-AVG             PIC 99V99 VALUE ZERO.\n           05 TRUCK-AVG           PIC 99V99 VALUE ZERO.\n           05 BIKE-AVG            PIC 99V99 VALUE ZERO.\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM OPEN-FILES\n           PERFORM PROCESS-RECORDS UNTIL WS-EOF = 'Y'\n           PERFORM CALCULATE-AVERAGES\n           PERFORM WRITE-OUTPUT\n           PERFORM CLOSE-FILES\n           STOP RUN.\n       \n       OPEN-FILES.\n           INITIALIZE CAR-TOTAL,BUS-TOTAL,TRUCK-TOTAL,BIKE-TOTAL\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n       \n       PROCESS-RECORDS.\n           READ INPUT-FILE\n               AT END MOVE 'Y' TO WS-EOF\n               NOT AT END PERFORM UPDATE-TOTALS\n           END-READ.\n       \n       UPDATE-TOTALS.\n           EVALUATE IN-VEHICLE-TYPE\n               WHEN 'Car     '\n                   display 'car speed:' IN-SPEED\n                   ADD 1 TO CAR-COUNT\n                   ADD IN-SPEED TO CAR-TOTAL\n               WHEN 'Bus     '\n                   display 'BUS speed:' IN-SPEED\n                   ADD 1 TO BUS-COUNT\n                   ADD IN-SPEED TO BUS-TOTAL\n               WHEN 'Truck   '\n                   display 'Truck speed:' IN-SPEED\n                   ADD 1 TO TRUCK-COUNT\n                   ADD IN-SPEED TO TRUCK-TOTAL\n               WHEN 'Bike    '\n                   display 'Bike speed:' IN-SPEED \n                   ADD 1 TO BIKE-COUNT\n                   ADD IN-SPEED TO BIKE-TOTAL\n           END-EVALUATE.\n       \n       CALCULATE-AVERAGES.\n           DISPLAY 'CAR-TOTAL:' CAR-TOTAL\n           DISPLAY 'BUS-TOTAL:' BUS-TOTAL\n           DISPLAY 'TRUCK-TOTAL:' TRUCK-TOTAL\n           DISPLAY 'BIKE-TOTAL:' BIKE-TOTAL \n           IF CAR-COUNT > 0\n               COMPUTE CAR-AVG = CAR-TOTAL / CAR-COUNT\n           END-IF\n           IF BUS-COUNT > 0\n               COMPUTE BUS-AVG = BUS-TOTAL / BUS-COUNT\n           END-IF\n           IF TRUCK-COUNT > 0\n               COMPUTE TRUCK-AVG = TRUCK-TOTAL / TRUCK-COUNT\n           END-IF\n           IF BIKE-COUNT > 0\n               COMPUTE BIKE-AVG = BIKE-TOTAL / BIKE-COUNT\n           END-IF.\n       \n       WRITE-OUTPUT.\n           IF CAR-COUNT > 0\n               MOVE 'Car     ' TO OUT-VEHICLE-TYPE\n               MOVE CAR-AVG TO OUT-AVG-SPEED\n               MOVE '          ' TO OUT-DATA  \n               WRITE OUTPUT-RECORD\n           END-IF\n           IF BUS-COUNT > 0\n               MOVE 'Bus     ' TO OUT-VEHICLE-TYPE\n               MOVE BUS-AVG TO OUT-AVG-SPEED\n               MOVE '          ' TO OUT-DATA  \n               WRITE OUTPUT-RECORD\n           END-IF\n           IF TRUCK-COUNT > 0\n               MOVE 'Truck   ' TO OUT-VEHICLE-TYPE\n               MOVE TRUCK-AVG TO OUT-AVG-SPEED\n               MOVE '          ' TO OUT-DATA  \n               WRITE OUTPUT-RECORD\n           END-IF\n           IF BIKE-COUNT > 0\n               MOVE 'Bike    ' TO OUT-VEHICLE-TYPE\n               MOVE BIKE-AVG TO OUT-AVG-SPEED\n               MOVE '          ' TO OUT-DATA  \n               WRITE OUTPUT-RECORD\n           END-IF.\n       \n       CLOSE-FILES.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "Car                 355\nBus                 471\nCar                 260\nTruck               307\nBus                 607\nBike                701\nBike                504"
      },
      "outputs": {
        "output.txt": "Car                 30.75\nBus                 53.90\nTruck               30.70\nBike                60.25\n"
      }
    },
    {
      "Program_name": "task_func_33",
      "Cobol_Eval": "Write a COBOL program that merges weather data from two input files ('weather1.txt' and 'weather2.txt') into a single output file ('weather-merged.txt'). The program should adhere to the standard COBOL division structure (IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION) and follow COBOL formatting conventions for Area A and Area B. Use standard COBOL indentation to improve readability.\n\nThe input files contain records with a timestamp, followed by the weather condition at that time. The program should read the records from both input files and write them to the output file, preserving the original format. Include a header record in the output file indicating the structure of the data.\n\nThe program should handle reaching the end of either input file gracefully and continue processing records from the other file until both are exhausted. After processing, it should close the files and display a message indicating successful completion.\n\nFocus on describing the program's functionality and the data it handles, without specifying detailed COBOL syntax or implementation details. The generated COBOL program should achieve the same result as the provided example, based on this high-level description.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. WEATHER-MERGER.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE-1 ASSIGN TO 'weather1.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT INPUT-FILE-2 ASSIGN TO 'weather2.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE ASSIGN TO 'weather-merged.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE-1.\n       01 WEATHER-REC-1.\n           05 TIME-1         PIC X(5).\n           05 FILLER        PIC X(3).\n           05 CONDITION-1   PIC X(10).\n           \n       FD INPUT-FILE-2.\n       01 WEATHER-REC-2.\n           05 TIME-2         PIC X(5).\n           05 FILLER        PIC X(3).\n           05 CONDITION-2   PIC X(10).\n           \n       FD OUTPUT-FILE.\n       01 WEATHER-REC-OUT.\n           05 TIME-OUT      PIC X(5).\n           05 FILLER        PIC X(3) VALUE SPACES.\n           05 COND-OUT      PIC X(10).\n           \n       WORKING-STORAGE SECTION.\n       01 WS-EOF-1          PIC X VALUE 'N'.\n       01 WS-EOF-2          PIC X VALUE 'N'.\n       01 WS-HEADER.\n           05 FILLER        PIC X(4) VALUE 'Time'.\n           05 FILLER        PIC X(4) VALUE SPACES.\n           05 FILLER        PIC X(7) VALUE 'Weather'.\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INIT-PARA\n           PERFORM PROCESS-PARA UNTIL WS-EOF-1 = 'Y' \n                                 AND WS-EOF-2 = 'Y'\n           PERFORM CLOSE-PARA\n           STOP RUN.\n           \n       INIT-PARA.\n           OPEN INPUT INPUT-FILE-1\n           OPEN INPUT INPUT-FILE-2\n           OPEN OUTPUT OUTPUT-FILE\n           WRITE WEATHER-REC-OUT FROM WS-HEADER\n           READ INPUT-FILE-1 \n               AT END MOVE 'Y' TO WS-EOF-1\n           END-READ\n           READ INPUT-FILE-2\n               AT END MOVE 'Y' TO WS-EOF-2\n           END-READ.\n           \n       PROCESS-PARA.\n           IF WS-EOF-1 = 'N'\n               MOVE TIME-1 TO TIME-OUT\n               MOVE CONDITION-1 TO COND-OUT\n               WRITE WEATHER-REC-OUT\n               display 'file 1 :' WEATHER-REC-OUT\n               READ INPUT-FILE-1\n                   AT END MOVE 'Y' TO WS-EOF-1\n               END-READ\n           END-IF\n           \n           IF WS-EOF-2 = 'N'\n               MOVE TIME-2 TO TIME-OUT\n               MOVE CONDITION-2 TO COND-OUT\n               WRITE WEATHER-REC-OUT\n               display 'file 2 :' WEATHER-REC-OUT \n               READ INPUT-FILE-2\n                   AT END MOVE 'Y' TO WS-EOF-2\n               END-READ\n           END-IF.\n           \n       CLOSE-PARA.\n           CLOSE INPUT-FILE-1\n           CLOSE INPUT-FILE-2\n           CLOSE OUTPUT-FILE\n           DISPLAY 'Weather data has been merged successfully.'.\n\n",
      "input_file_names": [
        "weather1.txt",
        "weather2.txt"
      ],
      "output_file_names": "weather-merged.txt",
      "inputs": {
        "weather1.txt": "15:00   Sunny\n16:00   Sunny\n17:00   Cloudy\n18:00   Cloudy\n19:00   Stormy",
        "weather2.txt": "09:00   Sunny\n10:00   Sunny'\n11:00   Cloudy\n12:00   Snowy"
      },
      "outputs": {
        "weather-merged.txt": "Time    Weather\n15:00   Sunny\n09:00   Sunny\n16:00   Sunny\n10:00   Sunny'\n17:00   Cloudy\n11:00   Cloudy\n18:00   Cloudy\n12:00   Snowy\n19:00   Stormy\n"
      }
    },
    {
      "Program_name": "task_func_34",
      "Cobol_Eval": "Write a valid COBOL program that calculates customer bills based on sales data. The program should:\n\n1. Follow the standard COBOL division structure with IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE DIVISIONS. \n\n2. Adhere to COBOL formatting conventions, using Area A for division and paragraph headers and Area B for statements.\n\n3. Use standard COBOL indentation, especially in the PROCEDURE DIVISION, to improve readability.\n\nThe program will:\n- Read a sales tax file ('task_func34_inp1') containing zip codes and tax rates. \n- Read a customer file ('task_func34_inp2') with customer number, unit price, quantity purchased, address, and zip code.\n- Calculate the subtotal (unit price * quantity), then look up the tax rate by the customer's zip code to calculate tax and total amount due.\n- Write a formatted bill file ('task_func34_out1') displaying the customer number, unit price, quantity, calculated sales tax amount, and total amount due.\n\nEnsure the program efficiently reads the input files, performs the tax and total calculations, and generates a properly formatted bill file as output, without any extraneous functionality beyond the core requirements.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. BILLING-PROGRAM.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT SALES-TAX-FILE\n               ASSIGN TO 'task_func34_inp1'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT CUSTOMER-FILE\n               ASSIGN TO 'task_func34_inp2'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT BILL-FILE\n               ASSIGN TO 'task_func34_out1'\n               ORGANIZATION IS LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  SALES-TAX-FILE.\n       01  SALES-TAX-RECORD.\n           05 ST-ZIPCODE      PIC X(5).\n           05 FILLER          PIC X.\n           05 ST-TAX-RATE     PIC V999.\n           05 FILLER          PIC X(71).\n\n       FD  CUSTOMER-FILE.\n       01  CUSTOMER-RECORD.\n           05 CUST-NUMBER     PIC X(5).\n           05 FILLER          PIC X.\n           05 UNIT-PRICE      PIC 9(3)V99.\n           05 FILLER          PIC X.\n           05 QUANTITY        PIC 9(3).\n           05 FILLER          PIC X.\n           05 IN-ADDRESS      PIC X(20).\n           05 FILLER          PIC X.\n           05 CUST-ZIPCODE    PIC X(5).\n           05 FILLER          PIC X(58).\n\n       FD  BILL-FILE\n           LABEL RECORDS ARE OMITTED\n           RECORD CONTAINS 132 CHARACTERS.\n       01  BILL-RECORD       PIC X(132).\n\n       WORKING-STORAGE SECTION.\n       01  WS-EOF-FLAG       PIC X VALUE 'N'.\n       01  WS-TAX-TABLE.\n           05 WS-TAX-ENTRY OCCURS 1000 TIMES\n              INDEXED BY TAX-IDX.\n              10 WS-ZIPCODE  PIC X(5).\n              10 WS-TAX-RATE PIC V999.\n       \n       01  WS-TAX-COUNT      PIC 9(4) VALUE 0.\n       01  WS-FOUND          PIC X VALUE 'N'.\n       01  WS-CALCULATIONS.\n           05 WS-SUBTOTAL    PIC 9(7)V99.\n           05 WS-TAX-AMOUNT  PIC 9(7)V99.\n           05 WS-TOTAL       PIC 9(7)V99.\n       \n       01  WS-HEADER-LINE.\n           05 FILLER           PIC X(18) VALUE SPACES.\n           05 FILLER           PIC X(10) VALUE 'CUSTOMER'.\n           05 FILLER           PIC X(05) VALUE SPACES.\n           05 FILLER           PIC X(12) VALUE 'UNIT PRICE'.\n           05 FILLER           PIC X(8) VALUE SPACES.\n           05 FILLER           PIC X(6) VALUE 'QTY'.\n           05 FILLER           PIC X(10) VALUE SPACES.\n           05 FILLER           PIC X(12) VALUE 'SALES TAX'.\n           05 FILLER           PIC X(12) VALUE SPACES.\n           05 FILLER           PIC X(10) VALUE 'TOTAL'.\n\n       01  WS-BILL-LINE.\n           05 FILLER         PIC X(18) VALUE SPACES.\n           05 OUT-CUST-NO    PIC X(5).\n           05 FILLER         PIC X(10) VALUE SPACES.          \n           05 OUT-UNIT-PRICE PIC 999.99.\n           05 FILLER         PIC X(10) VALUE SPACES.     \n           05 OUT-QUANTITY   PIC ZZ9.\n           05 FILLER         PIC X(10) VALUE SPACES.\n           05 OUT-DET-SALES-TAX\n                             PIC Z(6).99.\n           05 FILLER         PIC X(10)  VALUE SPACES.\n           05 OUT-TOTAL      PIC Z,ZZZ,ZZZ.99.\n           05 FILLER         PIC X(38)  VALUE SPACES.\n\n       PROCEDURE DIVISION.\n       000-MAIN-PARA.\n           PERFORM 100-LOAD-TAX-TABLE\n           PERFORM 200-PROCESS-CUSTOMER-FILE\n           PERFORM 300-PROGRAM-EXIT.\n\n       100-LOAD-TAX-TABLE.\n           OPEN INPUT SALES-TAX-FILE\n           MOVE 'N' TO WS-EOF-FLAG\n           PERFORM UNTIL WS-EOF-FLAG = 'Y'\n               READ SALES-TAX-FILE\n                   AT END MOVE 'Y' TO WS-EOF-FLAG\n                   NOT AT END\n                       ADD 1 TO WS-TAX-COUNT\n                       MOVE ST-ZIPCODE TO \n                            WS-ZIPCODE(WS-TAX-COUNT)\n                       MOVE ST-TAX-RATE TO \n                            WS-TAX-RATE(WS-TAX-COUNT)\n                      \n               END-READ\n           END-PERFORM\n\n           CLOSE SALES-TAX-FILE.\n\n       200-PROCESS-CUSTOMER-FILE.\n           OPEN INPUT CUSTOMER-FILE\n                OUTPUT BILL-FILE\n\n           MOVE 'N' TO WS-EOF-FLAG\n           MOVE WS-HEADER-LINE TO BILL-RECORD\n           WRITE BILL-RECORD\n           PERFORM UNTIL WS-EOF-FLAG = 'Y'\n               READ CUSTOMER-FILE\n                   AT END MOVE 'Y' TO WS-EOF-FLAG\n                   NOT AT END\n                       PERFORM CALCULATE-BILL\n                       PERFORM WRITE-BILL\n               END-READ\n           END-PERFORM\n           CLOSE CUSTOMER-FILE\n                 BILL-FILE.\n\n       CALCULATE-BILL.\n           COMPUTE WS-SUBTOTAL = UNIT-PRICE * QUANTITY\n           MOVE 'N' TO WS-FOUND\n           SET TAX-IDX TO 1\n           SEARCH WS-TAX-ENTRY\n               AT END MOVE 0 TO WS-TAX-RATE(1)\n               WHEN WS-ZIPCODE(TAX-IDX) = CUST-ZIPCODE\n                   MOVE 'Y' TO WS-FOUND\n                   COMPUTE WS-TAX-AMOUNT = \n                          WS-SUBTOTAL * WS-TAX-RATE(TAX-IDX)\n           END-SEARCH\n           IF WS-FOUND = 'N'\n               MOVE 0 TO WS-TAX-AMOUNT\n           END-IF\n           COMPUTE WS-TOTAL = WS-SUBTOTAL + WS-TAX-AMOUNT.\n\n       WRITE-BILL.\n           MOVE CUST-NUMBER   TO OUT-CUST-NO\n           MOVE UNIT-PRICE    TO OUT-UNIT-PRICE\n           MOVE QUANTITY      TO OUT-QUANTITY  \n           MOVE WS-TAX-AMOUNT TO OUT-DET-SALES-TAX         \n           MOVE WS-TOTAL      TO OUT-TOTAL\n           WRITE BILL-RECORD  FROM WS-BILL-LINE\n                 AFTER ADVANCING 2 LINES.\n\n       300-PROGRAM-EXIT.\n           STOP RUN.\n",
      "input_file_names": [
        "task_func34_inp1",
        "task_func34_inp2"
      ],
      "output_file_names": "task_func34_out1",
      "inputs": {
        "task_func34_inp1": "99501,046\n85001,023",
        "task_func34_inp2": "12345,01299,002,XYZ                 ,99501\n67890,05834,004,ABC                 ,85001"
      },
      "outputs": {
        "task_func34_out1": "                  CUSTOMER       UNIT PRICE          QTY             SALES TAX               TOTAL\n\n\n                  12345          012.99            2               1.19                 27.17\n\n                  67890          058.34            4               5.36                238.72\n"
      }
    },
    {
      "Program_name": "task_func_35",
      "Cobol_Eval": "Write a valid COBOL program that updates a master file with transaction data. The program should:\n\n- Follow the standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE divisions) \n- Adhere to COBOL Area A and Area B coding conventions\n- Use standard COBOL indentation, especially in PROCEDURE DIVISION, to improve readability\n\nThe program will read an old master file (task_func35_inp1) and a transaction file (task_func35_inp2). For each record, it should:\n\n- If the account numbers match, add the transaction amount to the master record amount and write the updated record to a new master file (task_func35_out)\n- If only the master record exists, write it to the new master file unchanged  \n- If only the transaction record exists, write a new record with the transaction data to the new master file\n\nAt the end, close all files. The records use the following format:\n\nMaster:  05 account-no PIC X(5), 05 amount PIC 9(4)V99. \nTransaction: 05 account-no PIC X(5), 05 amount PIC 9(4)V99.\nOutput: 05 account-no PIC X(5), 05 amount PIC 9(5)V99.\n\nEnsure the program handles reaching the end of either input file gracefully. The output file should contain the updated master records in account number order.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. MASTER-UPDATE.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OLD-MASTER ASSIGN TO 'task_func35_inp1'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT TRANS-FILE ASSIGN TO 'task_func35_inp2'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT NEW-MASTER ASSIGN TO 'task_func35_out'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  OLD-MASTER.\n       01  OLD-MASTER-REC.\n           05 OLD-ACCT-NO        PIC X(5).\n           05 OLD-IN1-FILL1      PIC X.\n           05 OLD-AMOUNT-DUE     PIC 9(4)V99.   \n           05 FILLER             PIC X(89) VALUE SPACES.\n           \n       FD  TRANS-FILE.\n       01  TRANS-REC.\n           05 TRANS-ACCT-NO      PIC X(5).\n           05 TRANS-IN2-FILL1    PIC X.\n           05 TRANS-AMOUNT       PIC 9(4)V99.\n           05 TRANS-IN2-FILL2    PIC X.\n           05 FILLER             PIC X(89) VALUE SPACES.\n           \n       FD  NEW-MASTER.\n       01  NEW-MASTER-REC        PIC X(100).\n                      \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05 EOF-OLD-MASTER     PIC X VALUE 'N'.\n           05 EOF-TRANS          PIC X VALUE 'N'.\n           \n       01  WS-WORK-AREAS.\n           05 WS-OLD-ACCT        PIC X(5).\n           05 WS-TRANS-ACCT      PIC X(5).\n           05 WS-TEMP-AMOUNT     PIC 9(5)V99.\n       \n       01  WS-OUTPUT-LINE.\n           05 OUT-ACCT-NO          PIC X(5).\n           05 OUT-FILL1            PIC X.\n           05 OUT-AMOUNT-DUE       PIC 9(5)V99.\n           05 OUT-FILLER           PIC X(88) VALUE SPACES.\n\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INIT-PARA\n           PERFORM PROCESS-PARA UNTIL EOF-OLD-MASTER = 'Y' AND \n                                    EOF-TRANS = 'Y'\n           PERFORM CLOSE-PARA\n           STOP RUN.\n           \n       INIT-PARA.\n           OPEN INPUT  OLD-MASTER\n                      TRANS-FILE\n                OUTPUT NEW-MASTER\n           PERFORM READ-OLD-MASTER\n           PERFORM READ-TRANS-FILE.\n           \n       PROCESS-PARA.\n           IF EOF-OLD-MASTER = 'N' AND EOF-TRANS = 'N'\n              INITIALIZE NEW-MASTER-REC\n               IF OLD-ACCT-NO = TRANS-ACCT-NO                \n                   MOVE OLD-ACCT-NO TO OUT-ACCT-NO\n                   MOVE ','         TO OUT-FILL1\n                   COMPUTE WS-TEMP-AMOUNT = OLD-AMOUNT-DUE + \n                                            TRANS-AMOUNT\n                   MOVE WS-TEMP-AMOUNT  TO OUT-AMOUNT-DUE                                  \n                   WRITE NEW-MASTER-REC FROM WS-OUTPUT-LINE\n                   PERFORM READ-OLD-MASTER\n                   PERFORM READ-TRANS-FILE\n               ELSE\n                   IF OLD-ACCT-NO < TRANS-ACCT-NO\n                       MOVE OLD-MASTER-REC TO WS-OUTPUT-LINE\n                       WRITE NEW-MASTER-REC FROM WS-OUTPUT-LINE\n                       PERFORM READ-OLD-MASTER\n                   ELSE\n                       MOVE TRANS-ACCT-NO TO OUT-ACCT-NO\n                       MOVE TRANS-AMOUNT  TO OUT-AMOUNT-DUE\n                       WRITE NEW-MASTER-REC FROM WS-OUTPUT-LINE\n                       PERFORM READ-TRANS-FILE\n                   END-IF\n               END-IF\n           ELSE\n               IF EOF-OLD-MASTER = 'N'\n                   MOVE OLD-MASTER-REC TO WS-OUTPUT-LINE\n                   WRITE NEW-MASTER-REC\n                   PERFORM READ-OLD-MASTER\n               END-IF\n               IF EOF-TRANS = 'N'\n                   MOVE TRANS-ACCT-NO TO OUT-ACCT-NO\n                   MOVE TRANS-AMOUNT  TO OUT-AMOUNT-DUE\n                   WRITE NEW-MASTER-REC FROM WS-OUTPUT-LINE\n                   PERFORM READ-TRANS-FILE\n               END-IF\n           END-IF.\n           \n       READ-OLD-MASTER.\n           READ OLD-MASTER\n               AT END MOVE 'Y' TO EOF-OLD-MASTER.\n               \n       READ-TRANS-FILE.\n           READ TRANS-FILE\n               AT END MOVE 'Y' TO EOF-TRANS.\n               \n       CLOSE-PARA.\n           CLOSE OLD-MASTER\n                 TRANS-FILE\n                 NEW-MASTER.\n\n",
      "input_file_names": [
        "task_func35_inp1",
        "task_func35_inp2"
      ],
      "output_file_names": "task_func35_out",
      "inputs": {
        "task_func35_inp1": "11111,009967\n22222,007666\n44444,076566",
        "task_func35_inp2": "11111,009899\n22222,087778\n33333,092828\n44444,092828"
      },
      "outputs": {
        "task_func35_out": "11111,0019866\n22222,0095444\n33333,0092828\n44444,0169394\n"
      }
    },
    {
      "Program_name": "task_func_36",
      "Cobol_Eval": "Write a COBOL program that calculates the mean and median of a set of numbers read from an input file named \"input.txt\". The program should output the calculated mean and median values to an output file named \"output.txt\".\n\nEnsure the generated COBOL program adheres to the following requirements:\n\n1. The program must be a valid COBOL program.\n2. Use the standard COBOL division structure: IDENTIFICATION DIVISION, DATA DIVISION (including FILE SECTION and WORKING-STORAGE SECTION), and PROCEDURE DIVISION. \n3. Follow COBOL coding conventions for Area A (columns 8-11 for division headers and paragraph names) and Area B (columns 12-72 for statements).\n4. Apply standard COBOL indentation to enhance readability, especially within the PROCEDURE DIVISION.\n\nThe program should read numbers from the input file, store them in memory, perform the necessary calculations to determine the mean and median values, sort the numbers if required for the median calculation, and write the results to the output file. Handle end-of-file conditions and close files after processing.\n\nFocus on clearly describing the program's functionality and data handling without providing detailed implementation instructions or COBOL syntax specifics beyond the basic structural and formatting requirements outlined above. The LLM should determine the most appropriate algorithms and COBOL statements to achieve the desired outcome based on this high-level description.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. MEAN-MEDIAN-CALC.\n      \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO \"input.txt\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO \"output.txt\"\n               ORGANIZATION IS LINE SEQUENTIAL.\n      \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05  NUMBER-IN    PIC 9(5).\n      \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD   PIC X(80).\n      \n       WORKING-STORAGE SECTION.\n       01  WS-FLAGS.\n           05  EOF-FLAG    PIC X VALUE 'N'.\n      \n       01  WS-COUNTERS.\n           05  NUMBER-COUNT    PIC 9(5) VALUE 0.\n      \n       01  WS-CALCULATIONS.\n           05  TOTAL-SUM      PIC 9(10)  VALUE 0.\n           05  MEAN-VALUE     PIC 9(5)   VALUE 0.\n           05  MEDIAN-VALUE   PIC 9(5)   VALUE 0.\n      \n       01  WS-ARRAY.\n           05  NUMBER-TABLE   PIC 9(5)V99 OCCURS 1000 TIMES\n                             INDEXED BY IDX1, IDX2.\n      \n       01  WS-OUTPUT-LINES.\n           05  MEAN-LINE      PIC X(80).\n           05  MEDIAN-LINE    PIC X(80).\n      \n       01  WS-TEMP           PIC 9(5)V99.\n      \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM READ-AND-STORE-NUMBERS\n           PERFORM CALCULATE-MEAN\n           PERFORM SORT-NUMBERS\n           PERFORM CALCULATE-MEDIAN\n           PERFORM WRITE-RESULTS\n           PERFORM CLEANUP\n           STOP RUN.\n      \n       INITIALIZATION.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n      \n       READ-AND-STORE-NUMBERS.\n           PERFORM UNTIL EOF-FLAG = 'Y'\n               READ INPUT-FILE\n                   AT END\n                       MOVE 'Y' TO EOF-FLAG\n                   NOT AT END\n                       ADD 1 TO NUMBER-COUNT\n                       display 'number-in:' number-in\n                       MOVE NUMBER-IN TO NUMBER-TABLE(NUMBER-COUNT)\n                       ADD NUMBER-IN TO TOTAL-SUM\n               END-READ\n           END-PERFORM.\n      \n       CALCULATE-MEAN.\n           COMPUTE MEAN-VALUE = TOTAL-SUM / (NUMBER-COUNT - 1)\n           display 'total sum:' total-sum\n           display 'number-count:' number-count\n           display 'mean:' mean-value\n           MOVE SPACES TO MEAN-LINE\n           STRING \"Mean = \" MEAN-VALUE\n               DELIMITED BY SIZE INTO MEAN-LINE.\n      \n       SORT-NUMBERS.\n           PERFORM VARYING IDX1 FROM 1 BY 1 \n               UNTIL IDX1 > NUMBER-COUNT - 1\n               PERFORM VARYING IDX2 FROM IDX1 BY 1 \n                   UNTIL IDX2 > NUMBER-COUNT\n                   IF NUMBER-TABLE(IDX1) > NUMBER-TABLE(IDX2)\n                       MOVE NUMBER-TABLE(IDX1) TO WS-TEMP\n                       MOVE NUMBER-TABLE(IDX2) TO NUMBER-TABLE(IDX1)\n                       MOVE WS-TEMP TO NUMBER-TABLE(IDX2)\n                   END-IF\n               END-PERFORM\n           END-PERFORM.\n      \n       CALCULATE-MEDIAN.\n           IF FUNCTION MOD(NUMBER-COUNT 2) = 0\n             COMPUTE MEDIAN-VALUE = (NUMBER-TABLE((NUMBER-COUNT - 1)) / 2) +\n                 NUMBER-TABLE(((NUMBER-COUNT - 1) / 2) + 1)) / 2\n           ELSE\n             COMPUTE MEDIAN-VALUE = \n                 NUMBER-TABLE((NUMBER-COUNT) / 2)\n           END-IF\n           display 'median val:' median-value  \n           MOVE SPACES TO MEDIAN-LINE\n           STRING \"Median = \" MEDIAN-VALUE\n               DELIMITED BY SIZE INTO MEDIAN-LINE.\n      \n       WRITE-RESULTS.\n           WRITE OUTPUT-RECORD FROM MEAN-LINE\n           display 'Mean:' output-record \n           WRITE OUTPUT-RECORD FROM MEDIAN-LINE.\n           display 'Median:' output-record.\n      \n       CLEANUP.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "07488\n00033\n00377\n00234\n00036\n00007\n00373\n09282\n00023\n00078\n00736"
      },
      "outputs": {
        "output.txt": "Mean = 07151\nMedian = 00019\n"
      }
    },
    {
      "Program_name": "task_func_37",
      "Cobol_Eval": "Write a valid COBOL program that reads data records from an input file named 'task_func37_inp', sorts the records in ascending order based on a department field, filters out records with non-positive quantity values, reformats the records, and writes the sorted and filtered records to an output file named 'task_func37_out'. \n\nThe program should follow standard COBOL structure with IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE divisions. Use a SORT statement to perform the record sorting. Adhere to COBOL coding conventions, with division headers and paragraph names in Area A (columns 8-11) and statements in Area B (columns 12-72). Apply consistent indentation, especially in the PROCEDURE DIVISION, to enhance readability.\n\nDefine the necessary file and record descriptions in the FILE and WORKING-STORAGE SECTIONs of the DATA DIVISION. In the PROCEDURE DIVISION, include an INPUT PROCEDURE to read the input file, check quantity values, and release qualifying records to a work file. After sorting, use an OUTPUT PROCEDURE to retrieve the sorted records, reformat them, and write them to the output file.\n\nThroughout the process, handle end-of-file conditions appropriately. The input and output record formats should include part number, quantity, and department fields, along with any necessary filler.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SORT-DEPT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'task_func37_inp'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'task_func37_out'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT WORK-FILE\n               ASSIGN TO 'WORK.TMP'.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 PART-NO-IN      PIC X(05).\n           05 FILL1-IN        PIC X.\n           05 QTY-IN          PIC X(05).\n           05 FILL2-IN        PIC X.\n           05 DEPT-IN         PIC X(02).\n           05 FILLER-IN       PIC X(80).\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 DEPT-OUT        PIC X(02).\n           05 FILL1-OUT       PIC X.\n           05 PART-NO-OUT     PIC X(05).\n           05 FILL2-OUT       PIC X.\n           05 QTY-OUT         PIC X(05).\n           05 FILLER-OUT      PIC X(80).\n           \n       SD  WORK-FILE.\n       01  WORK-RECORD.\n           05 WORK-DEPT       PIC X(02).\n           05 WORK-FILL1      PIC X.\n           05 WORK-PART-NO    PIC X(05).\n           05 WORK-FILL2      PIC X.\n           05 WORK-QTY        PIC X(05).\n           05 WORK-FILLER     PIC X(80).\n           \n       WORKING-STORAGE SECTION.\n       01  WS-EOF-FLAG        PIC X VALUE 'N'.\n       01  WS-QTY-NUM         PIC 9(05).\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           SORT WORK-FILE\n               ON ASCENDING KEY WORK-DEPT\n               INPUT  PROCEDURE  INPUT-PROCEDURE\n               OUTPUT PROCEDURE OUTPUT-PROCEDURE\n               .\n           \n           STOP RUN.\n           \n       OUTPUT-PROCEDURE SECTION.\n       OUTPUT-PARA.\n           OPEN OUTPUT OUTPUT-FILE. \n           PERFORM UNTIL WS-EOF-FLAG = 'Y'\n               RETURN WORK-FILE\n                   AT END\n                       MOVE 'Y' TO WS-EOF-FLAG\n                   NOT AT END\n                       MOVE WORK-DEPT    TO DEPT-OUT\n                       MOVE WORK-FILL1   TO FILL1-OUT                      \n                       MOVE WORK-PART-NO TO PART-NO-OUT\n                       MOVE WORK-FILL2   TO FILL2-OUT\n                       MOVE WORK-QTY     TO QTY-OUT\n                       MOVE SPACES       TO FILLER-OUT\n                       WRITE OUTPUT-RECORD \n               END-RETURN\n           END-PERFORM\n           CLOSE OUTPUT-FILE.\n\n       INPUT-PROCEDURE SECTION.\n       INPUT-PARA.\n           OPEN INPUT INPUT-FILE\n           PERFORM UNTIL WS-EOF-FLAG = 'Y'\n               READ INPUT-FILE\n                   AT END\n                       MOVE 'Y' TO WS-EOF-FLAG\n                   NOT AT END\n                       MOVE QTY-IN TO WS-QTY-NUM\n                       IF WS-QTY-NUM > 0\n                           MOVE DEPT-IN    TO WORK-DEPT\n                           MOVE FILL1-IN   TO WORK-FILL1\n                           MOVE PART-NO-IN TO WORK-PART-NO\n                           MOVE FILL2-IN   TO WORK-FILL2\n                           MOVE QTY-IN     TO WORK-QTY\n                           MOVE FILLER-IN  TO WORK-FILLER\n                           RELEASE WORK-RECORD\n                       END-IF\n               END-READ\n           END-PERFORM\n              MOVE 'N' TO WS-EOF-FLAG\n           CLOSE INPUT-FILE.\n\n\n",
      "input_file_names": "task_func37_inp",
      "output_file_names": "task_func37_out",
      "inputs": {
        "task_func37_inp": "12345,00000,02\n45789,00023,01\n12456,00018,05\n11111,00018,04"
      },
      "outputs": {
        "task_func37_out": "01,45789,00023\n04,11111,00018\n05,12456,00018\n"
      }
    },
    {
      "Program_name": "task_func_38",
      "Cobol_Eval": "Write a COBOL program that merges two input files ('task_func38_inp1' and 'task_func38_inp2') into a single output file ('task_func38_out1') while also generating a separate output file ('task_func38_out2') that lists any duplicate transaction numbers and their count.\n\nThe program should:\n1. Be a valid COBOL program, adhering to the standard COBOL division structure (IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION). \n2. Follow COBOL Area A (columns 8-11) and Area B (columns 12-72) conventions for division headers, paragraph names, and statements.\n3. Use standard COBOL indentation to improve readability, especially within the PROCEDURE DIVISION.\n\nThe input files contain records with a 5-character transaction number, a purchase amount with 2 decimal places, and other filler data. The program should merge the records from the input files, sort them by ascending transaction number, and write them to the first output file.\n\nSimultaneously, it should track duplicate transaction numbers and their occurrence count. If a transaction number appears more than once, write a record to the second output file containing the transaction number and the duplicate count.\n\nEnsure the program opens, processes, and closes files correctly, and uses appropriate COBOL syntax for file handling, data manipulation, and program flow control.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. MERGE-TRANS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE1 ASSIGN TO 'task_func38_inp1'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT INPUT-FILE2 ASSIGN TO 'task_func38_inp2'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT MERGE-FILE ASSIGN TO 'MERGEWORK'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE1 ASSIGN TO 'task_func38_out1'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE2 ASSIGN TO 'task_func38_out2'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE1.\n       01 INPUT-REC1.\n           05 TRANS-NO1      PIC X(05).\n           05 AMT-PURCH1     PIC 9(5)V99.\n           05 FILLER         PIC X(68).\n           \n       FD INPUT-FILE2.\n       01 INPUT-REC2.\n           05 TRANS-NO2      PIC X(05).\n           05 AMT-PURCH2     PIC 9(5)V99.\n           05 FILLER         PIC X(68).\n           \n       SD MERGE-FILE.\n       01 MERGE-REC.\n           05 MERGE-TRANS-NO PIC X(05).\n           05 MERGE-AMT      PIC 9(5)V99.\n           05 FILLER         PIC X(68).\n           \n       FD OUTPUT-FILE1.\n       01 OUTPUT-REC1        PIC X(80).          \n           \n       FD OUTPUT-FILE2.\n       01 OUTPUT-REC2        PIC X(80).\n           \n       WORKING-STORAGE SECTION.\n       01 WS-VARS.\n           05 WS-PREV-TRANS  PIC X(05) VALUE SPACES.\n           05 WS-COUNT       PIC 9(03) VALUE ZERO.\n           05 WS-EOF         PIC X(01) VALUE 'N'.\n           \n       01 WS-OUT2-RECORD.         \n           05 WS-OUT2-TRANS-NO   PIC X(05).\n           05 WS-OUT2-FILLER1    PIC X VALUE ','.\n           05 WS-OUT2-COUNT      PIC X(03).\n           05 WS-OUT2-FILLER2    PIC X(71) VALUE SPACES. \n\n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           MERGE MERGE-FILE ON ASCENDING KEY MERGE-TRANS-NO\n               USING INPUT-FILE1\n                     INPUT-FILE2\n               OUTPUT PROCEDURE OUTPUT-PROC.          \n           \n           CLOSE OUTPUT-FILE1\n           CLOSE OUTPUT-FILE2.     \n           STOP RUN.\n           \n        PROCESS-RECORD.      \n          \n           WRITE OUTPUT-REC1 FROM MERGE-REC        \n           \n           IF MERGE-TRANS-NO = WS-PREV-TRANS\n               ADD 1 TO WS-COUNT\n           ELSE\n               PERFORM WRITE-DUP-COUNT\n               MOVE MERGE-TRANS-NO TO WS-PREV-TRANS\n               MOVE 1 TO WS-COUNT\n           END-IF.\n           \n       WRITE-DUP-COUNT.\n           IF WS-COUNT > 1\n               MOVE WS-PREV-TRANS TO WS-OUT2-TRANS-NO\n               MOVE WS-COUNT      TO WS-OUT2-COUNT\n               WRITE OUTPUT-REC2 FROM WS-OUT2-RECORD\n           END-IF.\n\n       OUTPUT-PROC SECTION.\n       OUTPUT-PARA.\n           OPEN OUTPUT OUTPUT-FILE1\n                       OUTPUT-FILE2\n           \n           PERFORM UNTIL WS-EOF = 'Y'\n               RETURN MERGE-FILE\n                   AT END\n                       MOVE 'Y' TO WS-EOF\n                       PERFORM WRITE-DUP-COUNT\n                   NOT AT END  \n                       IF MERGE-REC > SPACES                     \n                          PERFORM PROCESS-RECORD\n                       END-IF\n               END-RETURN\n           END-PERFORM.   \n       \n      ",
      "input_file_names": [
        "task_func38_inp1",
        "task_func38_inp2"
      ],
      "output_file_names": "task_func38_out1",
      "inputs": {
        "task_func38_inp1": "00001,0100230\n00002,0001805",
        "task_func38_inp2": "00002,0100230\n00003,0145600"
      },
      "outputs": {
        "task_func38_out1": "00001,0100230\n00002,0001805\n00002,0100230\n00003,0145600\n"
      }
    },
    {
      "Program_name": "task_func_39",
      "Cobol_Eval": "Write a valid COBOL program that reads an input file containing employee records, validates the data in each record against a set of business rules, and writes any records with invalid data to an error report file. The program should follow standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE DIVISION), adhere to COBOL Area A and B conventions, and use standard COBOL indentation to improve readability.\n\nThe input file (task_func39_inp1) contains these fields for each employee record:\n- Social Security Number (PIC 9(9)) \n- Employee Name (PIC X(20))\n- Employee Address (PIC X(20))\n- Transaction Code (PIC 9)\n- Annual Salary (PIC 9(5)) \n- Marital Status (PIC X)\n- Job Level (PIC 9)\n- Department (PIC 99)\n\nThe program should validate each record and write the employee name, an error message, and the invalid value to the error report file (task_func39_out1) if any of these conditions are found:\n- Employee Name is blank\n- Employee Address is blank \n- Transaction Code is not between 1-9\n- Annual Salary is not between 15000-87000\n- Marital Status is not M, S, D or W\n- Job Level is not between 1-6\n- Department is not 10, 20 or 30\n\nThe error report should contain a header with the column names, a row of dashes under the header, and then error records formatted with the employee name, error message, and invalid value.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ERROR-LIST-REPORT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'task_func39_inp1'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT ERROR-FILE\n               ASSIGN TO 'task_func39_out1'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n          05 SSN               PIC 9(9).\n          05 INP-FILL1         PIC X.\n          05 EMP-NAME          PIC X(20).\n          05 INP-FILL2         PIC X.\n          05 EMP-ADDRESS       PIC X(20).\n          05 INP-FILL3         PIC X.\n          05 TRANS-CODE        PIC 9.\n          05 INP-FILL4         PIC X.\n          05 ANNUAL-SALARY     PIC 9(5).\n          05 INP-FILL5         PIC X.\n          05 MARITAL-STATUS    PIC X.\n          05 INP-FILL6         PIC X.\n          05 JOB-LEVEL         PIC 9.\n          05 INP-FILL7         PIC X.\n          05 DEPARTMENT        PIC 99.\n          05 INP-FILL8         PIC X.\n          05 FILLER            PIC X(13).\n       \n       FD ERROR-FILE.\n       01 ERROR-RECORD.\n          05 OUT-NAME          PIC X(20).\n          05 ERROR-MESSAGE     PIC X(50).\n          05 ERROR-VALUE       PIC X(30).\n          05 OUT-FILLER        PIC X(32) VALUE SPACES.\n       \n       WORKING-STORAGE SECTION.\n       01 WS-FLAGS.\n          05 EOF-FLAG          PIC X VALUE 'N'.\n             88 WS-EOF            VALUE 'Y'.\n          \n       01 WS-VALID-MARITAL.\n          05 VALID-STATUS     PIC X.\n             88 VALID-MARITAL VALUES ARE 'M', 'S', 'D', 'W'.\n             \n       01 WS-VALID-DEPT.\n          05 VALID-DEPT       PIC 99.\n             88 VALID-DEPARTMENT VALUES ARE 10, 20, 30.\n             \n       01 WS-HEADERS.\n          05 HEADER1          PIC X(132) VALUE \n             'NAME                    ERROR DESCRIPTION                  \n      -     'ERR VALUE'.\n          05 HEADER2          PIC X(132) VALUE ALL '-'.\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INIT-PARA\n           PERFORM PROCESS-PARA UNTIL WS-EOF\n           PERFORM CLOSE-PARA\n           STOP RUN.\n           \n       INIT-PARA.\n           OPEN INPUT INPUT-FILE\n                OUTPUT ERROR-FILE\n           WRITE ERROR-RECORD FROM HEADER1\n           WRITE ERROR-RECORD FROM HEADER2.\n           \n       PROCESS-PARA.\n           READ INPUT-FILE\n               AT END MOVE 'Y' TO EOF-FLAG\n               NOT AT END PERFORM VALIDATE-RECORD\n           END-READ.\n           \n       VALIDATE-RECORD.\n           \n           MOVE SPACES TO OUT-FILLER\n\n           IF EMP-NAME = SPACES\n              MOVE EMP-NAME TO OUT-NAME\n              MOVE 'EMPLOYEE NAME IS BLANK' TO ERROR-MESSAGE\n              MOVE EMP-NAME TO ERROR-VALUE\n              WRITE ERROR-RECORD\n           END-IF.\n           \n           IF EMP-ADDRESS = SPACES\n              MOVE EMP-NAME TO OUT-NAME\n              MOVE 'EMPLOYEE ADDRESS IS BLANK' TO ERROR-MESSAGE\n              MOVE EMP-ADDRESS TO ERROR-VALUE\n              WRITE ERROR-RECORD\n           END-IF.\n           \n           IF TRANS-CODE < 1 OR TRANS-CODE > 9\n              MOVE EMP-NAME TO OUT-NAME\n              MOVE 'TRANS CODE IS INVALID' TO ERROR-MESSAGE\n              MOVE TRANS-CODE TO ERROR-VALUE\n              WRITE ERROR-RECORD\n           END-IF.\n           \n           IF ANNUAL-SALARY < 15000 OR ANNUAL-SALARY > 87000\n              MOVE EMP-NAME TO OUT-NAME\n              MOVE 'SALARY OUT OF RANGE' TO ERROR-MESSAGE\n              MOVE ANNUAL-SALARY TO ERROR-VALUE\n              WRITE ERROR-RECORD\n           END-IF.\n           \n           MOVE MARITAL-STATUS TO VALID-STATUS\n           IF NOT VALID-MARITAL\n              MOVE EMP-NAME TO OUT-NAME\n              MOVE 'MARITAL STATUS IS INVALID' TO ERROR-MESSAGE\n              MOVE MARITAL-STATUS TO ERROR-VALUE\n              WRITE ERROR-RECORD\n           END-IF.\n           \n           IF JOB-LEVEL < 1 OR JOB-LEVEL > 6\n              MOVE EMP-NAME TO OUT-NAME\n              MOVE 'JOB LEVEL IS INVALID' TO ERROR-MESSAGE\n              MOVE JOB-LEVEL TO ERROR-VALUE\n              WRITE ERROR-RECORD\n           END-IF.\n           \n           MOVE DEPARTMENT TO VALID-DEPT\n           IF NOT VALID-DEPARTMENT\n              MOVE EMP-NAME TO OUT-NAME\n              MOVE 'DEPARTMENT IS INVALID' TO ERROR-MESSAGE\n              MOVE DEPARTMENT TO ERROR-VALUE\n              WRITE ERROR-RECORD\n           END-IF.\n           \n       CLOSE-PARA.\n           CLOSE INPUT-FILE\n                 ERROR-FILE.",
      "input_file_names": "task_func39_inp1",
      "output_file_names": "task_func39_out1",
      "inputs": {
        "task_func39_inp1": "080243567,ANT MAN             ,11 MAIN ST          ,0,21000,M,5,20\n070235826,SUBWAYSURFER        ,13 CROSS ST         ,9,43000,R,7,10\n023478911,JUNIORSON           ,53 AVENUE ROAD      ,6,12000,S,6,30\n424724472,STUTON              ,92 PARK STREET      ,8,15000,M,6,35\n"
      },
      "outputs": {
        "task_func39_out1": "NAME                    ERROR DESCRIPTION                 ERR VALUE\n------------------------------------------------------------------------------------------------------------------------------------\nANT MAN             TRANS CODE IS INVALID                             0\nSUBWAYSURFER        MARITAL STATUS IS INVALID                         R\nSUBWAYSURFER        JOB LEVEL IS INVALID                              7\nJUNIORSON           SALARY OUT OF RANGE                               12000\nSTUTON              DEPARTMENT IS INVALID                             35\n"
      }
    },
    {
      "Program_name": "task_func_40",
      "Cobol_Eval": "Write a valid COBOL program that generates random dates between a specified start and end date (inclusive) and writes them to an output file named 'task_func_40_out'. The program should adhere to the standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE DIVISION) and follow COBOL formatting conventions for Area A (columns 8-11) and Area B (columns 12-72). Use standard COBOL indentation, especially in the PROCEDURE DIVISION, to improve readability.\n\nIn the DATA DIVISION, define the necessary data items to store the start date (Jan 1, 2020), end date (Dec 31, 2020), generated random dates, and a seed value for the random number generator. \n\nThe PROCEDURE DIVISION should handle the following:\n\n1. Initialize the program by opening the output file, converting the start and end dates to integers, calculating the range of dates, and seeding the random number generator.\n\n2. Process dates by generating random integers within the calculated range, converting them back to dates, and writing the formatted dates to the output file. Continue this process until all dates in the range have been generated.\n\n3. Clean up by closing the output file before the program terminates.\n\nThe generated dates should be written to the output file in the format 'YYYY-MM-DD'.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. RANDOM-DATE-GENERATOR.\n      \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OUTPUT-FILE ASSIGN TO 'task_func_40_out'\n           ORGANIZATION IS LINE SEQUENTIAL.\n      \n       DATA DIVISION.\n       FILE SECTION.\n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05  OUTPUT-LINE              PIC X(80).\n      \n       WORKING-STORAGE SECTION.\n       01  WS-START-DATE.\n           05  WS-START-YEAR           PIC 9(4) VALUE 2020.\n           05  WS-START-MONTH          PIC 9(2) VALUE 01.\n           05  WS-START-DAY            PIC 9(2) VALUE 01.\n      \n       01  WS-END-DATE.\n           05  WS-END-YEAR             PIC 9(4) VALUE 2020.\n           05  WS-END-MONTH            PIC 9(2) VALUE 12.\n           05  WS-END-DAY              PIC 9(2) VALUE 31.\n      \n       01  WS-RANDOM-DATE.\n           05  WS-RANDOM-YEAR          PIC 9(4).\n           05  WS-RANDOM-MONTH         PIC 9(2).\n           05  WS-RANDOM-DAY           PIC 9(2).\n      \n       01  WS-VARIABLES.\n           05  WS-START-INTEGER        PIC 9(8).\n           05  WS-END-INTEGER          PIC 9(8).\n           05  WS-RANGE                PIC 9(8).\n           05  WS-RANDOM-NUM           PIC 9(8).\n           05  WS-SEED                 PIC 9(4) VALUE 42.\n           05  WS-EOF-FLAG             PIC X    VALUE 'N'.\n           05  WS-DATE-STRING          PIC X(10).\n      \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION\n           PERFORM PROCESS-DATES UNTIL WS-EOF-FLAG = 'Y'\n           PERFORM CLEANUP\n           STOP RUN.\n      \n       INITIALIZATION.\n           OPEN OUTPUT OUTPUT-FILE\n           COMPUTE WS-START-INTEGER = FUNCTION INTEGER-OF-DATE(\n               WS-START-YEAR * 10000 + WS-START-MONTH * 100 + \n               WS-START-DAY)\n           COMPUTE WS-END-INTEGER = FUNCTION INTEGER-OF-DATE(\n               WS-END-YEAR * 10000 + WS-END-MONTH * 100 + \n               WS-END-DAY)\n           COMPUTE WS-RANGE = WS-END-INTEGER - WS-START-INTEGER + 1\n           MOVE FUNCTION RANDOM(WS-SEED) TO WS-RANDOM-NUM.\n      \n       PROCESS-DATES.\n           IF WS-START-INTEGER > WS-END-INTEGER\n               MOVE 'Y' TO WS-EOF-FLAG\n               EXIT PARAGRAPH\n           END-IF\n      \n           COMPUTE WS-RANDOM-NUM = FUNCTION RANDOM * WS-RANGE\n           ADD WS-START-INTEGER TO WS-RANDOM-NUM\n      \n           MOVE FUNCTION DATE-OF-INTEGER(WS-RANDOM-NUM) TO \n               WS-RANDOM-DATE\n      \n           STRING WS-RANDOM-YEAR DELIMITED BY SIZE\n                  '-'\n                  WS-RANDOM-MONTH DELIMITED BY SIZE\n                  '-'\n                  WS-RANDOM-DAY DELIMITED BY SIZE\n               INTO WS-DATE-STRING\n      \n           MOVE WS-DATE-STRING TO OUTPUT-LINE\n           WRITE OUTPUT-RECORD\n                \n           ADD 1 TO WS-START-INTEGER.\n      \n       CLEANUP.\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "",
      "output_file_names": "task_func_40_out",
      "inputs": {},
      "outputs": {
        "task_func_40_out": "2020-12-26\n2020-11-03\n2020-08-07\n2020-02-25\n2020-12-11\n2020-09-13\n2020-06-30\n2020-10-02\n2020-02-04\n2020-07-19\n2020-07-08\n2020-10-14\n2020-03-31\n2020-09-19\n2020-08-31\n2020-05-01\n2020-04-14\n2020-03-31\n2021-01-10\n2020-04-20\n2020-10-10\n2021-01-02\n2020-09-03\n2020-10-13\n2020-12-09\n2020-04-20\n2020-07-29\n2020-11-06\n2020-08-20\n2020-07-05\n2020-11-04\n2020-04-17\n2020-06-04\n2020-03-07\n2020-04-01\n2020-11-18\n2020-12-17\n2020-04-08\n2021-01-13\n2020-08-20\n2020-10-03\n2021-01-17\n2021-01-20\n2021-01-03\n2020-03-01\n2020-08-21\n2021-02-10\n2020-11-16\n2020-04-15\n2020-11-29\n2020-06-21\n2020-07-30\n2020-12-20\n2020-06-15\n2020-08-28\n2020-08-07\n2020-11-10\n2020-08-18\n2020-09-09\n2020-06-27\n2020-03-07\n2020-03-13\n2021-02-13\n2020-11-22\n2020-10-28\n2020-04-22\n2020-05-05\n2020-09-13\n2020-09-21\n2020-05-10\n2020-04-01\n2020-06-20\n2020-04-23\n2020-10-26\n2020-12-06\n2020-12-15\n2020-03-23\n2020-06-25\n2021-03-13\n2021-03-01\n2020-11-28\n2020-11-15\n2020-06-02\n2020-09-11\n2020-04-02\n2020-08-24\n2020-09-09\n2020-12-02\n2020-03-29\n2020-05-21\n2020-07-07\n2021-01-22\n2020-11-25\n2021-02-26\n2020-05-09\n2021-01-01\n2020-05-14\n2020-10-17\n2021-03-22\n2020-05-11\n2020-12-05\n2020-05-07\n2020-11-22\n2020-12-04\n2020-12-20\n2021-03-29\n2020-09-23\n2020-12-23\n2020-06-14\n2021-01-21\n2020-10-25\n2020-12-20\n2020-07-26\n2020-11-01\n2020-06-11\n2020-06-09\n2020-08-14\n2020-10-06\n2020-09-03\n2020-12-15\n2020-08-03\n2020-06-20\n2020-05-14\n2021-03-25\n2020-08-22\n2020-08-03\n2020-09-06\n2020-06-12\n2020-11-23\n2020-11-22\n2021-02-03\n2020-10-01\n2020-10-08\n2020-08-12\n2020-12-11\n2020-06-10\n2020-08-02\n2020-08-15\n2021-04-04\n2020-11-06\n2021-04-22\n2020-10-17\n2020-08-24\n2020-06-09\n2020-10-14\n2021-05-25\n2021-01-22\n2021-03-14\n2020-10-18\n2020-12-25\n2020-06-05\n2020-08-14\n2020-11-09\n2020-12-13\n2020-09-03\n2020-08-08\n2021-04-06\n2020-08-08\n2021-05-21\n2020-10-19\n2020-08-12\n2020-09-23\n2020-12-03\n2021-02-28\n2020-07-24\n2020-12-17\n2020-11-12\n2020-08-14\n2020-06-24\n2021-05-05\n2020-11-10\n2020-06-30\n2020-07-16\n2020-12-07\n2021-01-28\n2021-03-18\n2021-02-02\n2020-12-18\n2020-10-30\n2021-05-03\n2020-09-12\n2021-01-11\n2020-07-26\n2020-10-14\n2021-03-05\n2021-03-09\n2021-06-05\n2021-01-14\n2021-07-07\n2020-09-24\n2020-09-11\n2021-01-30\n2021-05-28\n2020-12-06\n2021-05-28\n2020-11-11\n2020-08-25\n2020-09-02\n2021-02-21\n2021-02-24\n2021-03-01\n2020-12-20\n2020-11-05\n2020-08-27\n2021-07-12\n2020-10-26\n2021-06-19\n2021-03-10\n2021-05-11\n2021-03-31\n2021-06-30\n2020-08-18\n2021-04-05\n2020-12-17\n2021-03-13\n2021-02-14\n2020-12-09\n2021-05-04\n2021-04-01\n2020-09-28\n2021-02-26\n2020-09-22\n2020-08-16\n2020-09-21\n2021-03-31\n2020-10-28\n2021-06-14\n2021-01-08\n2020-09-16\n2020-12-04\n2021-04-28\n2020-10-23\n2020-09-06\n2020-12-05\n2021-07-28\n2020-11-22\n2021-08-13\n2020-12-14\n2021-02-25\n2021-06-02\n2021-01-27\n2020-12-24\n2020-12-18\n2021-08-22\n2020-10-06\n2021-04-02\n2021-01-05\n2021-06-20\n2021-01-14\n2020-10-07\n2020-10-23\n2021-02-16\n2021-01-25\n2021-08-03\n2021-05-17\n2020-10-09\n2021-06-10\n2021-06-30\n2020-12-07\n2020-11-05\n2021-04-27\n2020-10-08\n2021-03-31\n2021-01-27\n2021-08-20\n2021-01-25\n2021-09-15\n2021-07-22\n2021-05-13\n2020-12-16\n2021-07-31\n2021-03-21\n2021-09-07\n2020-10-28\n2021-01-06\n2020-10-08\n2021-05-21\n2020-11-29\n2020-12-02\n2020-11-15\n2021-07-25\n2021-07-16\n2021-03-26\n2020-10-12\n2020-12-14\n2021-08-11\n2021-01-03\n2020-11-19\n2021-08-26\n2021-05-17\n2021-04-07\n2021-01-12\n2021-10-16\n2021-05-13\n2021-03-17\n2021-08-20\n2021-03-24\n2021-07-31\n2020-11-21\n2021-03-13\n2021-07-29\n2021-08-16\n2021-06-27\n2021-02-08\n2021-08-08\n2021-09-03\n2021-10-20\n2021-03-02\n2021-06-21\n2021-06-30\n2020-11-16\n2021-09-15\n2021-06-28\n2021-03-17\n2021-05-23\n2021-06-11\n2020-11-30\n2021-09-14\n2021-01-02\n2021-05-19\n2021-01-11\n2021-09-20\n2021-06-10\n2021-02-18\n2021-07-06\n2021-03-03\n2021-09-24\n2021-03-22\n2021-06-17\n2021-11-21\n2021-10-25\n2020-12-13\n2021-10-30\n2020-12-11\n2020-12-17\n2021-02-09\n2021-06-28\n2021-07-13\n2021-08-24\n2021-03-09\n2021-01-13\n2021-06-12\n2021-04-20\n2021-11-02\n2021-09-29\n2021-06-25\n2021-06-18\n2021-01-27\n2021-09-05\n2021-04-20\n2021-01-17\n2021-12-14\n2021-05-14\n2021-05-12\n2021-05-23\n2021-11-04\n2021-12-03\n2021-08-11\n2021-12-06\n2021-02-19\n2021-03-29\n2021-11-13\n2021-04-21\n2021-09-16\n2021-02-19\n2021-04-02\n"
      }
    },
    {
      "Program_name": "task_func_43",
      "Cobol_Eval": "Write a valid COBOL program that reads a file named 'input.txt' containing numbers, determines which numbers are prime, and writes the prime numbers to an output file named 'output.txt'. \n\nThe program should have an IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, and PROCEDURE DIVISION, adhering to standard COBOL structure. Use appropriate indentation, especially in the PROCEDURE DIVISION, with division headers and paragraph names in Area A (columns 8-11) and statements in Area B (columns 12-72).\n\nIn the ENVIRONMENT DIVISION, define SELECT statements for the input and output files. \n\nIn the DATA DIVISION, define the file and record formats for the input and output files in the FILE SECTION. Define any necessary working storage variables in the WORKING-STORAGE SECTION.\n\nIn the PROCEDURE DIVISION, include paragraphs to open input/output files, read the input file, check each number for primality, write prime numbers to the output file, and close files when done. The program should handle end-of-file conditions gracefully.\n\nFocus on creating a well-structured COBOL program that achieves the desired functionality of identifying and outputting prime numbers from an input file. Choose appropriate data types and an efficient algorithm for primality testing.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. PRIME-NUMBERS.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'input.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.txt'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 INPUT-NUMBER    PIC 9(5).\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 OUTPUT-NUMBER   PIC 9(5).\n           \n       WORKING-STORAGE SECTION.\n       01  WS-VARIABLES.\n           05 WS-NUMBER       PIC 9(5).\n           05 WS-DIVISOR      PIC 9(5).\n           05 WS-QUOTIENT     PIC 9(5). \n           05 WS-REMAINDER    PIC 9(5).\n           05 WS-PRIME-FLAG   PIC 9(1).\n           05 WS-EOF          PIC X(1).\n           \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM OPEN-FILES\n           PERFORM PROCESS-FILE UNTIL WS-EOF = 'Y'\n           PERFORM CLOSE-FILES\n           STOP RUN.\n           \n       OPEN-FILES.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n           \n       CLOSE-FILES.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n           \n       PROCESS-FILE.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   PERFORM CHECK-PRIME\n           END-READ.\n           \n       CHECK-PRIME.\n           MOVE 1 TO WS-PRIME-FLAG\n           MOVE INPUT-NUMBER TO WS-NUMBER\n           \n           IF WS-NUMBER <= 1\n               MOVE 0 TO WS-PRIME-FLAG\n           END-IF\n           \n           IF WS-NUMBER = 2\n               MOVE 1 TO WS-PRIME-FLAG\n           END-IF\n           \n           PERFORM VARYING WS-DIVISOR FROM 2 BY 1\n               UNTIL WS-DIVISOR >= WS-NUMBER\n               OR WS-PRIME-FLAG = 0\n                \n               DIVIDE WS-NUMBER BY WS-DIVISOR\n                   GIVING WS-QUOTIENT\n                   REMAINDER WS-REMAINDER\n                \n               IF WS-REMAINDER = 0\n                   MOVE 0 TO WS-PRIME-FLAG\n               END-IF\n           END-PERFORM\n            \n           IF WS-PRIME-FLAG = 1\n               MOVE WS-NUMBER TO OUTPUT-NUMBER\n                \n               WRITE OUTPUT-RECORD FROM OUTPUT-NUMBER\n           END-IF.\n",
      "input_file_names": "input.txt",
      "output_file_names": "output.txt",
      "inputs": {
        "input.txt": "00001\n00004\n00003\n00006\n00008\n00023\n00034\n00036\n00043\n00067\n00056"
      },
      "outputs": {
        "output.txt": "00003\n00023\n00043\n00067\n"
      }
    },
    {
      "Program_name": "task_func_44",
      "Cobol_Eval": "Write a COBOL program that analyzes an input article file ('article.ps') and generates an output file ('output.ps') containing unique words from the article along with their frequencies. The program should also write log messages to a separate log file ('logfile.ps').\n\nThe program should adhere to the following COBOL-specific requirements:\n1. Use the standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, and PROCEDURE DIVISION). \n2. Follow COBOL coding conventions for Area A (columns 8-11) and Area B (columns 12-72).\n3. Apply proper COBOL indentation, especially in the PROCEDURE DIVISION, to enhance readability.\n4. Declare necessary variables, tables, and file definitions in the appropriate sections of the DATA DIVISION.\n\nThe program should perform these high-level steps:\n1. Open the input article file, output frequency file, and log file. \n2. Read the article title and content from the input file.\n3. Check if the title contains specific keywords. If found, process the article content.\n4. Remove punctuation from the content and count the frequency of each unique word.\n5. Write the unique words and their frequencies to the output file.\n6. Write informative log messages to the log file to track program progress.\n7. Close all files and stop the program.\n\nEnsure the program is a compilable COBOL program that efficiently processes the input article file and generates the word frequency output file and log file as described.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ARTICLE-ANALYZER.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT ARTICLE-FILE\n               ASSIGN TO 'article.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'output.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT LOG-FILE\n               ASSIGN TO 'logfile.ps'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  ARTICLE-FILE.\n       01  ARTICLE-RECORD.\n           05 ARTICLE-TITLE    PIC X(50).\n           05 ARTICLE-CONTENT  PIC X(100).\n           \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 WORD-OUT        PIC X(20).\n           05 WORD-COUNT      PIC 9(4).\n           \n       FD  LOG-FILE.\n       01  LOG-RECORD         PIC X(100).\n       \n       WORKING-STORAGE SECTION.\n       01  WS-FILE-STATUS     PIC 9(2).\n       01  WS-EOF-FLAG        PIC X VALUE 'N'.\n           88 WS-EOF          VALUE 'Y'.\n           \n       01  WS-KEYWORDS.\n           05 WS-LIKE-COUNT   PIC 9(2) VALUE 0.\n           05 WS-WHAT-COUNT   PIC 9(2) VALUE 0.\n           \n      \n\n       01  WS-WORDS-TABLE.\n           05 WS-WORD-ENTRY OCCURS 50 TIMES.\n              10 WS-STORED-WORD  PIC X(20).\n              10 WS-WORD-COUNT   PIC 9(4).\n           \n       01  WS-INDEXES.\n           05 WS-WORD-IDX     PIC 9(3) VALUE 1.\n           05 WS-TBL-IDX      PIC 9(3).\n           \n      \n       01  WS-TEMP-TITLE      PIC X(50).\n\n              \n       01  WS-COUNTERS.\n            \n           05 WS-TOTAL-WORDS PIC 9(3) VALUE 0.\n           \n       01  WS-TEMP-VARS.\n           05 WS-WORD   PIC X(20).\n           05 WS-TEMP-CONTENT PIC X(100).\n           \n       01  WS-LOG-MSG        PIC X(100).\n       01  WS-BUFFERS.\n          05  WS-TEMP-WORD          PIC X(20).\n          05  WS-INDEX              PIC 9(2) VALUE 1.\n          05  WS-I                  PIC 9(2) VALUE 1.\n          05  WS-J                  PIC 9(2) VALUE 1.\n\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION-PARA\n           PERFORM PROCESS-ARTICLES UNTIL WS-EOF  \n           PERFORM WRITE-OUTPUT\n           PERFORM CLEANUP-PARA\n           STOP RUN.\n           \n       INITIALIZATION-PARA.\n           \n           INITIALIZE WS-FILE-STATUS\n           OPEN OUTPUT LOG-FILE\n            \n\n           OPEN INPUT ARTICLE-FILE\n           \n           IF WS-FILE-STATUS NOT = \"00\"\n              MOVE \"Error opening files1\" TO WS-LOG-MSG\n              PERFORM WRITE-LOG\n              DISPLAY \"File open error:\" WS-FILE-STATUS\n              STOP RUN\n           END-IF\n\n          OPEN OUTPUT OUTPUT-FILE\n          INITIALIZE WS-FILE-STATUS\n           \n           IF WS-FILE-STATUS NOT = \"00\"\n              MOVE \"Error opening files2\" TO WS-LOG-MSG\n              PERFORM WRITE-LOG\n              DISPLAY \"File open error\"\n              STOP RUN\n           END-IF\n           \n           MOVE \"Starting program initialization\" TO WS-LOG-MSG\n           PERFORM WRITE-LOG\n           \n           MOVE \"Initialization complete\" TO WS-LOG-MSG\n           PERFORM WRITE-LOG.\n           \n       PROCESS-ARTICLES.\n           READ ARTICLE-FILE\n               AT END SET WS-EOF TO TRUE\n               NOT AT END\n                   MOVE \"Processing article\" TO WS-LOG-MSG\n                   PERFORM WRITE-LOG\n                   PERFORM PROCESS-ARTICLE\n           END-READ.\n           \n       PROCESS-ARTICLE.\n           INSPECT ARTICLE-TITLE TALLYING \n               WS-LIKE-COUNT FOR ALL   'LIKE' 'like' 'Like'\n               WS-WHAT-COUNT FOR ALL 'WHAT' 'what' 'What'\n           \n           IF WS-LIKE-COUNT > 0 OR WS-WHAT-COUNT > 0\n               MOVE \"Found keyword match in title\" TO WS-LOG-MSG\n               PERFORM WRITE-LOG\n               PERFORM PROCESS-CONTENT\n           END-IF.\n           \n       PROCESS-CONTENT.\n           MOVE ARTICLE-CONTENT TO WS-TEMP-CONTENT\n           display \"ws-temp-content:\" ws-temp-content\n           PERFORM REMOVE-PUNCTUATION\n           \n           MOVE \"Processing content words\" TO WS-LOG-MSG\n           PERFORM WRITE-LOG\n           \n           MOVE SPACES TO WS-WORD\n           MOVE 1 TO WS-WORD-IDX\n\n   \n           MOVE 1 TO WS-INDEX\n           MOVE 1 TO WS-I\n           display 'ws-temp-content:' ws-temp-content\n    \n\n           PERFORM UNTIL WS-I > 50\n              \n              \n              IF  WS-TEMP-CONTENT(WS-I:1) = SPACE OR WS-I = 50\n\n                  IF WS-WORD NOT = SPACES\n                      PERFORM  COUNT-WORD\n                      MOVE SPACES TO  WS-WORD  \n                      MOVE 1 TO WS-J\n                  END-IF\n              ELSE\n                  MOVE  WS-TEMP-CONTENT(WS-I:1) TO  WS-WORD(WS-J:1)\n\n                  ADD 1 TO WS-J\n              END-IF\n              ADD 1 TO WS-I\n           END-PERFORM.\n\n           \n       COUNT-WORD.\n           MOVE \"Counting word frequency\" TO WS-LOG-MSG\n           PERFORM WRITE-LOG\n           \n           PERFORM VARYING WS-TBL-IDX FROM 1 BY 1\n               UNTIL WS-TBL-IDX > 50\n               \n               IF WS-STORED-WORD(WS-TBL-IDX) = WS-WORD\n                   ADD 1 TO WS-WORD-COUNT(WS-TBL-IDX)\n                   EXIT PERFORM\n               ELSE\n                   IF WS-STORED-WORD(WS-TBL-IDX) = SPACES\n                       MOVE WS-WORD TO WS-STORED-WORD(WS-TBL-IDX)\n                       display 'word2:' ws-stored-word(ws-tbl-idx)\n                       MOVE 1 TO WS-WORD-COUNT(WS-TBL-IDX)\n                       display 'word count:' ws-word-count(ws-tbl-idx)\n                       EXIT PERFORM\n                   END-IF\n               END-IF\n           END-PERFORM.\n.\n\n           \n       REMOVE-PUNCTUATION.\n           INSPECT WS-TEMP-CONTENT \n               REPLACING ALL \".\" BY SPACE\n                         ALL \",\" BY SPACE\n                         ALL \"!\" BY SPACE\n                 ALL \"?\" BY SPACE.\n           \n       WRITE-OUTPUT.\n           MOVE \"Writing output file\" TO WS-LOG-MSG\n           PERFORM WRITE-LOG\n            \n           PERFORM VARYING WS-WORD-IDX FROM 1 BY 1 \n               UNTIL WS-WORD-IDX > 50\n               MOVE WS-STORED-WORD(WS-WORD-IDX) TO WORD-OUT\n               MOVE WS-WORD-COUNT(WS-WORD-IDX) TO WORD-COUNT\n               WRITE OUTPUT-RECORD\n           END-PERFORM.\n           \n       WRITE-LOG.\n           WRITE LOG-RECORD FROM WS-LOG-MSG.\n           \n       CLEANUP-PARA.\n           MOVE \"Performing cleanup\" TO WS-LOG-MSG\n           PERFORM WRITE-LOG\n           \n           CLOSE ARTICLE-FILE\n           CLOSE OUTPUT-FILE\n           CLOSE LOG-FILE.",
      "input_file_names": [
        "article.ps",
        "temp.ps"
      ],
      "output_file_names": [
        "output.ps",
        "logfile.ps"
      ],
      "inputs": {
        "article.ps": "what an opportunity to convert python like codes to cobol based on the cobol instruction",
        "temp.ps": "team,goals,penalties\nTeam A              005002\nTeam C              002002\nTeam F              001001\n\nTeam B              002000\nTeam D              000003\nTeam E              002001\n"
      },
      "outputs": {
        "output.ps": "o                   0001\ncobol               0002\nbased               0001\non                  0001\nthe                 0001\ninstruction         0001\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n                    0000\n",
        "logfile.ps": "Starting program initialization\nInitialization complete\nProcessing article\nFound keyword match in title\nProcessing content words\nCounting word frequency\nCounting word frequency\nCounting word frequency\nCounting word frequency\nCounting word frequency\nCounting word frequency\nCounting word frequency\nWriting output file\nPerforming cleanup\n"
      }
    },
    {
      "Program_name": "task_func_45",
      "Cobol_Eval": "Write a valid COBOL program that generates a weather report for 5 cities given a UTC date and time. The program should:\n\n- Follow the standard COBOL division structure (IDENTIFICATION, ENVIRONMENT, DATA, PROCEDURE)\n- Use proper COBOL formatting conventions for Area A (columns 8-11) and Area B (columns 12-72) \n- Apply standard COBOL indentation, especially in PROCEDURE DIVISION, for readability\n\nThe program will:\n1. Read a UTC datetime (YYYY MM DD HH MM SS format) from an input file named 'task_func45_inp'  \n2. For each of 5 hardcoded cities (New York, London, Beijing, Tokyo, Sydney), calculate the local datetime by applying the city's UTC offset\n3. Randomly generate a weather condition (Sunny, Cloudy, Rainy, Snowy, Stormy) for each city\n4. Write the city name, local datetime, and weather to an output file named 'task_func45_out'\n\nInclude all necessary data definitions, file handling, and procedural logic to accomplish this. The input file will contain one UTC datetime per record. The output should have one line per city showing the city, local datetime, and weather.\n\nFocus on clearly expressing what the program needs to do rather than providing detailed COBOL syntax or algorithms. Ensure the program compiles and produces the expected output.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. WEATHER-REPORT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'task_func45_inp'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'task_func45_out'\n               ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD INPUT-FILE.\n       01 INPUT-RECORD.\n           03 INPUT-DATETIME.\n              05 INP-YEAR      PIC X(4).\n              05 INP-FIL1      PIC X  VALUE SPACES.\n              05 INP-MONTH     PIC X(2).\n              05 INP-FIL2      PIC X  VALUE SPACES.\n              05 INP-DAY       PIC X(2).\n              05 INP-FIL3      PIC X  VALUE SPACES.\n              05 INP-HOUR      PIC X(2).\n              05 INP-FIL4      PIC X  VALUE SPACES.\n              05 INP-MINUTE    PIC X(2).\n\t      05 INP-FIL5      PIC X  VALUE SPACES.\n              05 INP-SECOND    PIC X(2).\n                \n       FD OUTPUT-FILE.\n       01 OUTPUT-RECORD.\n           05 FILLER           PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       01 WS-EOF               PIC X VALUE 'N'.\n       01 WS-I                 PIC 9(1).\n       01 WS-J                 PIC 9(1).\n       01 WS-RANDOM            PIC 9(4).\n       01 WS-SEED              PIC 9(4) VALUE 42.\n       \n       01 WS-CITIES.\n           05 CITY-DATA OCCURS 5 TIMES.\n               10 CITY-NAME    PIC X(10).\n               10 TIMEZONE     PIC X(20).\n               10 UTC-OFFSET   PIC S9(4).\n       \n       01 WS-WEATHER-CONDITIONS.\n           05 WEATHER OCCURS 5 TIMES PIC X(10).\n       \n       01 WS-UTC-DATETIME.\n           05 UTC-YEAR        PIC 9(4).\n           05 UTC-MONTH       PIC 9(2).\n           05 UTC-DAY         PIC 9(2).\n           05 UTC-HOUR        PIC 9(2).\n           05 UTC-MINUTE      PIC 9(2).\n           05 UTC-SECOND      PIC 9(2).\n       \n       01 WS-LOCAL-DATETIME.\n           05 LOCAL-YEAR      PIC 9(4).\n           05 FILLER          PIC X VALUE '-'.\n           05 LOCAL-MONTH     PIC 9(2).\n           05 FILLER          PIC X VALUE '-'.\n           05 LOCAL-DAY       PIC 9(2).\n           05 FILLER          PIC X VALUE ' '.\n           05 LOCAL-HOUR      PIC 9(2).\n           05 FILLER          PIC X VALUE ':'.\n           05 LOCAL-MINUTE    PIC 9(2).\n           05 FILLER          PIC X VALUE ':'.\n           05 LOCAL-SECOND    PIC 9(2).\n           05 FILLER          PIC X VALUE ' '.\n           05 TIMEZONE-ABBR   PIC X(4).\n       \n       01 WS-OUTPUT-LINE.\n           05 OUT-CITY        PIC X(10).\n           05 FILLER          PIC X(2) VALUE SPACES.\n           05 OUT-DATETIME    PIC X(25).\n           05 FILLER          PIC X(2) VALUE SPACES.\n           05 OUT-WEATHER     PIC X(10).\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZE-DATA\n           PERFORM OPEN-FILES\n           PERFORM PROCESS-WEATHER-REPORT UNTIL WS-EOF = 'Y'\n           PERFORM CLOSE-FILES\n           STOP RUN.\n       \n       INITIALIZE-DATA.\n           MOVE 'New York  ' TO CITY-NAME(1)\n           MOVE 'London    ' TO CITY-NAME(2)\n           MOVE 'Beijing   ' TO CITY-NAME(3)\n           MOVE 'Tokyo     ' TO CITY-NAME(4)\n           MOVE 'Sydney    ' TO CITY-NAME(5)\n           \n           MOVE 'EST'        TO TIMEZONE(1)\n           MOVE 'GMT'        TO TIMEZONE(2)\n           MOVE 'CST'        TO TIMEZONE(3)\n           MOVE 'JST'        TO TIMEZONE(4)\n           MOVE 'AEDT'       TO TIMEZONE(5)\n           \n           MOVE -5           TO UTC-OFFSET(1)\n           MOVE  0           TO UTC-OFFSET(2)\n           MOVE +8           TO UTC-OFFSET(3)\n           MOVE +9           TO UTC-OFFSET(4)\n           MOVE +11          TO UTC-OFFSET(5)\n           \n           MOVE 'Sunny     ' TO WEATHER(1)\n           MOVE 'Cloudy    ' TO WEATHER(2)\n           MOVE 'Rainy     ' TO WEATHER(3)\n           MOVE 'Snowy     ' TO WEATHER(4)\n           MOVE 'Stormy    ' TO WEATHER(5).\n       \n       OPEN-FILES.\n           OPEN INPUT INPUT-FILE           \n           OPEN OUTPUT OUTPUT-FILE.\n       \n       PROCESS-WEATHER-REPORT.\n           INITIALIZE INPUT-RECORD\n           READ INPUT-FILE\n               AT END MOVE 'Y' TO WS-EOF\n           END-READ.\n\n           IF (WS-EOF = 'N' AND INPUT-DATETIME <> 0)\n              DISPLAY INPUT-DATETIME\n              PERFORM GENERATE-REPORT\n           END-IF.\n       \n       GENERATE-REPORT.\n           MOVE INP-YEAR     TO UTC-YEAR\n                                LOCAL-YEAR\n           MOVE INP-MONTH    TO UTC-MONTH \n                                LOCAL-MONTH           \n           MOVE INP-DAY      TO UTC-DAY\n                                LOCAL-DAY     \n           MOVE INP-HOUR     TO UTC-HOUR  \n                                LOCAL-HOUR      \n           MOVE INP-MINUTE   TO UTC-MINUTE  \n                                LOCAL-MINUTE\n           MOVE INP-SECOND   TO UTC-SECOND    \n                                LOCAL-SECOND\n           \n           PERFORM VARYING WS-I FROM 1 BY 1 \n                     UNTIL WS-I > 5\n               PERFORM CALCULATE-LOCAL-TIME\n               PERFORM GENERATE-WEATHER\n               PERFORM WRITE-REPORT-LINE\n           END-PERFORM.\n       \n       CALCULATE-LOCAL-TIME.\n           \n           COMPUTE LOCAL-HOUR = UTC-HOUR + UTC-OFFSET(WS-I)\n           IF LOCAL-HOUR >= 24\n               ADD -24 TO LOCAL-HOUR\n               ADD 1 TO LOCAL-DAY\n           END-IF\n           IF LOCAL-HOUR < 0\n               ADD 24 TO LOCAL-HOUR\n               SUBTRACT 1 FROM LOCAL-DAY\n           END-IF.\n       \n       GENERATE-WEATHER.\n           COMPUTE WS-RANDOM = FUNCTION RANDOM(WS-SEED) * 5 + 1\n           MOVE WEATHER(WS-RANDOM)  TO OUT-WEATHER.\n       \n       WRITE-REPORT-LINE.\n           MOVE CITY-NAME(WS-I)     TO OUT-CITY           \n           MOVE WS-LOCAL-DATETIME   TO OUT-DATETIME\n           WRITE OUTPUT-RECORD FROM WS-OUTPUT-LINE.\n       \n       CLOSE-FILES.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n\n",
      "input_file_names": "task_func45_inp",
      "output_file_names": "task_func45_out",
      "inputs": {
        "task_func45_inp": "2024-12-18 14:12:00"
      },
      "outputs": {
        "task_func45_out": "New York    2024-12-18 09:12:00        Rainy\nLondon      2024-12-18 14:12:00        Rainy\nBeijing     2024-12-18 22:12:00        Rainy\nTokyo       2024-12-18 23:12:00        Rainy\nSydney      2024-12-19 01:12:00        Rainy\n"
      }
    },
    {
      "Program_name": "task_func_47",
      "Cobol_Eval": "Write a COBOL program that reads person names from an input file named 'task_func47_inp', converts certain non-English characters in the names to their English equivalents or removes non-alphabetic characters, and writes the converted names to an output file named 'task_func47_out'. \n\nThe program should follow the standard COBOL division structure with IDENTIFICATION DIVISION, ENVIRONMENT DIVISION, DATA DIVISION, and PROCEDURE DIVISION. Use appropriate COBOL syntax, indentation, and formatting conventions.\n\nIn the ENVIRONMENT DIVISION, define the input and output files as line sequential. \n\nIn the DATA DIVISION, define the file and record structures for the input and output files. Also define any necessary working storage variables.\n\nIn the PROCEDURE DIVISION, include paragraphs to open the files, read and process each input record until end-of-file, and close the files when done. The main processing should convert the input name, replacing certain non-English characters with English equivalents (e.g. '\u00e4' to 'a', '\u00d6' to 'O', '\u00e6' to 'ae', etc.) and removing any remaining non-alphabetic characters except spaces. Write each converted name to the output file.\n\nThe program should be a complete, executable COBOL program that reads the input file, converts the names as described, and writes the results to the output file.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. NAMECONVERT.\n      \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT INPUT-FILE\n               ASSIGN TO 'task_func47_inp'\n               ORGANIZATION IS LINE SEQUENTIAL.\n           SELECT OUTPUT-FILE\n               ASSIGN TO 'task_func47_out'\n               ORGANIZATION IS LINE SEQUENTIAL.\n      \n       DATA DIVISION.\n       FILE SECTION.\n       FD  INPUT-FILE.\n       01  INPUT-RECORD.\n           05 PERSON-NAME    PIC X(30).\n      \n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 CONVERTED-NAME PIC X(30).\n      \n       WORKING-STORAGE SECTION.\n       01  WS-EOF           PIC X VALUE 'N'.\n       01  WS-TEMP-NAME     PIC X(30).\n       01  WS-CHAR-IDX      PIC 99 VALUE 1.\n       01  WS-CURRENT-CHAR  PIC X.\n      \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM OPEN-FILES\n           PERFORM PROCESS-RECORDS UNTIL WS-EOF = 'Y'\n           PERFORM CLOSE-FILES\n           STOP RUN.\n      \n       OPEN-FILES.\n           OPEN INPUT INPUT-FILE\n           OPEN OUTPUT OUTPUT-FILE.\n      \n       PROCESS-RECORDS.\n           READ INPUT-FILE\n               AT END\n                   MOVE 'Y' TO WS-EOF\n               NOT AT END\n                   PERFORM CONVERT-NAME\n                   PERFORM WRITE-OUTPUT\n           END-READ.\n      \n       CONVERT-NAME.\n           MOVE SPACES TO WS-TEMP-NAME\n           MOVE PERSON-NAME TO WS-TEMP-NAME\n           PERFORM VARYING WS-CHAR-IDX FROM 1 BY 1 \n               UNTIL WS-CHAR-IDX > 30\n               MOVE WS-TEMP-NAME(WS-CHAR-IDX:1) TO WS-CURRENT-CHAR\n               EVALUATE WS-CURRENT-CHAR\n                   WHEN '\u00c5' MOVE 'A' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00e1' MOVE 'a' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00e5' MOVE 'a' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00c4' MOVE 'A' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00e4' MOVE 'a' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00d6' MOVE 'O' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00f6' MOVE 'o' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00c6' MOVE 'AE' TO WS-TEMP-NAME(WS-CHAR-IDX:2)\n                   WHEN '\u00e6' MOVE 'ae' TO WS-TEMP-NAME(WS-CHAR-IDX:2)\n                   WHEN '\u00d8' MOVE 'O' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00f8' MOVE 'o' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00c9' MOVE 'E' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN '\u00e9' MOVE 'e' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n\t\t   WHEN '\u00f1' MOVE 'n' TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                   WHEN OTHER\n                       IF WS-CURRENT-CHAR IS NOT ALPHABETIC AND\n                          WS-CURRENT-CHAR NOT = SPACE\n                           MOVE SPACE TO WS-TEMP-NAME(WS-CHAR-IDX:1)\n                       END-IF\n               END-EVALUATE\n           END-PERFORM.\n      \n       WRITE-OUTPUT.\n           MOVE WS-TEMP-NAME TO CONVERTED-NAME\n           WRITE OUTPUT-RECORD.\n      \n       CLOSE-FILES.\n           CLOSE INPUT-FILE\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "task_func47_inp",
      "output_file_names": "task_func47_out",
      "inputs": {
        "task_func47_inp": "T\u00e9a\nV\u00e1qu\u00e9z\nGarci\u00e1\nZ\u00f6e\nEle\u00f1a\n"
      },
      "outputs": {
        "task_func47_out": "Tea\nVaquez\nGarcia\nZoe\nElena\n"
      }
    },
    {
      "Program_name": "task_func_48",
      "Cobol_Eval": "Write a valid COBOL program that generates a student grades report. The program should:\n\n- Follow the standard COBOL division structure with IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION \n- Adhere to COBOL Area A (columns 8-11) and Area B (columns 12-72) conventions for division headers, paragraph names, and statements\n- Use standard COBOL indentation, especially in the PROCEDURE DIVISION, to improve readability\n\nThe program will:\n- Store data for 100 students and their grades across 8 subjects\n- Randomly generate a grade from 1-100 for each student in each subject \n- Calculate each student's average grade across the 8 subjects\n- Calculate the average grade for each subject across all students\n- Write an output report to a file named 'task_func48_out' showing:\n-- A header line listing the 8 subject names\n-- A line for each student showing their name, 8 subject grades, and average grade \n-- A final line showing the average grade for each subject across all students\n\nThe program does not require any input file. Its purpose is to generate random student grades data, perform analysis on the grades to calculate student and subject averages, and output a well-formatted report summarizing this information.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. STUDENT-GRADES-REPORT.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OUTPUT-FILE ASSIGN TO 'task_func48_out'\n           ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD                 PIC X(200).\n       \n       WORKING-STORAGE SECTION.\n       01  WS-CONSTANTS.\n           05 WS-NUM-STUDENTS             PIC 9(3) VALUE 100.\n           05 WS-NUM-SUBJECTS             PIC 9(2) VALUE 08.\n       \n       01  WS-SUBJECTS-TABLE.\n           05 WS-SUBJECT OCCURS 8 TIMES   PIC X(20).\n       \n       01  WS-GRADES-TABLE.\n           05 WS-STUDENT OCCURS 100 TIMES. \n               10 WS-STUDENT-NAME         PIC X(12).                               \n               10 WS-GRADE OCCURS 8 TIMES PIC 999.\n               10 WS-STUDENT-AVG          PIC 999V99.\n       \n       01  WS-SUBJECT-AVERAGES.\n           05 WS-SUBJ-AVG OCCURS 8 TIMES  PIC 999V99.\n       \n       01  WS-COUNTERS.\n           05 WS-STUDENT-CTR              PIC 9(3) VALUE 1.\n           05 WS-SUBJECT-CTR              PIC 9(2) VALUE 1.\n           05 WS-TOTAL                    PIC 9999V99.\n       \n       01  WS-OUTPUT-LINE.\n           05 WS-OUT-STUDENT-NAME         PIC X(12).\n           05 FILLER                      PIC X(2) VALUE SPACES.\n           05 WS-GRADE-OUT OCCURS 8 TIMES.\n               10 WS-GRADE-DISPLAY        PIC ZZ9.\n               10 FILLER                  PIC X(2) VALUE SPACES.\n           05 WS-AVG-DISPLAY              PIC ZZ9.99.\n       \n       01  WS-HEADER-LINE.\n           05 FILLER                      PIC X(10) VALUE SPACES.\n           05 FILLER                      PIC X(2) VALUE SPACES.\n           05 WS-HEADER OCCURS 8 TIMES.\n               10 WS-HEADER-TEXT          PIC X(12).\n           05 FILLER                      PIC X(13) \n               VALUE \"Average Grade\".\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZE-SUBJECTS\n           PERFORM OPEN-FILES\n           PERFORM WRITE-HEADER\n           PERFORM GENERATE-GRADES\n           PERFORM CALCULATE-AVERAGES\n           PERFORM WRITE-REPORT\n           PERFORM WRITE-SUBJECT-AVERAGES\n           PERFORM CLOSE-FILES\n           STOP RUN.\n       \n       INITIALIZE-SUBJECTS.\n\n           MOVE \"Physics\"    TO WS-SUBJECT(01)\n           MOVE \"Math\"       TO WS-SUBJECT(02)\n           MOVE \"Chemistry\"  TO WS-SUBJECT(03)\n           MOVE \"Biology\"    TO WS-SUBJECT(04)\n           MOVE \"English\"    TO WS-SUBJECT(05)\n           MOVE \"History\"    TO WS-SUBJECT(06)\n           MOVE \"Comp Sci\"   TO WS-SUBJECT(07)\n           MOVE \"Geography\"  TO WS-SUBJECT(08).\n       \n       OPEN-FILES.\n\n           OPEN OUTPUT OUTPUT-FILE.\n       \n       WRITE-HEADER.\n\n           PERFORM VARYING WS-SUBJECT-CTR FROM 1 BY 1\n                     UNTIL WS-SUBJECT-CTR > WS-NUM-SUBJECTS\n                   MOVE WS-SUBJECT(WS-SUBJECT-CTR) \n                           TO WS-HEADER-TEXT(WS-SUBJECT-CTR)\n           END-PERFORM\n           MOVE WS-HEADER-LINE TO OUTPUT-RECORD\n           WRITE OUTPUT-RECORD.\n       \n       GENERATE-GRADES.\n\n           PERFORM VARYING WS-STUDENT-CTR FROM 1 BY 1\n                     UNTIL WS-STUDENT-CTR > WS-NUM-STUDENTS\n                MOVE 0 TO WS-TOTAL   \n\t        STRING \"Student_\" WS-STUDENT-CTR\n                   INTO WS-STUDENT-NAME(WS-STUDENT-CTR)\n               PERFORM VARYING WS-SUBJECT-CTR FROM 1 BY 1\n                   UNTIL WS-SUBJECT-CTR > WS-NUM-SUBJECTS\n                   COMPUTE WS-GRADE(WS-STUDENT-CTR,WS-SUBJECT-CTR) =\n                       FUNCTION RANDOM * 100 + 1\n\t\t   ADD WS-GRADE(WS-STUDENT-CTR, WS-SUBJECT-CTR)\n                                              TO WS-TOTAL\n\n               END-PERFORM\n               COMPUTE WS-STUDENT-AVG(WS-STUDENT-CTR) =\n                       WS-TOTAL / WS-NUM-SUBJECTS\n           END-PERFORM.\n       \n       CALCULATE-AVERAGES.\n\n          \n           PERFORM CALC-SUBJECT-AVERAGES.\n       \n            \n       CALC-SUBJECT-AVERAGES.\n\n           PERFORM VARYING WS-SUBJECT-CTR FROM 1 BY 1\n               UNTIL WS-SUBJECT-CTR > WS-NUM-SUBJECTS\n               MOVE 0 TO WS-TOTAL\n               PERFORM VARYING WS-STUDENT-CTR FROM 1 BY 1\n                   UNTIL WS-STUDENT-CTR > WS-NUM-STUDENTS\n                   ADD WS-GRADE(WS-STUDENT-CTR, WS-SUBJECT-CTR)\n                       TO WS-TOTAL\n               END-PERFORM\n               COMPUTE WS-SUBJ-AVG(WS-SUBJECT-CTR) =\n                   WS-TOTAL / WS-NUM-STUDENTS\n           END-PERFORM.\n       \n       WRITE-REPORT.\n\n           PERFORM VARYING WS-STUDENT-CTR FROM 1 BY 1\n               UNTIL WS-STUDENT-CTR > WS-NUM-STUDENTS\n               MOVE SPACES TO WS-OUTPUT-LINE\n                 MOVE WS-STUDENT-NAME(WS-STUDENT-CTR)\n                 TO WS-OUT-STUDENT-NAME\n                 PERFORM VARYING WS-SUBJECT-CTR FROM 1 BY 1\n                   UNTIL WS-SUBJECT-CTR > WS-NUM-SUBJECTS\n                   MOVE WS-GRADE(WS-STUDENT-CTR, WS-SUBJECT-CTR)\n                       TO WS-GRADE-DISPLAY(WS-SUBJECT-CTR)\n                                  END-PERFORM\n               MOVE WS-STUDENT-AVG(WS-STUDENT-CTR)\n                   TO WS-AVG-DISPLAY\n               MOVE WS-OUTPUT-LINE TO OUTPUT-RECORD\n               WRITE OUTPUT-RECORD\n           END-PERFORM.\n       \n       WRITE-SUBJECT-AVERAGES.\n\n           MOVE SPACES TO WS-OUTPUT-LINE\n           MOVE \"Average\" TO WS-OUT-STUDENT-NAME\n           PERFORM VARYING WS-SUBJECT-CTR FROM 1 BY 1\n               UNTIL WS-SUBJECT-CTR > WS-NUM-SUBJECTS\n               MOVE WS-SUBJ-AVG(WS-SUBJECT-CTR)\n                   TO WS-GRADE-DISPLAY(WS-SUBJECT-CTR)\n           END-PERFORM\n           MOVE WS-OUTPUT-LINE TO OUTPUT-RECORD\n           WRITE OUTPUT-RECORD.\n       \n       CLOSE-FILES.\n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "",
      "output_file_names": "task_func48_out",
      "inputs": {},
      "outputs": {
        "task_func48_out": "            Physics     Math        Chemistry   Biology     English     History     Comp Sci    Geography   Average Grade\nStudent_001    10   78    7   25   76   23   97   74   48.75\nStudent_002    79   11   62   89   78   17   88   77   62.62\nStudent_003    52  100   49   40   48   46   13    5   44.12\nStudent_004    65   69   37   43   55   15   86    9   47.37\nStudent_005    51  100    1    1   40   84   49   71   49.62\nStudent_006    60   70    4   30   50   43   48   12   39.62\nStudent_007    77   23   96   39   17   12    8   67   42.37\nStudent_008    68   90   47   79   14   25   77    6   50.75\nStudent_009    94   69   88   38   42    2   23   62   52.25\nStudent_010    38   16   86   25   99   64   59   54   55.12\nStudent_011    41   33   24   48    8   93   52   64   45.37\nStudent_012    22    5   21   81    8   96   44   99   47.00\nStudent_013    62    8   40   32   34   59   74   89   49.75\nStudent_014    88   60   27   58   27   27   73   86   55.75\nStudent_015    86   32   16   37   29   49   29   31   38.62\nStudent_016    97   93   57   96   37   21   39   55   61.87\nStudent_017    68   28   57   21   21   69   48   40   44.00\nStudent_018     1   66   39   18   34   73   71   17   39.87\nStudent_019    78   88    9   51   71   24   66   64   56.37\nStudent_020    52   11   17    4   80   22   68   76   41.25\nStudent_021    35   92   23   99   97   90    9   17   57.75\nStudent_022     3   32   58   34    6   35   76   25   33.62\nStudent_023    94   50   40   22   94   76   81   39   62.00\nStudent_024    64   63   32   71   32   71   20   25   47.25\nStudent_025    80   44   87    5   12   43   35    2   38.50\nStudent_026     4   23   17   27   78   68   72   12   37.62\nStudent_027    44   35   28   62   41   67   95   64   54.50\nStudent_028    69   72    1   71   75   28   72   81   58.62\nStudent_029    98   47   78   37   97   92   83   18   68.75\nStudent_030    34   53   26   14   64   76   82   82   53.87\nStudent_031     4   50   95   32   67   56   75    9   48.50\nStudent_032    40   53   99   12   76   15   25   86   50.75\nStudent_033    75   98   87   47   87   58   91   86   78.62\nStudent_034    71   99   80   46   38   82    1   81   62.25\nStudent_035    87   95   17   79   64   61   31   22   57.00\nStudent_036    26   60   26    8   48   37   11    2   27.25\nStudent_037     6   61   16    4   44   58   63   78   41.25\nStudent_038    73   65   50   85   29    8   83   83   59.50\nStudent_039     9   33   22   30   30   89   91    9   39.12\nStudent_040    94   61   62   83   87   45   84   68   73.00\nStudent_041    87   47   76    3   97    1   88   33   54.00\nStudent_042    70   61   78   98   90   13   14   59   60.37\nStudent_043    87   31   44   68   25    5   91   79   53.75\nStudent_044    85   96   18    4   15   33   25   66   42.75\nStudent_045    39   75   27   11   28   12   83    7   35.25\nStudent_046    17   26    7   29   17   75   74   14   32.37\nStudent_047    35    2   16   67   86   26   19   64   39.37\nStudent_048     2   66   37   44   89    2   89   64   49.12\nStudent_049    45   19   36   48   30   33   44   89   43.00\nStudent_050    98   39   48   53   27   33   46   48   49.00\nStudent_051    95   29   23   81   46   25   76   16   48.87\nStudent_052    53   51   76    1   42   89   91   18   52.62\nStudent_053    13   40   73   46   98   56   43   36   50.62\nStudent_054     5   42   37   30   34   98   38   88   46.50\nStudent_055    20    8   68   17   90   14   42   25   35.50\nStudent_056    40   64   28   35   49   80   27   37   45.00\nStudent_057    62   13   89   55   22    7   24   19   36.37\nStudent_058    47   98   85   69   59   33   40   92   65.37\nStudent_059    98    9   78   92   99   58   16   55   63.12\nStudent_060    37   76   73   99   64   23   48   53   59.12\nStudent_061    36   51   92   74   42   18   74   14   50.12\nStudent_062    51   85   57   59   19    6   74   69   52.50\nStudent_063    92   44   70   78   86   38   38   43   61.12\nStudent_064    62   25   31   63   23   99   58   31   49.00\nStudent_065    61   49   99   53   63   12    9   17   45.37\nStudent_066    91   88   60   40   30   97   42   73   65.12\nStudent_067    57   73   30   60    7   10    6   83   40.75\nStudent_068    78   76   67   36   76   61   85   65   68.00\nStudent_069    68   64   62   43   97   53   25    2   51.75\nStudent_070    38   53   90   20   23   79   24   71   49.75\nStudent_071    13   78   89   85   26   27   77   59   56.75\nStudent_072    41   93    5   92   32   29   12   75   47.37\nStudent_073    14   32   12   48   32   43   14   82   34.62\nStudent_074    96   13   80   23   71   68   33   25   51.12\nStudent_075    71   69   66   28   92    8   71   73   59.75\nStudent_076    65    3   67    6   59   30   71   92   49.12\nStudent_077    19   96   44   56   15   19   50   64   45.37\nStudent_078     8   79   24   30   78   62   56   12   43.62\nStudent_079    41   90   57   28   72   45   82   97   64.00\nStudent_080    58   21    7   75   13   40   72   60   43.25\nStudent_081    70   54   53   43   57   51   50   10   48.50\nStudent_082    22   94   29   29   81    9   32   25   40.12\nStudent_083    40   12   16   35   53   71   50   92   46.12\nStudent_084    75   50   10   70   44   45   36   93   52.87\nStudent_085    50   84   47   31   76   93   85    7   59.12\nStudent_086    72   43   34   12   64   55   40   11   41.37\nStudent_087    89   94   65   35   90   27   27   82   63.62\nStudent_088    37   78   69   69   43   81   94   45   64.50\nStudent_089    52   54   80   92   83    7   27   21   52.00\nStudent_090    76   94   23   63   25   54   41    1   47.12\nStudent_091    88   83   91   27    9   68   80   16   57.75\nStudent_092    48   46    8   21   26   29   59    5   30.25\nStudent_093    59   29   11    8   25   29   10   28   24.87\nStudent_094    73   64   16   73   68   10   64   91   57.37\nStudent_095    57   98   47   18    4   85   16   55   47.50\nStudent_096    90   85   71   21   64   27   43   98   62.37\nStudent_097    68   10   57   91   15   22   28    2   36.62\nStudent_098    44  100   93   26   71   25   15   81   56.87\nStudent_099    26   28   96   99   95   21   94   13   59.00\nStudent_100    85   83   78   30   13   80   30   34   54.12\nAverage        55   55   48   45   51   44   52   48\n"
      }
    },
    {
      "Program_name": "task_func_49",
      "Cobol_Eval": "Write a valid COBOL program that generates a CSV file named 'task_func_49_inp' containing 100 records with randomly generated data for name, age, height and weight. \n\nThe program should:\n- Follow the standard COBOL division structure with IDENTIFICATION DIVISION, DATA DIVISION, and PROCEDURE DIVISION\n- Adhere to COBOL Area A (columns 8-11) and Area B (columns 12-72) conventions for division headers, paragraph names and statements\n- Use standard COBOL indentation, especially in the PROCEDURE DIVISION, to improve readability\n\nIn the FILE SECTION, define a file description for the output CSV file.\n\nIn WORKING-STORAGE SECTION, define:  \n- A table of 5 sample names\n- Variables to store running totals and averages for age, height and weight\n- A variable for the CSV header record\n\nThe PROCEDURE DIVISION should:\n1. OPEN the output file and write the CSV header \n2. Loop 100 times:\n   - Randomly select a name from the table\n   - Generate random values for age (18-77), height (150-199 cm), and weight (50-99 kg) \n   - Write a record to the CSV file\n   - Update running totals\n3. Calculate averages for age, height and weight\n4. Write a final record with the calculated averages\n5. CLOSE the output file\n\nThe generated CSV file should have 101 records - a header row, 100 data rows, and a final row with calculated averages.\n\nFocus on the program's functionality and data handling. Don't include low-level implementation details or COBOL syntax specifics beyond the outlined structural and formatting conventions.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. GENERATE-CSV.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT OUTPUT-FILE ASSIGN TO 'task_func_49_inp'\n           ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       FILE SECTION.\n       FD  OUTPUT-FILE.\n       01  OUTPUT-RECORD.\n           05 OUT-NAME              PIC X(20).\n           05 OUT-AGE               PIC Z99.\n           05 OUT-HEIGHT            PIC ZZ9.99.\n           05 OUT-WEIGHT            PIC ZZ9.99.\n       \n       WORKING-STORAGE SECTION.\n       01  WS-COUNTERS.\n           05 WS-INDEX             PIC 9(3) VALUE 1.\n           05 WS-RANDOM            PIC 9(8) VALUE 0.\n       \n       01  WS-TOTALS.\n           05 WS-TOTAL-AGE         PIC 9(5) VALUE 0.\n           05 WS-TOTAL-HEIGHT      PIC 9(7)V99 VALUE 0.\n           05 WS-TOTAL-WEIGHT      PIC 9(7)V99 VALUE 0.\n       \n       01  WS-AVERAGES.\n           05 WS-AVG-AGE           PIC ZZ9.99.\n           05 WS-AVG-HEIGHT        PIC ZZ9.99.\n           05 WS-AVG-WEIGHT        PIC ZZ9.99.\n       \n       01  WS-NAMES.\n           05 FILLER              PIC X(20) VALUE 'John Smith'.\n           05 FILLER              PIC X(20) VALUE 'Mary Johnson'.\n           05 FILLER              PIC X(20) VALUE 'Robert Brown'.\n           05 FILLER              PIC X(20) VALUE 'Patricia Davis'.\n           05 FILLER              PIC X(20) VALUE 'Michael Wilson'.\n       01  WS-NAME-TABLE REDEFINES WS-NAMES.\n           05 WS-NAME             PIC X(20) OCCURS 5 TIMES.\n       \n       01  WS-HEADER             PIC X(50) \n           VALUE 'Name,Age,Height,Weight'.\n       \n       PROCEDURE DIVISION.\n       MAIN-PARA.\n           PERFORM INITIALIZATION-PARA\n           PERFORM PROCESS-PARA\n           PERFORM CLOSING-PARA\n           STOP RUN.\n       \n       INITIALIZATION-PARA.\n           OPEN OUTPUT OUTPUT-FILE\n           WRITE OUTPUT-RECORD FROM WS-HEADER\n           MOVE 1 TO WS-INDEX.\n       \n       PROCESS-PARA.\n           PERFORM UNTIL WS-INDEX > 100\n              COMPUTE WS-RANDOM = FUNCTION RANDOM * 5 + 1\n              MOVE WS-NAME(WS-RANDOM) TO OUT-NAME\n              \n              COMPUTE WS-RANDOM = FUNCTION RANDOM * 60 + 18\n              MOVE WS-RANDOM TO OUT-AGE\n              ADD WS-RANDOM TO WS-TOTAL-AGE\n              \n              COMPUTE WS-RANDOM = FUNCTION RANDOM * 50 + 150\n              MOVE WS-RANDOM TO OUT-HEIGHT\n              ADD WS-RANDOM TO WS-TOTAL-HEIGHT\n              \n              COMPUTE WS-RANDOM = FUNCTION RANDOM * 50 + 50\n              MOVE WS-RANDOM TO OUT-WEIGHT\n              ADD WS-RANDOM TO WS-TOTAL-WEIGHT\n              \n              WRITE OUTPUT-RECORD\n              ADD 1 TO WS-INDEX\n           END-PERFORM.\n       \n       CLOSING-PARA.\n           COMPUTE WS-AVG-AGE = WS-TOTAL-AGE / 100\n           COMPUTE WS-AVG-HEIGHT = WS-TOTAL-HEIGHT / 100\n           COMPUTE WS-AVG-WEIGHT = WS-TOTAL-WEIGHT / 100\n           \n           MOVE 'AVERAGES' TO OUT-NAME\n           MOVE WS-AVG-AGE TO OUT-AGE\n           MOVE WS-AVG-HEIGHT TO OUT-HEIGHT\n           MOVE WS-AVG-WEIGHT TO OUT-WEIGHT\n           WRITE OUTPUT-RECORD\n           \n           CLOSE OUTPUT-FILE.\n",
      "input_file_names": "",
      "output_file_names": "task_func_49_inp",
      "inputs": {},
      "outputs": {
        "task_func_49_inp": "Name,Age,Height,Weight\nPatricia Davis       52151.00 65.00\nPatricia Davis       75154.00 87.00\nPatricia Davis       61165.00 89.00\nPatricia Davis       51165.00 70.00\nJohn Smith           55196.00 65.00\nMichael Wilson       19189.00 65.00\nPatricia Davis       50181.00 64.00\nMary Johnson         25152.00 59.00\nMary Johnson         49179.00 52.00\nMary Johnson         57173.00 74.00\nMary Johnson         52161.00 93.00\nJohn Smith           65192.00 94.00\nRobert Brown         49153.00 65.00\nMichael Wilson       69176.00 92.00\nJohn Smith           19162.00 53.00\nJohn Smith           20181.00 83.00\nPatricia Davis       26160.00 93.00\nMichael Wilson       56164.00 92.00\nJohn Smith           30197.00 94.00\nPatricia Davis       63155.00 82.00\nPatricia Davis       28178.00 77.00\nPatricia Davis       76174.00 97.00\nMichael Wilson       62179.00 86.00\nMichael Wilson       25190.00 73.00\nMary Johnson         28172.00 75.00\nMichael Wilson       65180.00 84.00\nMichael Wilson       54196.00 55.00\nRobert Brown         76194.00 78.00\nMichael Wilson       62173.00 61.00\nMichael Wilson       38154.00 89.00\nRobert Brown         64151.00 71.00\nMichael Wilson       45155.00 63.00\nPatricia Davis       26160.00 80.00\nJohn Smith           61189.00 60.00\nJohn Smith           25168.00 91.00\nJohn Smith           64181.00 72.00\nRobert Brown         46158.00 95.00\nMichael Wilson       76192.00 88.00\nJohn Smith           29194.00 72.00\nMichael Wilson       49189.00 71.00\nPatricia Davis       66191.00 88.00\nMichael Wilson       57184.00 79.00\nJohn Smith           47179.00 66.00\nMary Johnson         52185.00 81.00\nJohn Smith           38198.00 52.00\nMary Johnson         45173.00 73.00\nPatricia Davis       65181.00 63.00\nJohn Smith           27199.00 58.00\nMary Johnson         50181.00 55.00\nRobert Brown         31190.00 75.00\nMichael Wilson       36163.00 92.00\nMary Johnson         77199.00 70.00\nPatricia Davis       19154.00 92.00\nJohn Smith           28180.00 70.00\nPatricia Davis       19163.00 53.00\nJohn Smith           31161.00 54.00\nMary Johnson         21192.00 71.00\nMichael Wilson       60195.00 60.00\nRobert Brown         55179.00 82.00\nMichael Wilson       38160.00 61.00\nRobert Brown         50182.00 79.00\nPatricia Davis       35176.00 86.00\nRobert Brown         72191.00 86.00\nPatricia Davis       39187.00 99.00\nPatricia Davis       76152.00 67.00\nPatricia Davis       35185.00 59.00\nMary Johnson         25176.00 97.00\nPatricia Davis       49192.00 66.00\nRobert Brown         20156.00 90.00\nPatricia Davis       46157.00 72.00\nPatricia Davis       34185.00 84.00\nMichael Wilson       27155.00 93.00\nRobert Brown         35197.00 75.00\nJohn Smith           65174.00 99.00\nRobert Brown         58191.00 91.00\nMary Johnson         61190.00 61.00\nRobert Brown         48190.00 61.00\nPatricia Davis       49199.00 67.00\nJohn Smith           35162.00 78.00\nRobert Brown         68198.00 83.00\nPatricia Davis       68199.00 83.00\nMary Johnson         59169.00 51.00\nJohn Smith           18159.00 53.00\nPatricia Davis       73157.00 60.00\nRobert Brown         69173.00 87.00\nJohn Smith           74181.00 68.00\nPatricia Davis       28198.00 99.00\nRobert Brown         48199.00 94.00\nPatricia Davis       71163.00 86.00\nMichael Wilson       48157.00 57.00\nRobert Brown         73156.00 92.00\nRobert Brown         53199.00 94.00\nPatricia Davis       43197.00 94.00\nJohn Smith           50164.00 59.00\nPatricia Davis       48176.00 67.00\nMichael Wilson       49164.00 82.00\nJohn Smith           61184.00 72.00\nJohn Smith           77166.00 70.00\nRobert Brown         71188.00 90.00\nMary Johnson         75162.00 68.00\nAVERAGES             48176.46 75.83\n"
      }
    },
    {
      "Program_name": "task_func_55",
      "Cobol_Eval": "Write a valid COBOL program that reads data values from an input file named 'original_data.txt', identifies and removes outlier values, and writes the cleaned data to an output file named 'data_without_outliers.txt'. The program should also output the indices of the removed outlier values to a separate file named 'outlier_indices.txt'.\n\nThe program should consist of the standard COBOL divisions:\n- IDENTIFICATION DIVISION with an appropriate PROGRAM-ID \n- ENVIRONMENT DIVISION to define the input and output files\n- DATA DIVISION to define the file and working storage data structures\n- PROCEDURE DIVISION containing the main program logic\n\nWithin the PROCEDURE DIVISION, organize the code into paragraphs and sections as needed. Use COBOL's Area A (columns 8-11) for division headers and paragraph names, and Area B (columns 12-72) for statements. Apply consistent indentation, especially in the PROCEDURE DIVISION, to enhance readability.\n\nThe program should perform the following key steps:\n1. Read the data values from 'original_data.txt' \n2. Calculate the mean and standard deviation of the data\n3. Identify outliers based on each value's Z-score exceeding a defined threshold\n4. Write the outlier indices to 'outlier_indices.txt'\n5. Write the cleaned data without the outliers to 'data_without_outliers.txt'\n\nEnsure the program handles opening and closing the files properly and uses appropriate COBOL syntax throughout. The specific algorithms for calculating statistics and identifying outliers are left to your discretion.\n\nCode:\n",
      "Expected_Program": "       IDENTIFICATION DIVISION.\n       PROGRAM-ID. REMOVE-OUTLIERS.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT ORIGINAL-FILE ASSIGN TO 'original_data.txt' .\n           SELECT CLEAN-FILE ASSIGN TO 'data_without_outliers.txt'.\n           SELECT INDEX-FILE ASSIGN TO 'outlier_indices.txt' .\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  ORIGINAL-FILE.\n       01  ORIGINAL-RECORD.\n           05  ORIGINAL-VALUE  PIC 9(5) .\n           \n\n       FD  CLEAN-FILE.\n       01  CLEAN-RECORD.\n           05  CLEAN-VALUE     PIC 9(5) .\n            \n\n       FD  INDEX-FILE.\n       01  INDEX-RECORD.\n           05  OUTLIER-INDEX   PIC 9(5).\n            \n\n       WORKING-STORAGE SECTION.\n       01  WS-COUNTERS.\n           05  RECORD-INDEX    PIC 9(5) VALUE 0.\n           05  OUTLIER-COUNT   PIC 9(5) VALUE 0.\n           05  TOTAL-COUNT     PIC 9(5) VALUE 0.\n           05  EOF             PIC 9 VALUE 0.\n\n       01  WS-VALUES.\n           05  WS-DATA         OCCURS 100 TIMES.\n               10  WS-VALUE    PIC 9(5)V99.\n\n       01  WS-STATS.\n           05  WS-MEAN         PIC S9(5)V99 VALUE 0.\n           05  WS-SUM          PIC S9(10)V99 VALUE 0.\n           05  WS-STDDEV       PIC S9(5)V99 VALUE 0.\n           05  WS-VARIANCE     PIC S9(10)V99 VALUE 0.\n           05  WS-Z-SCORE      PIC S9(5)V99 VALUE 0.\n           05  Z-SCORE-THRESHOLD PIC S9(5)V99 VALUE 3.00.\n\n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           OPEN INPUT ORIGINAL-FILE\n           OPEN OUTPUT CLEAN-FILE\n           OPEN OUTPUT INDEX-FILE\n\n           PERFORM READ-AND-CALCULATE\n           PERFORM CALCULATE-MEAN\n           PERFORM CALCULATE-STDDEV\n           PERFORM IDENTIFY-OUTLIERS\n           PERFORM WRITE-RESULTS\n\n           CLOSE ORIGINAL-FILE\n           CLOSE CLEAN-FILE\n           CLOSE INDEX-FILE\n           GOBACK.\n\n       READ-AND-CALCULATE.\n           initialize clean-value\n                      OUTLIER-INDEX\n           display 'read-and-calculate'\n           MOVE 0 TO RECORD-INDEX\n           MOVE 0 TO WS-SUM \n           PERFORM UNTIL EOF = 1\n               READ ORIGINAL-FILE INTO ORIGINAL-RECORD\n               AT END\n                   MOVE 1 TO EOF\n               NOT AT END\n                   ADD 1 TO RECORD-INDEX\n                    \n                   MOVE ORIGINAL-VALUE TO WS-VALUE(RECORD-INDEX)\n                   ADD ORIGINAL-VALUE TO WS-SUM\n               END-READ\n           END-PERFORM\n           MOVE RECORD-INDEX TO TOTAL-COUNT.\n\n       CALCULATE-MEAN.\n           display 'calculate mean'\n           IF TOTAL-COUNT NOT = 0\n               COMPUTE WS-MEAN = WS-SUM / TOTAL-COUNT\n           END-IF\n           display 'mean is:' WS-MEAN.\n\n       CALCULATE-STDDEV.\n           display 'calculate stddev'\n           PERFORM VARYING RECORD-INDEX FROM 1 BY 1\n           UNTIL RECORD-INDEX > TOTAL-COUNT\n               COMPUTE WS-VARIANCE = WS-VARIANCE +\n          (WS-VALUE(RECORD-INDEX) - WS-MEAN) ** 2\n           END-PERFORM\n           DISPLAY 'total count is:' total-count\n           IF TOTAL-COUNT NOT = 0\n               COMPUTE WS-STDDEV = FUNCTION \n               SQRT(WS-VARIANCE / TOTAL-COUNT)\n           END-IF\n             .\n\n       IDENTIFY-OUTLIERS.\n           display 'identify-outliers'\n           MOVE 0 TO RECORD-INDEX\n           PERFORM UNTIL RECORD-INDEX > TOTAL-COUNT\n               ADD 1 TO RECORD-INDEX\n               COMPUTE WS-Z-SCORE =\n               (WS-VALUE(RECORD-INDEX) - WS-MEAN) / WS-STDDEV\n                 \n               IF FUNCTION ABS(WS-Z-SCORE) > Z-SCORE-THRESHOLD\n                   ADD 1 TO OUTLIER-COUNT\n                   MOVE RECORD-INDEX TO OUTLIER-INDEX\n                    \n                   WRITE INDEX-RECORD FROM OUTLIER-INDEX\n               ELSE\n                   if WS-VALUE(RECORD-INDEX) > 0\n                     MOVE WS-VALUE(RECORD-INDEX) TO CLEAN-VALUE\n                      \n                     WRITE CLEAN-RECORD FROM CLEAN-VALUE\n                      \n                   end-if \n               END-IF\n           END-PERFORM.\n\n       WRITE-RESULTS.\n           display 'write-results'\n           PERFORM VARYING RECORD-INDEX FROM 1 BY 1 UNTIL\n           RECORD-INDEX > TOTAL-COUNT\n               MOVE WS-VALUE(RECORD-INDEX) TO ORIGINAL-VALUE\n               WRITE ORIGINAL-RECORD FROM ORIGINAL-VALUE\n           END-PERFORM.\n\n",
      "input_file_names": [
        "original_data.txt",
        "outlier_indices.txt"
      ],
      "output_file_names": "data_without_outliers.txt",
      "inputs": {
        "original_data.txt": "04679\n20976\n23467\n00233\n01673",
        "outlier_indices.txt": ""
      },
      "outputs": {
        "data_without_outliers.txt": "04679\n20976\n23467\n00233\n016730"
      }
    }
  ]